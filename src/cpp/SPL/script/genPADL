#!/usr/bin/env perl

#
# Copyright 2021 IBM Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

package Globals;
use strict;
our $doc = undef;
our @elementStack = [];
our $verbose = 0;
our $physicalADL = 0;
our $trace = 0;
our $functionIndent = 0;
our $mainComposite = undef;
our $currentPE = undef;
our %operInstances;
our $parallelRegions = undef;
our $maxOperIndex = 0;
our @modelOperators;
our @physicalOperators;
our $physicalOperatorMaxIndex = 0;
our @physicalPEs;
our $physicalPEMaxIndex = 0;
our $physicalADL = 0;
our %importOperatorInfoMap;
our %exportOperatorInfoMap;


#####################################################
package GraphArc;
use strict;
use Data::Dumper;

sub new
{
    my ($class, $fromOperIndex, $fromPortIndex, $fromPortKind, $toOperIndex, $toPortIndex, $toPortKind, $color) = @_;
    my $self = {};
    $self->{_fromOperIndex} = $fromOperIndex;
    $self->{_fromPortIndex} = $fromPortIndex;
    $self->{_fromPortKind} = $fromPortKind;
    $self->{_toOperIndex} = $toOperIndex;
    $self->{_toPortIndex} = $toPortIndex;
    $self->{_toPortKind} = $toPortKind;
    $self->{_color} = $color;
    bless $self, $class;
    return $self;
}


sub render
{
    my ($self, $fh) = @_;
    my $fromID = "oper_".$self->{_fromOperIndex};
    my $toID = "oper_".$self->{_toOperIndex};
    my $fromPort = ($self->{_fromPortKind} eq "output") ? "oport" : "iport";
    $fromPort .= $self->{_fromPortIndex};
    my $toPort = ($self->{_toPortKind} eq "output") ? "oport" : "iport";
    $toPort .= $self->{_toPortIndex};
    print $fh "   \"$fromID\":$fromPort -> \"$toID\":$toPort [ color = \"$self->{_color}\" ];\n";
}

1;
#####################################################
package GraphNode;
use strict;

sub new
{
    my ($class, $node, $color) = @_;
    my $self = {};
    $self->{_index} = $node->{index};
    $self->{_node} = $node;
    $self->{_id} = "oper_".$node->index();
    bless $self, $class;
    return $self;
}

sub render
{
    die("This must be overridden");
}

1;
#####################################################
package OperatorGraphNode;
use strict;
our @ISA = qw(GraphNode);

sub new
{
    my ($class, $operator, $color) = @_;
    my $self = $class->SUPER::new($operator, $color);
    bless $self, $class;
    return $self;
}

sub render
{
    my ($self, $fh) = @_;
    my $iPortCount = $self->{_node}->numberOfInputPorts();
    my $oPortCount = $self->{_node}->numberOfOutputPorts();
    my $label = $self->{_node}->name();
    print $fh "   \"$self->{_id}\" [ label=\"$label ";
    for (my $i = 0; $i < $iPortCount; ++$i) {
        print $fh " | <iport$i> iport$i";
    }
    for (my $i = 0; $i < $oPortCount; ++$i) {
        print $fh " | <oport$i> oport$i";
    }
    print $fh "\" shape=\"record\" ];\n";
}

1;
#####################################################
package Graph;
use strict;

sub new
{
    my ($class) = @_;
    my $self = {};
    $self->{_nodes} = [];
    $self->{_arcs} = [];
    bless $self, $class;
    return $self;
}

sub addNode
{
    my ($self, $node) = @_;
    push(@{$self->{_nodes}}, $node);
}

sub addArc
{
    my ($self, $arc) = @_;
    push(@{$self->{_arcs}}, $arc);
}

sub render
{
    my ($self, $fh) = @_;
    print $fh "digraph G {\n";
    print $fh "   rankdir=LR;\n";
    foreach my $node (@{$self->{_nodes}}) {
        $node->render($fh);
    }
    foreach my $arc (@{$self->{_arcs}}) {
        $arc->render($fh);
    }
    print $fh "}\n";
}


1;
#####################################################
#####################################################
#####################################################
package PhysicalNode;
use strict;
use Carp qw(longmess);
use Data::Dumper;

sub indent
{
   my ($self, $indent) = @_;
   for (my $i = 0; $i < $indent; ++$i) {
      print " ";
   }
}

sub print
{
    my ($self, $indent, $string) = @_;
    $self->indent($indent);
    print $string;
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    my $kind = ref($self);
    my $stackTrace = longmess();
    print STDERR Dumper($stackTrace);
    die("genPhysicalADL must be overridden for $kind");
}


1;
#####################################################
package PhysicalPEPort;
use strict;
use Data::Dumper;
our @ISA = qw(PhysicalNode);

sub new
{
    my ($class, $index, $owningPhysicalPE, $physOperIndex, $physOperPort) = @_;
    my $self = {};
    $self->{_index} = $index;
    $self->{_owningPhysicalPE} = $owningPhysicalPE;
    $self->{_physOperIndex} = $physOperIndex;
    $self->{_physOperPort} = $physOperPort;
    $self->{_physOperPortIndex} = $physOperPort->index();
    $self->{_staticConnections} = [];
    bless $self, $class;
    return $self;
}

sub physicalPort
{
    my ($self) = @_;
    die("Internal error") unless defined($self->{_physOperPort});
    return $self->{_physOperPort};
}

sub index
{
    my ($self) = @_;
    return $self->{_index};
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;

    if (scalar @{$self->{_staticConnections}} > 0) {
        $self->print($indent, "<staticConnections>\n");
        $indent += 3;
        foreach my $conn (@{$self->{_staticConnections}}) {
           $conn->genPhysicalADL($indent);
        }
        $indent -= 3;
        $self->print($indent, "</staticConnections>\n");
    } else {
        $self->print($indent, "<staticConnections/>\n");
    }
}
1;
#####################################################
package PhysicalPEInputPort;
use strict;
use Data::Dumper;
our @ISA = qw(PhysicalPEPort);

sub new
{
    my ($class, $index, $owningPhysicalPE, $physOperIndex, $physOperIPort) = @_;
    my $self = $class->SUPER::new($index, $owningPhysicalPE, $physOperIndex, $physOperIPort);
    $self->{_imports} = [];
    foreach my $modelImport (@{$physOperIPort->{_imports}}) {
        my $physicalImport = $modelImport->physicalImport(scalar @{$self->{_imports}});
        push(@{$self->{_imports}}, $physicalImport);
    }
    bless $self, $class;
    return $self;
}

sub buildStaticConnections
{
    my ($self) = @_;
    print STDERR "Building static connections for PE $self->{_owningPhysicalPE}->{_index}, input port $self->{_index}\n" if ($Globals::verbose);
    my $physOper = $Globals::physicalOperators[$self->{_physOperIndex}];
    my $connections = $physOper->getInputConnections($self->{_physOperPortIndex});
    foreach my $conn (@{$connections}) {
        my $toPhysOperIndex = $conn->{_toPhysicalOperIndex};
        my $toPhysOper = $Globals::physicalOperators[$toPhysOperIndex];
        my $toPE = $toPhysOper->owningPE();
        # We don't care about intra-pe connections
        next if ($toPE->index() == $self->{_owningPhysicalPE}->index());

        my $toPEOutputPort;
        if (defined($conn->{_splitterIndex})) {
            $toPEOutputPort = $toPhysOper->getSplitterPEOutputPort($conn->{_toOperPortIndex}, $conn->{_splitterIndex}, $conn->{_channelIndex});
        } else {
            $toPEOutputPort = $toPhysOper->getPEOutputPort($conn->{_toOperPortIndex});
        }
        my $toPEOutputPortIndex = $toPEOutputPort->index();
        my $newStaticInputConnection = ModelStaticInputConnection->new($toPE->index(), $toPEOutputPortIndex);
        push(@{$self->{_staticConnections}}, $newStaticInputConnection);
    }
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    my $physOperPort = $self->physicalPort();
    my $modelPort = $physOperPort->modelPort();
    my $index = $self->{_index};
    my $tupleTypeIndex = $modelPort->{_tupleTypeIndex};
    my $encoding = $modelPort->{_encoding};
    my $transport = $modelPort->{_transport};
    $self->print($indent, "<inputPort index=\"$index\" tupleTypeIndex=\"$tupleTypeIndex\" encoding=\"$encoding\" transport=\"$transport\">\n");
    $indent +=3;
    if (scalar @{$self->{_imports}} > 0) {
        my $lastImport = $self->{_imports}->[-1];
        my $filter = $lastImport->filter();
        $self->print($indent, "<importedStreams");
        if (defined($filter)) {
            $filter =~ s/&/&amp;/g;
            $filter =~ s/\"/&quot;/g;
            $filter =~ s/\</&lt;/g;
            $self->print(0, " filter=\"$filter\"");
        }
        $self->print(0, ">\n");
        $indent +=3;
        foreach my $import (@{$self->{_imports}}) {
            $import->genPhysicalADL($indent);
        }
        $indent -=3;
        $self->print($indent, "</importedStreams>\n");
    }
    $self->SUPER::genPhysicalADL($indent);
    $self->print($indent, "<operInstanceConnection operInstanceIndex=\"$self->{_physOperIndex}\" iportIndex=\"$self->{_physOperPortIndex}\"/>\n");
    $indent -=3;
    $self->print($indent, "</inputPort>\n");
}

1;
#####################################################
package PhysicalPEOutputPort;
use strict;
use Data::Dumper;
our @ISA = qw(PhysicalPEPort);

sub new
{
    my ($class, $index, $owningPhysicalPE, $physOperIndex, $physOperOPort) = @_;
    my $self = $class->SUPER::new($index, $owningPhysicalPE, $physOperIndex, $physOperOPort);
    $self->{_exports} = [];
    foreach my $modelExport (@{$physOperOPort->{_exports}}) {
        my $physicalExport = $modelExport->physicalExport();
        push(@{$self->{_exports}}, $physicalExport);
    }
    bless $self, $class;
    return $self;
}

sub buildStaticConnections
{
    my ($self) = @_;
    my $physOper = $Globals::physicalOperators[$self->{_physOperIndex}];
    my $connections = $physOper->getOutputConnections($self->{_physOperPortIndex});
    foreach my $conn (@{$connections}) {
        my $toPhysOperIndex = $conn->{_toPhysicalOperIndex};
        my $toPhysOper = $Globals::physicalOperators[$toPhysOperIndex];
        my $toPE = $toPhysOper->owningPE();
        next if ($toPE->index() == $self->{_owningPhysicalPE}->index());
        my $toPEInputPort = $toPhysOper->getPEInputPort($conn->{_toOperPortIndex});
        my $toPEInputPortIndex = $toPEInputPort->index();
        my $newStaticOutputConnection = ModelStaticOutputConnection->new($toPEInputPort->{_owningPhysicalPE}->index(), $toPEInputPortIndex);
        push(@{$self->{_staticConnections}}, $newStaticOutputConnection);
    }
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    my $physicalPort = $self->physicalPort();
    my $modelPrimitiveOperOutputPort = $physicalPort->modelPort();
    my $index = $self->{_index};
    my $encoding = $modelPrimitiveOperOutputPort->{_encoding};
    my $transport = $modelPrimitiveOperOutputPort->{_transport};
    my $singleThreadedOnOutput = $modelPrimitiveOperOutputPort->{_singleThreadedOnOutput};
    my $tupleTypeIndex = $modelPrimitiveOperOutputPort->{_tupleTypeIndex};
    $self->print($indent, "<outputPort index=\"$index\" encoding=\"$encoding\" transport=\"$transport\" singleThreadedOnOutput=\"$singleThreadedOnOutput\" tupleTypeIndex=\"$tupleTypeIndex\">\n");
    $indent += 3;
    if (scalar @{$self->{_exports}} > 0) {
        die("Internal error") if (scalar @{$self->{_exports}} != 1);
        my $export = $self->{_exports}->[0];
        $export->genPhysicalADL($indent);
    }
    $self->SUPER::genPhysicalADL($indent);
    $self->print($indent, "<operInstanceConnection operInstanceIndex=\"$self->{_physOperIndex}\" oportIndex=\"$self->{_physOperPortIndex}\"/>\n");
    $indent -= 3;
    $self->print($indent, "</outputPort>\n");
}

1;
#####################################################
package ModelStaticInputConnection;
use strict;
use Data::Dumper;
our @ISA = qw(PhysicalNode);

sub new
{
    my ($class, $physPEIndex, $portIndex) = @_;
    my $self = {};
    $self->{_physPEIndex} = $physPEIndex;
    $self->{_portIndex} = $portIndex;
    print STDERR "Creating static connection from PE $self->{_physPEIndex} oport $self->{_portIndex}\n" if ($Globals::verbose);
    bless $self, $class;
    return $self;
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<staticConnection oportIndex=\"$self->{_portIndex}\" peIndex=\"$self->{_physPEIndex}\"/>\n");
}

1;
#####################################################
package ModelStaticOutputConnection;
use strict;
use Data::Dumper;
our @ISA = qw(PhysicalNode);

sub new
{
    my ($class, $physPEIndex, $portIndex) = @_;
    my $self = {};
    $self->{_physPEIndex} = $physPEIndex;
    $self->{_portIndex} = $portIndex;
    bless $self, $class;
    return $self;
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<staticConnection iportIndex=\"$self->{_portIndex}\" peIndex=\"$self->{_physPEIndex}\"/>\n");
}

1;
#####################################################
package PhysicalPESplitterOutputPort;
use strict;
use Data::Dumper;
our @ISA = qw(PhysicalPEPort);

sub new
{
    my ($class, $index, $owningPhysicalPE, $physOperIndex, $physOperOPort, $splitterIndex, $channelIndex) = @_;
    my $self = $class->SUPER::new($index, $owningPhysicalPE, $physOperIndex, $physOperOPort);
    $self->{_splitterIndex} = $splitterIndex;
    $self->{_channelIndex} = $channelIndex;
    bless $self, $class;
    return $self;
}

sub buildStaticConnections
{
    my ($self) = @_;
    my $physOper = $Globals::physicalOperators[$self->{_physOperIndex}];
    my $connections = $physOper->getSplitterConnections($self->{_physOperPortIndex}, $self->{_splitterIndex}, $self->{_channelIndex});
    foreach my $conn (@{$connections}) {
        my $toPhysOperIndex = $conn->{_toPhysicalOperIndex};
        my $toPhysOper = $Globals::physicalOperators[$toPhysOperIndex];
        my $toPEInputPort = $toPhysOper->getPEInputPort($conn->{_toOperPortIndex});
        my $toPEInputPortIndex = $toPEInputPort->index();
        my $newStaticOutputConnection = ModelStaticOutputConnection->new($toPEInputPort->{_owningPhysicalPE}->index(), $toPEInputPortIndex);
        push(@{$self->{_staticConnections}}, $newStaticOutputConnection);
    }
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    my $physOperIndex = $self->{_physOperIndex};
    my $physOper = $Globals::physicalOperators[$physOperIndex];
    my $modelPrimitiveOper = $physOper->{_modelPrimitiveOperator};
    my $modelPrimitiveOperOutputPort = $modelPrimitiveOper->getOPort($self->{_physOperPortIndex});
    my $index = $self->{_index};
    my $encoding = $modelPrimitiveOperOutputPort->{_encoding};
    my $transport = $modelPrimitiveOperOutputPort->{_transport};
    my $singleThreadedOnOutput = $modelPrimitiveOperOutputPort->{_singleThreadedOnOutput};
    my $tupleTypeIndex = $modelPrimitiveOperOutputPort->{_tupleTypeIndex};

    $self->print($indent, "<outputPort index=\"$index\" encoding=\"$encoding\" transport=\"$transport\" singleThreadedOnOutput=\"$singleThreadedOnOutput\" tupleTypeIndex=\"$tupleTypeIndex\">\n");
    $indent += 3;
    $self->SUPER::genPhysicalADL($indent);
    $self->print($indent, "<operInstanceConnection operInstanceIndex=\"$self->{_physOperIndex}\" oportIndex=\"$self->{_physOperPortIndex}\" splitterIndex=\"$self->{_splitterIndex}\" channelIndex=\"$self->{_channelIndex}\"/>\n");
    $indent -= 3;
    $self->print($indent, "</outputPort>\n");
}

1;
#####################################################
package PhysicalPE;
use strict;
use Data::Dumper;
our @ISA = qw(PhysicalNode);

sub new
{
    my ($class, $logicalPE) = @_;
    my $self = {};
    $self->{_logicalPE} = $logicalPE;
    $self->{_index} = $Globals::physicalPEMaxIndex++;
    $self->{_logicalIndex} = $self->{_index};
    $self->{_class} = $logicalPE->{class};
    $self->{_inputPorts} = [];
    $self->{_outputPorts} = [];
    $self->{_operators} = [];
    $Globals::physicalPEs[$self->{_index}] = $self;
    bless $self, $class;
    return $self;
}

sub replicate
{
    my ($self) = @_;
    my $replica = {};
    $replica->{_index} = $Globals::physicalPEMaxIndex++;
    $replica->{_logicalIndex} = $self->{_logicalIndex};
    $replica->{_logicalPE} = $self->{_logicalPE};
    $replica->{_class} = $self->{_class};
    $replica->{_inputPorts} = [];
    $replica->{_outputPorts} = [];
    $replica->{_operators} = [];
    push(@Globals::physicalPEs, $replica);
    bless($replica, 'PhysicalPE');
    return $replica;
}

sub index
{
    my ($self) = @_;
    return $self->{_index};
}

sub setParallelRegionInfo
{
    my ($self, $regionIndex, $channelIndex) = @_;
    $self->{_regionIndex} = $regionIndex;
    $self->{_channelIndex} = $channelIndex;
}

sub allocateInputPort
{
    my ($self, $physOperIndex, $physOperIPort) = @_;
    my $newPort = PhysicalPEInputPort->new(scalar @{$self->{_inputPorts}}, $self, $physOperIndex, $physOperIPort);
    push(@{$self->{_inputPorts}}, $newPort);
    return $newPort;
}

sub allocateSplitterOutputPort
{
    my ($self, $physOperIndex, $physOperOPort, $splitterIndex, $channelIndex) = @_;
    my $newPort = PhysicalPESplitterOutputPort->new(scalar @{$self->{_outputPorts}}, $self, $physOperIndex, $physOperOPort, $splitterIndex, $channelIndex);
    push(@{$self->{_outputPorts}}, $newPort);
    return $newPort;
}

sub allocateOutputPort
{
    my ($self, $physOperIndex, $physOperOPort) = @_;
    my $newPort = PhysicalPEOutputPort->new(scalar @{$self->{_outputPorts}}, $self, $physOperIndex, $physOperOPort);
    push(@{$self->{_outputPorts}}, $newPort);
    return $newPort;
}

# Add the static inter-pe connections
sub buildStaticConnections
{
    my ($self) = @_;
    print STDERR "Building static connections for physical PE $self->{_index}\n" if ($Globals::verbose);
    foreach my $iPort (@{$self->{_inputPorts}}) {
        $iPort->buildStaticConnections();
    }
    foreach my $oPort (@{$self->{_outputPorts}}) {
        $oPort->buildStaticConnections();
    }
}

sub allocatePorts
{
    my ($self) = @_;
    print STDERR "Allocating ports for PE index $self->{_index}\n" if ($Globals::verbose);
    foreach my $oper (@{$self->{_operators}}) {
        # Walk the input ports and see what we need to allocate
        my $inputPorts = $oper->{_inputPorts};
        foreach my $iPort (@{$inputPorts}) {
            # If there are any inter-pe connections we need an input port
            if ($iPort->hasInterPEConnections() || $iPort->hasImports()) {
                # We have an inter-pe call.  Add a port
                my $newPEIport = $self->allocateInputPort($oper->index(), $iPort);
                $iPort->setPEPort($newPEIport);
            }
        }
        my $outputPorts = $oper->{_outputPorts};
        foreach my $oPort (@{$outputPorts}) {
            # For output ports we may need to allocate more than one
            # We need one output port for each direct inter-pe connection, and one for each 
            # splitter output channel
            my $splitters = $oPort->{_splitters};
            foreach my $splitter (@{$splitters}) {
                if ($splitter->hasInterPEConnections()) {
                    my $parallelChannels = $splitter->{_parallelChannels};
                    foreach my $channel (@{$parallelChannels}) {
                        my $newPEOport = $self->allocateSplitterOutputPort($oper->index(), $oPort, $splitter->index(), $channel->index());
                        $channel->setPEPort($newPEOport);
                    }
                }
            }
            if ($oPort->hasNonSplitterInterPEConnections() || $oPort->hasExport()) {
                my $newPEOport = $self->allocateOutputPort($oper->index(), $oPort);
                $oPort->setPEPort($newPEOport);
            }
        }
    }
}

sub addOperator
{
    my ($self, $operator) = @_;
    push(@{$self->{_operators}}, $operator);
    $operator->setOwningPE($self);
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    my $class = $self->{_logicalPE}->{class};
    my $language = $self->{_logicalPE}->{language};
    my $optimized = $self->{_logicalPE}->{optimized};
    my $relocatable = $self->{_logicalPE}->{relocatable};
    my $restartable = $self->{_logicalPE}->{restartable};
    $self->print($indent, "<pe class=\"$class\" index=\"$self->{_index}\" logicalIndex=\"$self->{_logicalIndex}\" language=\"$language\" optimized=\"$optimized\" relocatable=\"$relocatable\" restartable=\"$restartable\"");
    if (defined($self->{_regionIndex})) {
        $self->print(0, " regionIndex=\"$self->{_regionIndex}\" channelIndex=\"$self->{_channelIndex}\"");
    }
    $self->print(0, " xsi:type=\"physical:physPEType\">\n");

    $indent += 3;
    $self->{_logicalPE}->{_envVars}->gen($indent);
    $self->{_logicalPE}->{_executable}->gen($indent);

    $self->print($indent, "<operInstances>\n");
    $indent += 3;
    foreach my $oper (@{$self->{_operators}}) { $oper->genPhysicalADL($indent); }
    $indent -= 3;
    $self->print($indent, "</operInstances>\n");

    $self->{_logicalPE}->{_display}->gen($indent) if defined($self->{_logicalPE}->{_display});
    $self->{_logicalPE}->{_tracing}->gen($indent) if defined($self->{_logicalPE}->{_tracing});

    if (scalar @{$self->{_inputPorts}} == 0) {
        $self->print($indent, "<inputPorts/>\n");
    } else {
        $self->print($indent, "<inputPorts>\n");
        $indent += 3;
        foreach my $iPort (@{$self->{_inputPorts}}) { $iPort->genPhysicalADL($indent); }
        $indent -= 3;
        $self->print($indent, "</inputPorts>\n");
    }
    if (scalar @{$self->{_outputPorts}} == 0) {
        $self->print($indent, "<outputPorts/>\n");
    } else {
        $self->print($indent, "<outputPorts>\n");
        $indent += 3;
        foreach my $oPort (@{$self->{_outputPorts}}) { $oPort->genPhysicalADL($indent); }
        $indent -= 3;
        $self->print($indent, "</outputPorts>\n");
    }
    $indent -= 3;
    $self->print($indent, "</pe>\n");
}

1;
#####################################################
package PhysicalConnection;
use strict;
use Data::Dumper;
our @ISA = qw(PhysicalNode);

sub new
{
    my ($class, $fromPhysicalOperIndex, $fromOperPortIndex, $toPhysicalOperIndex, $toOperPortIndex, $portType) = @_;
    my $self = {};
    bless $self, $class;
    $self->{_fromPhysicalOperIndex} = $fromPhysicalOperIndex;
    $self->{_fromOperPortIndex} = $fromOperPortIndex;
    $self->{_toPhysicalOperIndex} = $toPhysicalOperIndex;
    $self->{_toOperPortIndex} = $toOperPortIndex;
    $self->{_portType} = $portType;
    print STDERR "Creating operator connection from operator index $fromPhysicalOperIndex, port $fromOperPortIndex to operator index $toPhysicalOperIndex, port $toOperPortIndex, of type $portType\n" if ($Globals::verbose);
    return $self;
}

sub isInterPE
{
    my ($self, $owningOperator) = @_;
    my $toOperatorIndex = $self->{_toPhysicalOperIndex};
    my $toOper = $Globals::physicalOperators[$toOperatorIndex];
    my $fromOperatorIndex = $self->{_fromPhysicalOperIndex};
    my $fromOper = $Globals::physicalOperators[$fromOperatorIndex];
    if ($toOper->owningPE()->index() != $fromOper->owningPE()->index()) {
        return 1;
    } 
    return 0;
}

sub isSplitterConnection
{
    return 0;
}

sub genInterPEPhysicalADL
{
    my ($self, $indent, $pePortIndex) = @_;
    return 0 unless ($self->isInterPE());
    $self->print($indent, "<interPeConnection operInstanceIndex=\"$self->{_toPhysicalOperIndex}\" $self->{_portType}=\"$self->{_toOperPortIndex}\" pePortIndex=\"$pePortIndex\"/>\n");
    return 1;
}

sub genIntraPEPhysicalADL
{
    my ($self, $indent) = @_;
    return 0 if ($self->isInterPE());
    $self->print($indent, "<intraPeConnection operInstanceIndex=\"$self->{_toPhysicalOperIndex}\" $self->{_portType}=\"$self->{_toOperPortIndex}\" />\n");
    return 1;
}

1;
#####################################################
package PhysicalSplitterConnection;
use strict;
use Data::Dumper;
our @ISA = qw(PhysicalConnection);

sub new
{
    my ($class, $fromPhysicalOperIndex, $fromOperPortIndex, $toPhysicalOperIndex, $toOperPortIndex, $splitterIndex, $channelIndex, $portType) = @_;
    my $self = $class->SUPER::new($fromPhysicalOperIndex, $fromOperPortIndex, $toPhysicalOperIndex, $toOperPortIndex, $portType);
    bless $self, $class;
    $self->{_splitterIndex} = $splitterIndex;
    $self->{_channelIndex} = $channelIndex;
    print STDERR "Creating operator splitter connection from operator index $fromPhysicalOperIndex, port $fromOperPortIndex to operator index $toPhysicalOperIndex, port $toOperPortIndex, of type $portType\n" if ($Globals::verbose);
    return $self;
}

sub isSplitterConnection
{
    return 1;
}

sub genIntraPEPhysicalADL
{
    my ($self, $indent) = @_;
    return 0 if ($self->isInterPE());
    $self->print($indent, "<intraPeConnection operInstanceIndex=\"$self->{_toPhysicalOperIndex}\" $self->{_portType}=\"$self->{_toOperPortIndex}\" splitterIndex=\"$self->{_splitterIndex}\" channelIndex=\"$self->{_channelIndex}\"/>\n");
    return 1;
}

sub genInterPEPhysicalADL
{
    my ($self, $indent, $pePortIndex) = @_;
    return 0 unless ($self->isInterPE());
    $self->print($indent, "<interPeConnection operInstanceIndex=\"$self->{_toPhysicalOperIndex}\" $self->{_portType}=\"$self->{_toOperPortIndex}\" splitterIndex=\"$self->{_splitterIndex}\" channelIndex=\"$self->{_channelIndex}\" pePortIndex=\"$pePortIndex\"/>\n");
    return 1;
}

1;
#####################################################
package PhysicalParallelChannel;
use strict;
use Data::Dumper;
our @ISA = qw(PhysicalNode);

sub new
{
    my ($class, $index, $owningPhysicalOperator, $owningPhysicalPort, $modelParallelChannel) = @_;
    my $self = {};
    $self->{_index} = $index;
    $self->{_owningPhysicalOperator} = $owningPhysicalOperator;
    $self->{_owningPhysicalPort} = $owningPhysicalPort;
    $self->{_modelParallelChannel} = $modelParallelChannel;
    $self->{_connections} = [];
    print STDERR "Creating parallel channel index $self->{_index} for operator index $owningPhysicalOperator->{_index}, output port $owningPhysicalPort->{_index}\n" if ($Globals::verbose);
    my $connections = $modelParallelChannel->{_connections};
    foreach my $conn (@{$connections}) {
        my $fromPhysicalOperIndex = $owningPhysicalOperator->index();
        my $fromOperOutputPortIndex = $owningPhysicalPort->index();
        my $physicalConnections = $conn->getPhysicalConnections($fromPhysicalOperIndex, $fromOperOutputPortIndex, "iportIndex");
        foreach my $physConnection (@{$physicalConnections}) {
            push(@{$self->{_connections}}, $physConnection);
        }
    }
    print STDERR "Done creating parallel channel index $self->{_index} for operator index $owningPhysicalOperator->{_index}, output port $owningPhysicalPort->{_index}\n" if ($Globals::verbose);
    bless $self, $class;
    return $self;
}

sub getConnections
{
    my ($self) = @_;
    return $self->{_connections};
}

sub getPEPort
{
    my ($self) = @_;
    return $self->{_physicalPEPort};
}

sub setPEPort
{
    my ($self, $physicalPEPort) = @_;
    $self->{_physicalPEPort} = $physicalPEPort;
}

sub index
{
    my ($self) = @_;
    return $self->{_index};
}

sub hasInterPEConnections
{
    my ($self) = @_;
    foreach my $conn (@{$self->{_connections}}) {
        return 1 if $conn->isInterPE();
    }
    return 0;
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<parallelChannel index=\"$self->{_index}\">\n");
    $indent += 3;
    if (defined($self->{_physicalPEPort})) {
        foreach my $connection (@{$self->{_connections}}) {
            $connection->genInterPEPhysicalADL($indent, $self->{_physicalPEPort}->index());
        }
    } else {
        foreach my $connection (@{$self->{_connections}}) {
            $connection->genIntraPEPhysicalADL($indent);
        }
    }
    $indent -= 3;
    $self->print($indent, "</parallelChannel>\n");
}
1;
#####################################################
package PhysicalSplitter;
use strict;
use Data::Dumper;
our @ISA = qw(PhysicalNode);

sub new
{
    my ($class, $owningPhysicalOperator, $owningPhysicalPort, $modelSplitter) = @_;
    my $self = {};
    $self->{_index} = $modelSplitter->{_index};
    $self->{_parallelRegion} = $modelSplitter->{_parallelRegion};
    $self->{_owningPhysicalOperator} = $owningPhysicalOperator;
    $self->{_owningPhysicalPort} = $owningPhysicalPort;
    $self->{_modelSplitter} = $modelSplitter;
    $self->{_parallelChannels} = [];
    print STDERR "Creating splitter index $self->{_index} for operator index $owningPhysicalOperator->{_index}, output port $owningPhysicalPort->{_index}\n" if ($Globals::verbose);
    my $parallelChannels = $modelSplitter->{_parallelChannels};
    my $index = 0;
    foreach my $parallelChannel (@{$parallelChannels}) {
        my $physParallelChannel = PhysicalParallelChannel->new($index, $owningPhysicalOperator, $owningPhysicalPort, $parallelChannel);
        ++$index;
        push(@{$self->{_parallelChannels}}, $physParallelChannel);
    }
    print STDERR "Done creating splitter index $self->{_index} for operator index $owningPhysicalOperator->{_index}, output port $owningPhysicalPort->{_index}\n" if ($Globals::verbose);
    bless $self, $class;
    return $self;
}

sub index
{
    my ($self) = @_;
    return $self->{_index};
}

sub getPEPort
{
    my ($self, $channelIndex)  = @_;
    my $channel = $self->{_parallelChannels}->[$channelIndex];
    return $channel->getPEPort();
}

sub getConnections
{
    my ($self, $channelIndex) = @_;
    my $channel = $self->{_parallelChannels}[$channelIndex];
    return $channel->getConnections();
}

sub hasInterPEConnections
{
    my ($self) = @_;
    foreach my $channel (@{$self->{_parallelChannels}}) {
        return 1 if $channel->hasInterPEConnections();
    }
    return 0;
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    my $regionIndex = $self->{_parallelRegion}->index();
    my $logicalOperInst = $self->{_owningPhysicalOperator}->{_modelPrimitiveOperator}->{_adlOperator};
    my $operInst = $Globals::operInstances{$logicalOperInst->index()};
    my $regionSplitter = $self->{_parallelRegion}->getSplitter($self->{_modelSplitter}->{_iPortIndex});
    my $iportIndex = $self->{_modelSplitter}->{_iPortIndex};
    # To find the splitter kind, and optional attributes, we need to go to the ADL physical side and find it on the associated logical operator
    $self->print($indent, "<splitter kind = \"$regionSplitter->{kind}\" regionIndex=\"$regionIndex\" index=\"$self->{_index}\" iportIndex=\"$iportIndex\">\n");
    $indent += 3;
    foreach my $parallelChannel (@{$self->{_parallelChannels}}) {
        $parallelChannel->genPhysicalADL($indent);
    }
    $regionSplitter->{_attributes}->gen($indent)  if (defined($regionSplitter->{_attributes}));
    $indent -= 3;
    $self->print($indent, "</splitter>\n");
}
1;
#####################################################
package PhysicalOperatorInputPort;
use strict;
use Data::Dumper;
our @ISA = qw(PhysicalNode);

sub new 
{
    my ($class, $owningPhysicalOperator, $modelInputPort) = @_;
    my $self = {};
    bless $self, $class;
    $self->{_owningOperator} = $owningPhysicalOperator;
    $self->{_modelInputPort} = $modelInputPort;
    $self->{_index} = $modelInputPort->index();
    $self->{_name} = $modelInputPort->name();
    $self->{_logicalName} = $modelInputPort->logicalName();
    $self->{_threadedPort} = $modelInputPort->threadedPort() if $modelInputPort->hasThreadedPort();
    $self->{_connections} = [];
    $self->{_imports} = [];
    print STDERR "Creating input port index $self->{_index} for operator index $owningPhysicalOperator->{_index}\n" if ($Globals::verbose);
    my $connections = $modelInputPort->{_connections};
    if (defined($connections) && scalar @{$connections} > 0) {
        my $fromPhysicalOperIndex = $owningPhysicalOperator->index();
        my $fromOperInputPortIndex = $self->{_index};
        foreach my $conn (@{$connections}) {
            # These are model connections.  They could connect to the output port of a primitive operator,
            # the output port of a composite, or the input port of a composite.
            # Connections to composite ports can result in one or more physical connection
            print STDERR "Getting physical connections from operator $fromPhysicalOperIndex, input port $fromOperInputPortIndex to oper index $conn->{_operIndex}, port $conn->{_portIndex}\n" if ($Globals::verbose);
            my $physicalConnections = $conn->getPhysicalConnections($fromPhysicalOperIndex, $fromOperInputPortIndex, "oportIndex");
            foreach my $physConnection (@{$physicalConnections}) {
                push(@{$self->{_connections}}, $physConnection);
            }
        }
        foreach my $conn (@{$connections}) {
            # Some connections could be to Import operators
            my $imports = $conn->getImports("oportIndex");
            foreach my $import (@{$imports}) {
#ToDo: Change this to create physical representations here, or get the import operators and store them.
                push(@{$self->{_imports}}, $import);
            }
        }
    }
    return $self;
}

sub modelPort
{
    my ($self) = @_;
    return $self->{_modelInputPort};
}

sub getPEPort
{
    my ($self) = @_;
    return $self->{_physPEPort};
}

sub setPEPort
{
    my ($self, $physPEPort) = @_;
    $self->{_physPEPort} = $physPEPort;
}

sub index
{
    my ($self) = @_;
    return $self->{_index};
}

sub getConnections
{
    my ($self) = @_;
    return $self->{_connections};
}

sub hasImports
{
    my ($self) = @_;
    return scalar @{$self->{_imports}} > 0;
}

sub hasInterPEConnections
{
    my ($self) = @_;
    foreach my $conn (@{$self->{_connections}}) {
        if ($conn->isInterPE($self->{_owningOperator})) {
            return 1;
        }
    }
    return 0;
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    my $name = $self->{_name};
    my $logicalName = $self->{_logicalName};
    my $isMutable = $self->{_modelInputPort}->{_isMutable};
    my $tupleTypeIndex = $self->{_modelInputPort}->{_tupleTypeIndex};

    # We need the name of the port, which is the name of the operator to which the 
    # first connection points
    $self->print($indent, "<inputPort index=\"$self->{_index}\" name=\"$name\" logicalName=\"$logicalName\" isMutable=\"$isMutable\" tupleTypeIndex=\"$tupleTypeIndex\" xsi:type=\"physical:physOperInstanceInputPortType\">\n");
    $indent += 3;
    # Gen interPE connections
    if (defined($self->{_physPEPort})) {
        foreach my $conn (@{$self->{_connections}}) {
            $conn->genInterPEPhysicalADL($indent, $self->{_physPEPort}->index());
        }
    }
    # Gen intraPE connections
    my $needsThreadedPort = 0;
    foreach my $conn (@{$self->{_connections}}) {
        my $rc = $conn->genIntraPEPhysicalADL($indent);
        $needsThreadedPort = 1 if ($rc == 1 && $conn->isSplitterConnection());
    }
    if ($needsThreadedPort && !defined($self->{_threadedPort})) {
        $self->{_threadedPort} = threadedPortType->create();
    }
    if (defined($self->{_threadedPort})) {
        $self->{_threadedPort}->genADL($indent);
    } 
    $indent -= 3;
    $self->print($indent, "</inputPort>\n");
}

1;
#####################################################
package PhysicalOperatorOutputPort;
use strict;
use Data::Dumper;
our @ISA = qw(PhysicalNode);

sub new 
{
    my ($class, $owningPhysicalOperator, $modelOutputPort) = @_;
    my $self = {};
    bless $self, $class;
    $self->{_owningOperator} = $owningPhysicalOperator;
    $self->{_modelOutputPort} = $modelOutputPort;
    $self->{_index} = $modelOutputPort->index();
    $self->{_name} = $modelOutputPort->name();
    $self->{_logicalStreamName} = $modelOutputPort->logicalStreamName();
    $self->{_logicalName} = $modelOutputPort->logicalName();
    $self->{_streamName} = $modelOutputPort->streamName();
    $self->{_splitters} = [];
    $self->{_connections} = [];
    $self->{_exports} = [];  
    print STDERR "Creating output port index $self->{_index} for operator index $owningPhysicalOperator->{_index}\n" if ($Globals::verbose);
    my $splitters = $modelOutputPort->{_splitters};
    if (defined($splitters) && scalar @{$splitters} > 0) {
        foreach my $splitter (@{$splitters}) {
            my $physSplitter = PhysicalSplitter->new($owningPhysicalOperator, $self, $splitter);
            push(@{$self->{_splitters}}, $physSplitter);
        }
    }
    my $connections = $modelOutputPort->{_connections};
    if (defined($connections) && scalar @{$connections} > 0) {
        foreach my $conn (@{$connections}) {
            # These are model connections.  They could connect to the input port of a primitive operator,
            # the input port of a composite, or the output port of a composite
            # Connections to composite ports can result in one or more physical connections
            my $fromPhysicalOperIndex = $owningPhysicalOperator->index();
            my $fromOperOutputPortIndex = $self->{_index};
            my $physicalConnections = $conn->getPhysicalConnections($fromPhysicalOperIndex, $fromOperOutputPortIndex, "iportIndex");
            foreach my $physConnection (@{$physicalConnections}) {
                push(@{$self->{_connections}}, $physConnection);
            }
        }
        # Some connections could be to export operators.  The compiler only permits one, but we'll code for many
        foreach my $conn (@{$connections}) {
            my $exports = $conn->getExports("iportIndex");
            foreach my $export (@{$exports}) {
                push(@{$self->{_exports}}, $export);
            }
        }
    }
    
    print STDERR "Done creating output port index $self->{_index} for operator index $owningPhysicalOperator->{_index}\n" if ($Globals::verbose);

    return $self;
}

sub modelPort
{
    my ($self) = @_;
    die("Internal error") unless defined($self->{_modelOutputPort});
    return $self->{_modelOutputPort};
}

sub hasExport
{
    my ($self) = @_;
    return scalar @{$self->{_exports}} > 0;
}

sub getSplitterConnections
{
    my ($self, $splitterIndex, $channelIndex) = @_;
    my $splitter = $self->{_splitters}[$splitterIndex];
    return $splitter->getConnections($channelIndex);
}

sub getPEPort
{
    my ($self) = @_;
    return $self->{_physPEPort};
}

sub getSplitterPEPort
{
    my ($self, $splitterIndex, $channelIndex) = @_;
    my $splitter = $self->{_splitters}[$splitterIndex];
    return $splitter->getPEPort($channelIndex);
}

sub getConnections
{
    my ($self) = @_;
    return $self->{_connections};
}

sub setPEPort
{
    my ($self, $physPEPort) = @_;
    $self->{_physPEPort} = $physPEPort;
}

sub hasNonSplitterInterPEConnections
{
    my ($self) = @_;
    foreach my $conn (@{$self->{_connections}}) {
        return 1 if $conn->isInterPE();
    }
    return 0;
}

sub index
{
    my ($self) = @_;
    return $self->{_index};   
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    my $owningPrimitiveOperator = $self->{_modelOutputPort}->{_owningPrimitiveOperator};
    my $index = $self->{_index};
    my $isMutable = $self->{_modelOutputPort}->{_isMutable};
    my $tupleTypeIndex = $self->{_modelOutputPort}->{_tupleTypeIndex};
    my $viewable = (defined($self->{_modelOutputPort}->{_viewable})) ? $self->{_modelOutputPort}->{_viewable} : undef;

    my $name = $self->{_name};
    my $logicalName = $self->{_logicalName};
    my $streamName = $self->{_streamName};
    my $logicalStreamName = $self->{_logicalStreamName};

    $self->print($indent, "<outputPort index=\"$index\"");
    $self->print(0, " name=\"$name\" logicalName=\"$logicalName\"");
    $self->print(0, " tupleTypeIndex=\"$tupleTypeIndex\" isMutable=\"$isMutable\"");
    $self->print(0, " streamName=\"$streamName\" logicalStreamName=\"$logicalStreamName\"");
    $self->print(0, " viewable=\"$viewable\"") if defined($viewable);
    $self->print(0, " xsi:type=\"physical:physOperInstanceOutputPortType\">\n");
    if (scalar @{$self->{_connections}} > 0) {
        # The connections in the ADL pes section seem to be in order of index while in the conposite section they are not.  
        # This tries to simulate that
        my @sorted = sort {$a->{_toPhysicalOperIndex} <=> $b->{_toPhysicalOperIndex}} @{$self->{_connections}};

        $indent += 3;
        # Gen interPE connections.  There can't be any if we don't have a PE port
        if (defined($self->{_physPEPort})) {
            foreach my $conn (@sorted) {
                $conn->genInterPEPhysicalADL($indent, $self->{_physPEPort}->index());
            }
        }
        # Gen intraPE connections
        foreach my $conn (@sorted) {
            $conn->genIntraPEPhysicalADL($indent);
        }
        $indent -= 3;
    }
    if (scalar @{$self->{_splitters}} > 0) {
        $indent += 3;
        # Splitters are either all inter or all intra, so we don't need to worry about ordering
        foreach my $splitter (@{$self->{_splitters}}) {
            $splitter->genPhysicalADL($indent);
        }
        $indent -= 3;
    }
    $self->print($indent, "</outputPort>\n");
}

1;
#####################################################
package PhysicalOperator;
use strict;
use Data::Dumper;
our @ISA = qw(PhysicalNode);

sub new
{
    my ($class, $modelPrimitiveOperator) = @_;
    my $self = {};
    bless $self, $class;
    $self->{_owningPE} = undef;
    $self->{_inputPorts} = [];
    $self->{_outputPorts} = [];
    $self->{_modelPrimitiveOperator} = $modelPrimitiveOperator;
    $self->{_index} = $modelPrimitiveOperator->{_physicalIndex};
    $self->{_name} = $modelPrimitiveOperator->fullyQualifiedName();
    $self->{_logicalName} = $modelPrimitiveOperator->fullyQualifiedLogicalName();
    $self->{_originalPE} = $modelPrimitiveOperator->originalPE();
    if ($modelPrimitiveOperator->isInParallelRegion()) {
        $self->{_parallelRegion} = $modelPrimitiveOperator->containingParallelRegion();
        $self->{_channelIndex} = $modelPrimitiveOperator->containingChannelIndex();
        $self->{_maxChannels} = $self->{_parallelRegion}->width();
    }
    print STDERR "Creating physical operator index $self->{_index}\n" if ($Globals::verbose);

    # Walk the model input ports and create the physical ones
    my $inputPorts = $modelPrimitiveOperator->{_inputPorts};
    foreach my $inputPort (@{$inputPorts}) {
        my $phyInputPort = PhysicalOperatorInputPort->new($self, $inputPort);
        push(@{$self->{_inputPorts}}, $phyInputPort);
    }

    # Walk the model output ports and create the physical ones.  Primarily here we subsume any splitters
    my $outputPorts = $modelPrimitiveOperator->{_outputPorts};
    foreach my $outputPort (@{$outputPorts}) {
        my $phyOutputPort = PhysicalOperatorOutputPort->new($self, $outputPort);
        push(@{$self->{_outputPorts}}, $phyOutputPort);
    }
    print STDERR "Done creating physical operator index $self->{_index}\n" if ($Globals::verbose);

    return $self;
}

sub getPEOutputPort
{
    my ($self, $oPortIndex) = @_;
    my $port = $self->{_outputPorts}[$oPortIndex];
    return $port->getPEPort();
}

sub getSplitterPEOutputPort
{
    my ($self, $oPortIndex, $splitterIndex, $channelIndex) = @_;
    my $port = $self->{_outputPorts}[$oPortIndex];
    return $port->getSplitterPEPort($splitterIndex, $channelIndex);
}

sub setOwningPE
{
    my ($self, $owningPE) = @_;
    die("Internal error") if defined($self->{_owningPE});
    $self->{_owningPE} = $owningPE;
}

sub owningPE
{
    my ($self) = @_;
    die("Internal error") unless defined($self->{_owningPE});
    return $self->{_owningPE};
}

sub index
{
    my ($self) = @_;
    return $self->{_index};
}

sub getPEInputPort
{
    my ($self, $iPortIndex) = @_;
    my $iPort = $self->{_inputPorts}[$iPortIndex];
    return $iPort->getPEPort();
}

sub getInputConnections
{
    my ($self, $portIndex) = @_;
    my $port = $self->{_inputPorts}[$portIndex];
    return $port->getConnections();
}

sub getOutputConnections
{
    my ($self, $portIndex) = @_;
    my $port = $self->{_outputPorts}[$portIndex];
    return $port->getConnections();
}

sub getSplitterConnections
{
    my ($self, $oPortIndex, $splitterIndex, $channelIndex) = @_;
    my $oPort = $self->{_outputPorts}[$oPortIndex];
    return $oPort->getSplitterConnections($splitterIndex, $channelIndex);
}

sub assignPE
{
    my ($self) = @_;
    my $modelOperator = $self->{_modelPrimitiveOperator};
    my $peIndex = $modelOperator->{_originalPE};
    # Find the pe 
    my $pe = $Globals::physicalPEs[$peIndex];
    die("Internal error") unless defined($pe);

    # If this operator was replicated as a result of transformation, then we need to determine if we need to allocate a new
    # PE for it, or if it goes into the one from whence it came.
    if ($modelOperator->isReplica())
    {
        # If we have a replica we need to figure out which PE it needs to go in.  The rule seems to be:
        # If the replica and any operator owning a splitter feeding this operator lived in the same original PE, then we put
        # the replica in the same PE, otherwise we allocate a new PE.
        my $colocatedOperator = $modelOperator->findColocatedOperator();
        if (defined($colocatedOperator)) {
            my $originalPEIndex = $colocatedOperator->originalPE();
            my $originalPE = $Globals::physicalPEs[$originalPEIndex];
            $originalPE->addOperator($self);
        } else {
            my $newPE = $pe->replicate();
            $newPE->addOperator($self);
            my $parallelRegion = $modelOperator->containingParallelRegion();
            my $channelIndex = $modelOperator->containingChannelIndex();
            $newPE->setParallelRegionInfo($parallelRegion->index(), $channelIndex);
        }
    } else {
        # This operator is not a replica.  Put it back into the original PE
        $pe->addOperator($self);
        if ($modelOperator->hasNonColocatedSplitter()) {
            my $parallelRegion = $modelOperator->containingParallelRegion();
            my $channelIndex = $modelOperator->containingChannelIndex();
            $pe->setParallelRegionInfo($parallelRegion->index(), $channelIndex);
        }
    }
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    my $logicalIndex = $self->{_modelPrimitiveOperator}->logicalOperator()->index();
    my $definitionIndex = $self->{_modelPrimitiveOperator}->{_definitionIndex};
    my $singleThreadedOnInputs = $self->{_modelPrimitiveOperator}->{_singleThreadedOnInputs};
    my $singleThreadedOnOutputs = $self->{_modelPrimitiveOperator}->{_singleThreadedOnOutputs};
    my $class = $self->{_modelPrimitiveOperator}->{_class};
    my $logicalName = $self->{_logicalName};
    my $name = $self->{_name};
    my $parallelRegionInfo = "";
    $parallelRegionInfo .= " regionIndex=\"" . $self->{_parallelRegion}->index() . "\"" if defined($self->{_parallelRegion});
    $parallelRegionInfo .= " channelIndex=\"" . $self->{_channelIndex} . "\"" if defined($self->{_channelIndex});
    $parallelRegionInfo .= " maxChannels=\"" . $self->{_maxChannels} . "\"" if defined($self->{_maxChannels});

    my $operInstanceIndex = $self->{_modelPrimitiveOperator}->{_adlOperator}->{index};
    my $operInst = $Globals::operInstances{$operInstanceIndex};

    $self->print($indent, "<operInstance");
    $self->print(0, " index=\"$self->{_index}\" logicalIndex=\"$logicalIndex\" logicalName=\"$logicalName\" name=\"$name\"");
    $self->print(0, " definitionIndex=\"$definitionIndex\" class=\"$class\" singleThreadedOnInputs=\"$singleThreadedOnInputs\"");
    $self->print(0, $parallelRegionInfo);
    $self->print(0, " singleThreadedOnOutputs=\"$singleThreadedOnOutputs\" xsi:type=\"physical:physOperInstanceType\">\n");
    $indent += 3;

    $operInst->{_resources}->gen($indent);
    $operInst->{_profiling}->gen($indent) if defined($operInst->{_profiling});
    $operInst->{_checkpointing}->gen($indent) if defined($operInst->{_checkpointing});
    $operInst->{_runtimeConstants}->gen($indent);

    if (scalar @{$self->{_inputPorts}} == 0) {
        $self->print($indent, "<inputPorts/>\n");
    } else {
        $self->print($indent, "<inputPorts>\n");
        foreach my $inputPort (@{$self->{_inputPorts}}) {
            $indent += 3;
            $inputPort->genPhysicalADL($indent);
            $indent -= 3;
        }
        $self->print($indent, "</inputPorts>\n");
    }
    if (scalar @{$self->{_outputPorts}} == 0) {
        $self->print($indent, "<outputPorts/>\n");
    } else {
        $self->print($indent, "<outputPorts>\n");
        foreach my $outputPort (@{$self->{_outputPorts}}) {
            $indent += 3;
            $outputPort->genPhysicalADL($indent);
            $indent -= 3;
        }
        $self->print($indent, "</outputPorts>\n");
    }
    $indent -= 3;
    $self->print($indent, "</operInstance>\n");
}

1;
####################################################
package ModelNode;
use strict;
use Data::Dumper;
  
sub indent
{
    my ($self, $indent) = @_;
    for (my $i = 0; $i < $indent; ++$i) {
        print " ";
    }
}

sub print
{
    my ($self, $indent, $string) = @_;
    $self->indent($indent);
    print $string;
}

sub gen
{
    my ($self, $indent) = @_;
    $self->genADL($indent);
}

sub genADL
{
    my ($self) = @_;
    my $kind = ref($self);
    die("genADL must be overridden for $kind");
}

1;
#####################################################
package ModelConnection;
use strict;
use Data::Dumper;
our @ISA = qw(ModelNode);

sub new
{
    my ($class, $operIndex, $portIndex, $kind) = @_;
    my $self = {};
    $self->{_operIndex} = $operIndex;
    $self->{_portIndex} = $portIndex;
    $self->{_kind} = $kind;
    bless $self, $class;
    return $self;
}

sub clone
{
    my ($self) = @_;
    my $clone = {};
    $clone->{_operIndex} = $self->{_operIndex};
    $clone->{_portIndex} = $self->{_portIndex};
    $clone->{_kind} = $self->{_kind};
    bless($clone, 'ModelConnection');
    return $clone;
}

sub fix
{
    my ($self, $state) = @_;
    my $targetOperIndex = $self->{_operIndex};
    my $newIndex = $state->{_operatorIndexMap}->{$targetOperIndex};
    if (defined($newIndex)) {
        print STDERR "Patching connection from index $targetOperIndex to index $newIndex\n" if ($Globals::verbose);
        $self->{_operIndex} = $newIndex;
    }
}

sub getExports
{
    my ($self, $portKind) = @_;
    my $toModelOperIndex = $self->{_operIndex};
    my $toModelOper = $Globals::modelOperators[$toModelOperIndex];
    my $toModelOperPort = $self->{_portIndex};
    if ($toModelOper->isExport()) {
        my $exports = [];
        my $exportInfo = $toModelOper->exportInfo();
        push(@{$exports}, $exportInfo);
        return $exports;
    } elsif ($toModelOper->isComposite()) {
        # Target is a composite operator
        if ($self->{_kind} eq "input") {
            return $toModelOper->getInputPortExports($toModelOperPort, $portKind);
        } else {
            return $toModelOper->getOutputPortExports($toModelOperPort, $portKind);
        }
    } elsif ($toModelOper->isPrimitive()) {
        my $exports = [];
        return $exports;
    } elsif ($toModelOper->isImport()) {
        die("Internal error: not expected");
    }
    die("Internal error");  # We should not get here
}

sub getImports
{
    my ($self, $portKind) = @_;
    my $toModelOperIndex = $self->{_operIndex};
    my $toModelOper = $Globals::modelOperators[$toModelOperIndex];
    my $toModelOperPort = $self->{_portIndex};
    if ($toModelOper->isImport()) {
        my $imports = [];
        my $importInfo = $toModelOper->importInfo();
        push (@{$imports}, $importInfo);
        return $imports;
    } elsif ($toModelOper->isComposite()) {
        # We have a target that is a composite operator.
        if ($self->{_kind} eq "input") {
            return $toModelOper->getInputPortImports($toModelOperPort, $portKind);
        } else {
            return $toModelOper->getOutputPortImports($toModelOperPort, $portKind);
        }
    } elsif ($toModelOper->isPrimitive()) {
        my $connections = [];
        return $connections;
    }
    die("Internal error");  # We should not get here
}

sub getPhysicalConnections
{
    my ($self, $fromPhysicalOperIndex, $fromModelOperPort, $portKind) = @_;
    my $toModelOperIndex = $self->{_operIndex};
    my $toModelOper = $Globals::modelOperators[$toModelOperIndex];
    my $toModelOperPort = $self->{_portIndex};
    print STDERR "ModelConnection::getPhysicalConnections: called to get physical connections to operator index $toModelOperIndex $portKind $toModelOperPort\n" if ($Globals::verbose);
    # We've been asked for the physical connections to an operator.  If the target is a primitive operator
    # simply create a single connection.
    if ($toModelOper->isPrimitive()) {
        my $connections = [];
        my $newPhysicalConnection = PhysicalConnection->new($fromPhysicalOperIndex, $fromModelOperPort, $toModelOper->physicalOperatorIndex(), $self->{_portIndex}, $portKind);
        push (@{$connections}, $newPhysicalConnection);
        return $connections;
    } elsif ($toModelOper->isComposite()) {
        # We have a target that is a composite operator.  We need to call it to get the set of connections
        # becuse there can be fanout from the input port
        if ($self->{_kind} eq "input") {
            return $toModelOper->getInputPortPhysicalConnections($fromPhysicalOperIndex, $fromModelOperPort, $toModelOperPort, $portKind);
        } else {
            return $toModelOper->getOutputPortPhysicalConnections($fromPhysicalOperIndex, $fromModelOperPort, $toModelOperPort, $portKind);
        }
    } elsif ($toModelOper->isImport() || $toModelOper->isExport()) {
        my $connections = [];
        return $connections;
    }

    die("Internal error");  # We should not get here
}

sub genADL
{
    my ($self, $indent) = @_;
    my $operIndex = $self->{_operIndex};
    my $operName = $Globals::modelOperators[$operIndex]->fullyQualifiedName();
    my $portIndex = $self->{_portIndex};
    my $portKind = $self->{_kind};
    $self->print($indent, "<connection operIndex=\"$operIndex\" operName=\"$operName\" portIndex=\"$portIndex\" portKind=\"$portKind\"/>\n");
}

1;
#####################################################
package ModelSplitterConnection;
use strict;
use Data::Dumper;
our @ISA = qw(ModelConnection);

sub new
{
    my ($class, $operIndex, $portIndex, $splitterIndex, $channelIndex) = @_;
    my $self = $class->SUPER::new($operIndex, $portIndex, "output");
    $self->{_splitterIndex} = $splitterIndex;
    $self->{_channelIndex} = $channelIndex;
    bless $self, $class;
    return $self;
}

sub clone
{
    my ($self) = @_;
    my $clone = $self->SUPER::clone($self);
    $clone->{_splitterIndex} = $self->{_splitterIndex};
    $clone->{_channelIndex} = $self->{_channelIndex};
    bless($clone, 'ModelSplitterConnection');
    return $clone;
}

sub getPhysicalConnections
{
    my ($self, $fromPhysicalOperIndex, $fromModelOperPort, $portKind) = @_;
    my $toModelOperIndex = $self->{_operIndex};
    my $toModelOper = $Globals::modelOperators[$toModelOperIndex];
    my $toModelOperPort = $self->{_portIndex};
    if ($toModelOper->isPrimitive()) {
        my $connections = [];
        my $newPhysicalConnection = PhysicalSplitterConnection->new($fromPhysicalOperIndex, $fromModelOperPort, $toModelOper->physicalOperatorIndex(), $self->{_portIndex}, $self->{_splitterIndex}, $self->{_channelIndex}, $portKind);
        push (@{$connections}, $newPhysicalConnection);
        return $connections;
    }
    die("Internal error");  # We shouldn't get here
}

sub genADL
{
    my ($self, $indent) = @_;
    my $operIndex = $self->{_operIndex};
    my $operName = $Globals::modelOperators[$operIndex]->name();
    my $portIndex = $self->{_portIndex};
    my $splitterIndex = $self->{_splitterIndex};
    my $channelIndex = $self->{_channelIndex};
    my $portKind = $self->{_kind};
    $self->print($indent, "<splitterConnection operIndex=\"$operIndex\" operName=\"$operName\" portIndex=\"$portIndex\" splitterIndex=\"$splitterIndex\" channelIndex=\"$channelIndex\" portKind=\"$portKind\"/>\n");
}

1;
#####################################################
package ModelPort;
use strict;
use Data::Dumper;
our @ISA = qw(ModelNode);

sub new
{
    my ($class, $port, $owningPrimitiveOperator) = @_;
    my $self = {};
    $self->{_index} = $port->{index};
    $self->{_owningPrimitiveOperator} = $owningPrimitiveOperator;
    bless $self, $class;
    return $self;
}

sub replicate
{
    my ($self, $owningPrimitiveOperator) = @_;
    my $replica = {};
    $replica->{_owningPrimitiveOperator} = $owningPrimitiveOperator;
    $replica->{_index} = $self->{_index};
    bless $replica, 'ModelPort';
    return $replica;
}

sub index
{
    my ($self) = @_;
    return $self->{_index};
}

1;
#####################################################
package ModelPrimitivePort;
use strict;
use Data::Dumper;
our @ISA = qw(ModelPort);

sub new
{
    my ($class, $adlPort, $owningPrimitiveOperator, $operInstancePort) = @_;
    my $self = $class->SUPER::new($adlPort, $owningPrimitiveOperator);
    $self->{_tupleTypeIndex} = $operInstancePort->{tupleTypeIndex};
    $self->{_encoding} = $operInstancePort->{_encoding};
    $self->{_transport} = $operInstancePort->{_transport};
    $self->{_isMutable} = $operInstancePort->{isMutable};
    $self->{_name} = $operInstancePort->{name};
    $self->{_connections} = [];

    my $connections = $adlPort->{_connections};
    $connections = $connections->{_connection} if defined($connections);
    foreach my $connection (@{$connections}) {
        my $modelConnection = ModelConnection->new($connection->{operIndex}, $connection->{portIndex}, $connection->{portKind});
        push(@{$self->{_connections}}, $modelConnection);
    }
    bless $self, $class;
    return $self;
}

sub replicate
{
    my ($self, $owningPrimitiveOperator) = @_;
    my $replica = $self->SUPER::replicate($owningPrimitiveOperator);
    $replica->{_tupleTypeIndex} = $self->{_tupleTypeIndex};
    $replica->{_encoding} = $self->{_encoding};
    $replica->{_transport} = $self->{_transport};
    $replica->{_isMutable} = $self->{_isMutable};
    $replica->{_name} = $self->{_name};
    $replica->{_connections} = [];
    foreach my $connection (@{$self->{_connections}}) {
        my $connectionKind = ref($connection);
        my $newConnection = $connection->clone();
        push(@{$replica->{_connections}}, $newConnection);
    }
    bless $replica, 'ModelPrimitivePort';
    return $replica;
}

sub logicalName
{
    my ($self) = @_;
    return $self->{_name};
}

sub name
{
    my ($self) = @_;
    return $self->{_name};
}

sub fixConnections
{
    my ($self, $state) = @_;
    foreach my $connection (@{$self->{_connections}}) {
        $connection->fix($state);
    }
}

sub genADL
{
    my ($self, $indent) = @_;
    if (scalar @{$self->{_connections}} > 0) {
        $self->print($indent, "<connections>\n");
        $indent += 3;
        foreach my $conn (@{$self->{_connections}}) {
            $conn->genADL($indent);
        }
        $indent -= 3;
        $self->print($indent, "</connections>\n");
    }
}

1;
#####################################################
package ModelPrimitiveInputPort;
use strict;
use Data::Dumper;
our @ISA = qw(ModelPrimitivePort);

sub new
{
    my ($class, $adlInputPort, $owningPrimitiveOperator) = @_;
    my $operIndex = $owningPrimitiveOperator->index();
    my $operInst = $Globals::operInstances{$operIndex};
    my $portIndex = $adlInputPort->{index};
    my $operIPort = $operInst->getIPort($portIndex);
    my $self = $class->SUPER::new($adlInputPort, $owningPrimitiveOperator, $operIPort);
    $self->{_splitters} = [];  
    $self->{_threadedPort} = $operIPort->{_threadedPort} if defined($operIPort->{_threadedPort});
    bless $self, $class;
    return $self;
}

sub hasThreadedPort
{
    my ($self) = @_;
    return defined($self->{_threadedPort});
}

sub threadedPort
{
    my ($self) = @_;
    die("Internal error") unless defined($self->{_threadedPort});
    return $self->{_threadedPort};
}

sub replicate
{
    my ($self, $owningPrimitiveOperator) = @_;
    my $replica = $self->SUPER::replicate($owningPrimitiveOperator);
    $replica->{_splitters} = $self->{_splitters};  # This is a copy of a pointer, not a clone
    $replica->{_threadedPort} = $self->{_threadedPort}; # This is a copy of a pointer, not a clone
    bless($replica, 'ModelPrimitiveInputPort');
    return $replica;
}

sub hasNonColocatedSplitter
{
    my ($self) = @_;
    my $originalPE = $self->{_owningPrimitiveOperator}->originalPE();
    foreach my $splitter (@{$self->{_splitters}}) {
        my $splitterModelOperator = $splitter->owningOperator();
        return 1 if ($originalPE != $splitterModelOperator->originalPE());
    }
    return 0;
}

sub findColocatedOperator
{
    my ($self) = @_;
    my $originalPE = $self->{_owningPrimitiveOperator}->originalPE();
    foreach my $splitter (@{$self->{_splitters}}) {
        my $splitterModelOperator = $splitter->owningOperator();
        if ($originalPE == $splitterModelOperator->originalPE()) {
            print STDERR "Found operator $self->{_owningPrimitiveOperator}->{_index} and $splitterModelOperator->{_index} have the same partition colocation\n" if ($Globals::verbose);
            return $splitterModelOperator;
        }
    }
    return undef;
}

sub addConnection
{
    my ($self, $toOperIndex, $toPortIndex) = @_;
    my $oper = $Globals::modelOperators[$toOperIndex];
    my $conn = ModelConnection->new($toOperIndex, $toPortIndex, "output");
    push(@{$self->{_connections}}, $conn);
}

# This method is called for each replica of channel 0 to add it's connections to each of the splitters projected
# by addSplitters
sub addConnections
{
    my ($self, $owningOperator, $channelIndex) = @_;
    foreach my $connection (@{$self->{_connections}}) {
        foreach my $splitter (@{$self->{_splitters}}) {
            my $splitterIndex = $splitter->index();
            $connection->{_channelIndex} = $channelIndex;
            $splitter->addChannelConnection($channelIndex, $owningOperator->index(), $self->index());
        }
    }
}

# Called on the channel 0 operator to project splitters onto the feeding operators
sub addSplitters
{
    my ($self, $owningOperator, $parallelRegion) = @_;
    my $splitterConnections = [];
    foreach my $connection (@{$self->{_connections}}) {
        die("Internal error") unless ($connection->{_kind} eq "output");
        print STDERR "Need to add splitter to operator index $connection->{_operIndex} output port $connection->{_portIndex}\n" if ($Globals::verbose);
        my $feedingOper = $Globals::modelOperators[$connection->{_operIndex}];
        my $feedingPortIndex = $connection->{_portIndex};
        my $toOperIndex = $owningOperator->index();
        my $toPortIndex = $self->{_index};
        my $splitter = $feedingOper->convertConnectionToSplitter($parallelRegion, $feedingPortIndex, $toOperIndex, $toPortIndex);
        push(@{$self->{_splitters}}, $splitter);
        my $newConnection = ModelSplitterConnection->new($connection->{_operIndex}, $connection->{_portIndex}, $splitter->index(), 0);
        push(@{$splitterConnections}, $newConnection);
    }
    $self->{_connections} = $splitterConnections;
}

sub genADL
{
    my ($self, $indent) = @_;
    my $index = $self->{_index};
    my $name = $self->{_name};
    $self->print($indent, "<port index=\"$index\" name=\"$name\">\n");
    $indent += 3;
    my $transport = $self->{_transport};
    my $tupleTypeIndex = $self->{_tupleTypeIndex};
    my $encoding = $self->{_encoding};
    $self->print($indent, "<augmentedPortInfo transport=\"$transport\" tupleTypeIndex=\"$tupleTypeIndex\" encoding=\"$encoding\"/>\n");
    $self->SUPER::genADL($indent);
    $indent -= 3;
    $self->print($indent, "</port>\n");
}

sub graph
{
    my ($self, $graph, $owningOperator) = @_;
    foreach my $connection (@{$self->{_connections}}) {
        my $toOperIndex = $connection->{_operIndex};
        my $toPortIndex = $connection->{_portIndex};
        my $toPortKind = $connection->{_kind};
        my $fromOperIndex = $owningOperator->index();
        my $fromPortIndex = $self->{_index};
        my $fromPortKind = "input";
        my $arc;
        if ($toPortKind eq "input") {
            $arc = GraphArc->new($toOperIndex, $toPortIndex, $toPortKind, $fromOperIndex, $fromPortIndex, $fromPortKind, "grey");
        } else {
            $arc = GraphArc->new($toOperIndex, $toPortIndex, $toPortKind, $fromOperIndex, $fromPortIndex, $fromPortKind, "orange");
        }
        $graph->addArc($arc);
    }
}
1;
#####################################################
package ModelPrimitiveExportInputPort;
use strict;
use Data::Dumper;
our @ISA = qw(ModelPort);

sub new
{
    my ($class, $adlInputPort, $owningPrimitiveOperator) = @_;
    my $self = $class->SUPER::new($adlInputPort, $owningPrimitiveOperator);
    $self->{_connections} = [];

    my $connections = $adlInputPort->{_connections};
    $connections = $connections->{_connection} if defined($connections);
    foreach my $connection (@{$connections}) {
        my $modelConnection = ModelConnection->new($connection->{operIndex}, $connection->{portIndex}, $connection->{portKind});
        push(@{$self->{_connections}}, $modelConnection);
    }
    bless $self, $class;
    return $self;
}

sub replicate
{
    my ($self, $owningPrimitiveOperator) = @_;
    my $replica = $self->SUPER::replicate($owningPrimitiveOperator);
    $replica->{_connections} = [];

    foreach my $connection (@{$self->{_connections}}) {
        my $newConnection = $connection->clone();
        push(@{$replica->{_connections}}, $newConnection);
    }
    bless($replica, 'ModelPrimitiveExportInputPort');
    return $replica;
}

sub fixConnections
{
    my ($self, $state) = @_;
    foreach my $connection (@{$self->{_connections}}) {
        $connection->fix($state);
    }
}

sub genADL
{
    my ($self, $indent) = @_;
    my $index = $self->{_index};
    my $name = $self->{_name};
    $self->print($indent, "<port index=\"$index\">\n");
    $indent += 3;
    $self->print($indent, "<connections>\n");
    foreach my $connection (@{$self->{_connections}}) {
        $indent += 3;
        $connection->genADL($indent);
        $indent -= 3;
    }
    $self->print($indent, "</connections>\n");
    $indent -= 3;
    $self->print($indent, "</port>\n");
}

1;
#####################################################
package ModelPrimitiveImportOutputPort;
use strict;
use Data::Dumper;
our @ISA = qw(ModelPort);

sub new
{
    my ($class, $adlOutputPort, $owningPrimitiveOperator) = @_;
    my $self = $class->SUPER::new($adlOutputPort, $owningPrimitiveOperator);
    $self->{_connections} = [];

    my $connections = $adlOutputPort->{_connections};
    $connections = $connections->{_connection} if defined($connections);
    foreach my $connection (@{$connections}) {
        my $modelConnection = ModelConnection->new($connection->{operIndex}, $connection->{portIndex}, $connection->{portKind});
        push(@{$self->{_connections}}, $modelConnection);
    }
    bless $self, $class;
    return $self;
}

sub replicate
{
    my ($self, $owningPrimitiveOperator) = @_;
    my $replica = $self->SUPER::replicate($owningPrimitiveOperator);
    $replica->{_connections} = [];

    foreach my $connection (@{$self->{_connections}}) {
        my $newConnection = $connection->clone();
        push(@{$replica->{_connections}}, $newConnection);
    }
    bless($replica, 'ModelPrimitiveImportOutputPort');
    return $replica;
}

sub fixConnections
{
    my ($self, $state) = @_;
    foreach my $connection (@{$self->{_connections}}) {
        $connection->fix($state);
    }
}

sub genADL
{
    my ($self, $indent) = @_;
    my $index = $self->{_index};
    my $name = $self->{_name};
    $self->print($indent, "<port index=\"$index\">\n");
    $indent += 3;
    $self->print($indent, "<connections>\n");
    foreach my $connection (@{$self->{_connections}}) {
        $indent += 3;
        $connection->genADL($indent);
        $indent -= 3;
    }
    $self->print($indent, "</connections>\n");
    $indent -= 3;
    $self->print($indent, "</port>\n");
}

1;
#####################################################
package ModelPrimitiveOutputPort;
use strict;
use Data::Dumper;
our @ISA = qw(ModelPrimitivePort);

sub new
{
    my ($class, $adlOutputPort, $owningPrimitiveOperator) = @_;
    my $operIndex = $owningPrimitiveOperator->index();
    my $operInst = $Globals::operInstances{$operIndex};
    my $portIndex = $adlOutputPort->{index};
    my $operOPort = $operInst->getOPort($portIndex);
    my $self = $class->SUPER::new($adlOutputPort, $owningPrimitiveOperator, $operOPort);
    $self->{_splitters} = [];
    $self->{_singleThreadedOnOutput} = $operOPort->{_singleThreadedOnOutput};
    $self->{_viewable} = $operOPort->{viewable};
    $self->{_streamName} = $operOPort->{streamName};
    bless $self, $class;
    return $self;
}

sub replicate
{
    my ($self, $owningPrimitiveOperator) = @_;
    print STDERR "Creating replica of output port from operator $self->{_index} for operator $owningPrimitiveOperator->{_index}\n" if ($Globals::verbose);
    my $replica = $self->SUPER::replicate($owningPrimitiveOperator);
die("Needs work") unless (scalar @{$self->{_splitters}} == 0);
    $replica->{_singleThreadedOnOutput} = $self->{_singleThreadedOnOutput};
    $replica->{_viewable} = $self->{_viewable};
    $replica->{_name} = $self->{_name};
    $replica->{_streamName} = $self->{_streamName};
    $replica->{_splitters} = $self->{_splitters};
    bless($replica, 'ModelPrimitiveOutputPort');
    return $replica;
}

sub addConnections
{
    my ($self, $owningOperator) = @_;
    # This is called on a repica to establish the connections from its downstream operators back to this replica
    foreach my $conn (@{$self->{_connections}}) {
        my $oper = $Globals::modelOperators[$conn->{_operIndex}];
        $oper->addInputConnection($conn->{_portIndex}, $owningOperator->index(), $self->index());
    }
}

sub convertConnectionToSplitter
{
    my ($self, $owningOperator, $parallelRegion, $toOperIndex, $toPortIndex) = @_;
    # Find this connection
    my $splitter = undef;
    my $newConnectionList = [];
    for (my $i = 0; $i < scalar @{$self->{_connections}}; ++$i) {
        my $conn = $self->{_connections}->[$i];
        if ($conn->{_operIndex} == $toOperIndex && $conn->{_portIndex} == $toPortIndex && $conn->{_kind} eq "input") {
            my $owningOperIndex = $owningOperator->index();
            my $owningOperOPortIndex = $self->index();
            $splitter = ModelSplitter->new(scalar @{$self->{_splitters}}, $toPortIndex, $parallelRegion, $owningOperIndex, $owningOperOPortIndex);
            $splitter->addChannelConnection(0, $toOperIndex, $toPortIndex);
            push(@{$self->{_splitters}}, $splitter);
        }  else {
            push(@{$newConnectionList}, $conn);
        }
    }
    $self->{_connections} = $newConnectionList;
    die("Internal error") unless defined($splitter);
    return $splitter;
}

sub logicalStreamName
{
    my ($self) = @_;
    return $self->{_streamName};
}

# StreamName needs to take into account of whether or not the operator owning this port
# is in a parallel region or not.
sub streamName
{
    my ($self) = @_;
    my $streamName = $self->{_streamName};
    my $owningPrimitiveOperator = $self->{_owningPrimitiveOperator};
    if ($owningPrimitiveOperator->isInParallelRegion()) {
        # We are in a parallel region.  We need to append the set of region indices.
        my $channelIndexes = $owningPrimitiveOperator->parallelChannelIndexes();
        $streamName .=  $channelIndexes;
    }
    return $streamName;
}

sub genADL
{
    my ($self, $indent) = @_;
    my $index = $self->{_index};
    my $name = $self->{_name};
    my $logicalStreamName = $self->logicalStreamName();
    my $streamName = $self->streamName();
    $self->print($indent, "<port index=\"$index\" name=\"$name\" streamName=\"$streamName\">\n");
    $indent += 3;
    my $transport = $self->{_transport};
    my $tupleTypeIndex = $self->{_tupleTypeIndex};
    my $encoding = $self->{_encoding};
    $self->print($indent, "<augmentedPortInfo transport=\"$transport\" tupleTypeIndex=\"$tupleTypeIndex\" encoding=\"$encoding\"/>\n");
    if (scalar @{$self->{_splitters}} > 0) {
        $self->print($indent, "<splitters>\n");
        $indent += 3;
        foreach my $splitter (@{$self->{_splitters}}) {
            $splitter->genADL($indent);
        }
        $indent -= 3;
        $self->print($indent, "</splitters>\n");
    }
    $self->SUPER::genADL($indent);
    $indent -= 3;
    $self->print($indent, "</port>\n");
}

sub graph
{
    my ($self, $graph, $owningOperator) = @_;
    foreach my $splitter (@{$self->{_splitters}}) {
        $splitter->graph($graph);
    }
    foreach my $connection (@{$self->{_connections}}) {
        my $toOperIndex = $connection->{_operIndex};
        my $toPortIndex = $connection->{_portIndex};
        my $toPortKind = $connection->{_kind};
        my $fromOperIndex = $owningOperator->index();
        my $fromPortIndex = $self->{_index};
        my $fromPortKind = "output";
        my $arc;
        if ($toPortKind eq "output") {
            $arc = GraphArc->new($fromOperIndex, $fromPortIndex, $fromPortKind, $toOperIndex, $toPortIndex, $toPortKind, "yellow");
        } else {
            $arc = GraphArc->new($fromOperIndex, $fromPortIndex, $fromPortKind, $toOperIndex, $toPortIndex, $toPortKind, "blue");
        }
        $graph->addArc($arc);
    }
}

1;
#####################################################
package ModelCompositePort;
use strict;
use Data::Dumper;
our @ISA = qw(ModelPort);

sub new
{
    my ($class, $adlPort) = @_;
    my $self = $class->SUPER::new($adlPort);
    $self->{_incomingConnections} = [];
    $self->{_outgoingConnections} = [];

    my $incomingConnections = $adlPort->{_incomingConnections};
    $incomingConnections = $incomingConnections->{_connection} if defined($incomingConnections);
    foreach my $connection (@{$incomingConnections}) {
        my $modelConnection = ModelConnection->new($connection->{operIndex}, $connection->{portIndex}, $connection->{portKind});
        push(@{$self->{_incomingConnections}}, $modelConnection);
    }

    my $outgoingConnections = $adlPort->{_outgoingConnections};
    $outgoingConnections = $outgoingConnections->{_connection} if defined($outgoingConnections);
    foreach my $connection (@{$outgoingConnections}) {
        my $modelConnection = ModelConnection->new($connection->{operIndex}, $connection->{portIndex}, $connection->{portKind});
        push(@{$self->{_outgoingConnections}}, $modelConnection);
    }
    bless $self, $class;
    return $self;
}

sub replicate
{
    my ($self, $owningPrimitiveOperator) = @_;
    my $replica = $self->SUPER::replicate($owningPrimitiveOperator);
    $replica->{_incomingConnections} = [];
    $replica->{_outgoingConnections} = [];

    foreach my $incomingConnection (@{$self->{_incomingConnections}}) {
        my $newConn = $incomingConnection->clone();
        push(@{$replica->{_incomingConnections}}, $newConn);
    }

    foreach my $outgoingConnection (@{$self->{_outgoingConnections}}) {
        my $newConn = $outgoingConnection->clone();
        push(@{$replica->{_outgoingConnections}}, $newConn);
    }

    bless($replica, 'ModelCompositePort');
    return $replica;
}

sub genADL
{
    my ($self, $indent) = @_;
    my $index = $self->{_index};
    $self->print($indent, "<port index=\"$index\">\n");
    $indent += 3;
    if (scalar @{$self->{_incomingConnections}} > 0) {
        $self->print($indent, "<incomingConnections>\n");
        $indent += 3;
        foreach my $connection (@{$self->{_incomingConnections}}) {
            $connection->genADL($indent);
        }
        $indent -= 3;
        $self->print($indent, "</incomingConnections>\n");
    }
    if (scalar @{$self->{_outgoingConnections}} > 0) {
        $self->print($indent, "<outgoingConnections>\n");
        $indent += 3;
        foreach my $connection (@{$self->{_outgoingConnections}}) {
            $connection->genADL($indent);
        }
        $indent -= 3;
        $self->print($indent, "</outgoingConnections>\n");
    }
    $indent -= 3;
    $self->print($indent, "</port>\n");
}


1;
#####################################################
package ModelCompositeOutputPort;
use strict;
use Data::Dumper;
use Carp qw(longmess);
our @ISA = qw(ModelCompositePort);

sub new
{
    my ($class, $adlOutputPort) = @_;
    my $self = $class->SUPER::new($adlOutputPort);
    bless $self, $class;
    return $self;
}

sub replicate
{
    my ($self, $owningPrimitiveOperator) = @_;
    my $replica = $self->SUPER::replicate($owningPrimitiveOperator);
    $replica->{_splitters} = $self->{_splitters};  # A copy???
    bless($replica, 'ModelCompositeOutputPort');
    return $replica;
}

sub fixIncomingConnections
{
    my ($self, $state) = @_;
    foreach my $connection (@{$self->{_incomingConnections}}) {
        $connection->fix($state);
    }
}

# Called on a replica to add connections to downstream operators
sub addOutgoingConnections
{
    my ($self, $owningOperator) = @_;
    foreach my $outgoingConnection (@{$self->{_outgoingConnections}}) {
        my $downstreamOper = $Globals::modelOperators[$outgoingConnection->{_operIndex}];
        $downstreamOper->addInputConnection($outgoingConnection->{_portIndex}, $owningOperator->index(), $self->index());
    }
}

sub getOutgoingExports
{
    my ($self, $portKind) = @_;
    my $exports = [];
    foreach my $outgoingConnection (@{$self->{_outgoingConnections}}) {
        my $newExports = $outgoingConnection->getExports($portKind);
        foreach my $export (@{$exports}) {
            push(@{$newExports}, $export);
        }
    }   
    return $exports;
}

sub getIncomingImports
{
    my ($self, $portKind) = @_;
    # There can only be one operator feeding a composite output port
    die("Internal error") if (scalar @{$self->{_incomingConnections}} != 1);
    my $imports = $self->{_incomingConnections}->[0]->getImports($portKind);
    return $imports;
}

sub getIncomingPhysicalConnections
{
    my ($self, $fromPhysicalOperIndex, $fromModelOperPort, $portKind) = @_;
    # There can only be one operator feeding a composite output port
    die("Internal error") if (scalar @{$self->{_incomingConnections}} != 1);
    my $physicalConnections = $self->{_incomingConnections}->[0]->getPhysicalConnections($fromPhysicalOperIndex, $fromModelOperPort, $portKind);
    return $physicalConnections;
}

sub getOutgoingPhysicalConnections
{
    my ($self, $fromPhysicalOperIndex, $fromModelOperPort, $portKind) = @_;
    # There can be fan-out from a composite output port
    my $physicalConnections = [];
    foreach my $outgoingConnection (@{$self->{_outgoingConnections}}) {
        my $newPhysicalConnections = $outgoingConnection->getPhysicalConnections($fromPhysicalOperIndex, $fromModelOperPort, $portKind);
        foreach my $physicalConnection (@{$newPhysicalConnections}) {
            push(@{$physicalConnections}, $physicalConnection);
        }
    }
    return $physicalConnections;
}

sub graph
{
    my ($self, $graph, $owningOperator) = @_;
    foreach my $connection (@{$self->{_incomingConnections}}) {
        my $fromOperIndex = $connection->{_operIndex};
        my $fromPortIndex = $connection->{_portIndex};
        my $fromPortKind = $connection->{_kind};
        my $toOperIndex = $owningOperator->index();
        my $toPortIndex = $self->{_index};
        my $toPortKind = "output";
        my $arc = GraphArc->new($fromOperIndex, $fromPortIndex, $fromPortKind, $toOperIndex, $toPortIndex, $toPortKind, "red");
        $graph->addArc($arc);
    }
    foreach my $connection (@{$self->{_outgoingConnections}}) {
        my $toOperIndex = $connection->{_operIndex};
        my $toPortIndex = $connection->{_portIndex};
        my $toPortKind = $connection->{_kind};
        my $fromOperIndex = $owningOperator->index();
        my $fromPortIndex = $self->{_index};
        my $fromPortKind = "output";
        my $arc = GraphArc->new($fromOperIndex, $fromPortIndex, $fromPortKind, $toOperIndex, $toPortIndex, $toPortKind, "green");
        $graph->addArc($arc);
    }
}

1;
#####################################################
package ModelCompositeInputPort;
use strict;
use Data::Dumper;
our @ISA = qw(ModelCompositePort);

sub new
{
    my ($class, $adlInputPort) = @_;
    my $self = $class->SUPER::new($adlInputPort);
    $self->{_splitters} = [];
    bless $self, $class;
    return $self;
}

sub replicate
{
    my ($self, $owningPrimitiveOperator) = @_;
    my $replica = $self->SUPER::replicate($owningPrimitiveOperator);
    $replica->{_splitters} = $self->{_splitters};  # A copy???
    bless($replica, 'ModelCompositeInputPort');
    return $replica;
}

sub addIncomingConnections
{
    my ($self, $owningOperator, $channelIndex) = @_;
    foreach my $incomingConnection (@{$self->{_incomingConnections}}) {
        foreach my $splitter (@{$self->{_splitters}}) {
            $incomingConnection->{_channelIndex} = $channelIndex;
            $splitter->addChannelConnection($channelIndex, $owningOperator->index(), $self->index());
        }
    }
}

sub fixOutgoingConnections
{
    my ($self, $state) = @_;
    foreach my $connection (@{$self->{_outgoingConnections}}) {
        $connection->fix($state);
    }
}

sub getIncomingImports
{
    my ($self, $portKind) = @_;
    my $imports = [];
    foreach my $incomingConnection (@{$self->{_incomingConnections}}) {
        my $newImports = $incomingConnection->getImports($portKind);
        foreach my $import (@{$newImports}) {
            push(@{$imports}, $import);
        }
    }
    return $imports;
}

sub getIncomingPhysicalConnections
{
    my ($self, $fromPhysicalOperIndex, $fromModelOperPort, $portKind) = @_;
    # There can many operators feeding the input port of a composite
    my $physicalConnections = [];
    foreach my $incomingConnection (@{$self->{_incomingConnections}}) {
        my $newPhysicalConnections = $incomingConnection->getPhysicalConnections($fromPhysicalOperIndex, $fromModelOperPort, $portKind);
        foreach my $physicalConnection (@{$newPhysicalConnections}) {
            push(@{$physicalConnections}, $physicalConnection);
        }
    }
    return $physicalConnections;
}

# Looc for any exports within the composite fed by this input port
sub getOutgoingExports
{
    my ($self, $portKind) = @_;
    my $exports = [];
    foreach my $outgoingConnection (@{$self->{_outgoingConnections}}) {
        my $newExports = $outgoingConnection->getExports($portKind);
        foreach my $export (@{$newExports}) { 
            push(@{$exports}, $export);
        }
    }
    return $exports;   
}

sub getOutgoingPhysicalConnections
{
    my ($self, $fromPhysicalOperIndex, $fromModelOperPort, $portKind) = @_;
    my $physicalConnections = [];
    # Each outgoing connection could go to a primitive opertor input port or a composite operator input port
    foreach my $outgoingConnection (@{$self->{_outgoingConnections}}) {
        my $newPhysicalConnections = $outgoingConnection->getPhysicalConnections($fromPhysicalOperIndex, $fromModelOperPort, $portKind);
        foreach my $physicalConnection (@{$newPhysicalConnections}) {
            push(@{$physicalConnections}, $physicalConnection);
        }
    }

    return $physicalConnections;
}

# Called on the channel 0 composite to project splitters onto the feeding operators.
sub addSplitters
{
    my ($self, $owningOperator, $parallelRegion) = @_;
    # For all incoming connections we need to add a splitter
    my $splitterConnections = [];
    foreach my $connection (@{$self->{_incomingConnections}}) {
        die("Internal error") unless ($connection->{_kind} eq "output");
        print STDERR "Need to add splitter to operator index $connection->{_operIndex} output port $connection->{_portIndex}\n" if ($Globals::verbose);
        my $feedingOper = $Globals::modelOperators[$connection->{_operIndex}];
        my $feedingPortIndex = $connection->{_portIndex};
        my $toOperIndex = $owningOperator->index();
        my $toPortIndex = $self->{_index};
        my $splitter = $feedingOper->convertConnectionToSplitter($parallelRegion, $feedingPortIndex, $toOperIndex, $toPortIndex);
        push(@{$self->{_splitters}}, $splitter);
        my $newConnection = ModelSplitterConnection->new($connection->{_operIndex}, $connection->{_portIndex}, $splitter->index(), 0);
        push(@{$splitterConnections}, $newConnection);
    }
    $self->{_incomingConnections} = $splitterConnections;
}

sub graph
{
    my ($self, $graph, $owningOperator) = @_;
    foreach my $connection (@{$self->{_incomingConnections}}) {
        my $fromOperIndex = $connection->{_operIndex};
        my $fromPortIndex = $connection->{_portIndex};
        my $fromPortKind = $connection->{_kind};
        my $toOperIndex = $owningOperator->index();
        my $toPortIndex = $self->{_index};
        my $toPortKind = "input";
        my $arc = GraphArc->new($fromOperIndex, $fromPortIndex, $fromPortKind, $toOperIndex, $toPortIndex, $toPortKind, "red");
        $graph->addArc($arc);
    }
    foreach my $connection (@{$self->{_outgoingConnections}}) {
        my $toOperIndex = $connection->{_operIndex};
        my $toPortIndex = $connection->{_portIndex};
        my $toPortKind = $connection->{_kind};
        my $fromOperIndex = $owningOperator->index();
        my $fromPortIndex = $self->{_index};
        my $fromPortKind = "input";
        my $arc = GraphArc->new($fromOperIndex, $fromPortIndex, $fromPortKind, $toOperIndex, $toPortIndex, $toPortKind, "green");
        $graph->addArc($arc);
    }
}

1;
#####################################################
package ModelParallelChannel;
use strict;
use Data::Dumper;
our @ISA = qw(ModelNode);

sub new
{
    my ($class, $index) = @_;
    my $self= {};
    $self->{_index} = $index;
    $self->{_connections} = [];
    bless $self, $class;
    return $self;
}

sub addConnection
{
    my ($self, $toOperIndex, $toPortIndex) = @_;
    my $oper = $Globals::modelOperators[$toOperIndex];
    my $conn = ModelConnection->new($toOperIndex, $toPortIndex, "input");
    push(@{$self->{_connections}}, $conn);
}

sub genADL
{
    my ($self, $indent) = @_;
    my $index = $self->{_index};
    $self->print($indent, "<parallelChannel index=\"$index\">\n");
    $indent += 3;
    $self->print($indent, "<connections>\n");
    $indent += 3;
    foreach my $connection (@{$self->{_connections}}) {
        $connection->genADL($indent);
    }
    $indent -= 3;
    $self->print($indent, "</connections>\n");
    $indent -= 3;
    $self->print($indent, "</parallelChannel>\n");
}

sub graph
{
    my ($self, $graph, $owningSplitter) = @_;
    foreach my $conn (@{$self->{_connections}}) {
        my $fromOperIndex = $owningSplitter->index();
        my $fromPortIndex = $self->{_index};
        my $toOperIndex = $conn->{_operIndex};
        my $toPortIndex = $conn->{_portIndex};
        my $arc = GraphArc->new($fromOperIndex, $fromPortIndex, "output", $toOperIndex, $toPortIndex, "input", "brown");
        $graph->addArc($arc);
    }
}

1;
#####################################################
package ModelSplitter;
use strict;
use Data::Dumper;
our @ISA = qw(ModelNode);

sub new
{
    my ($class, $index, $iPortIndex, $parallelRegion, $owningOperIndex, $owningPortIndex) = @_;
    my $self = {};
    my $width = $parallelRegion->width();
    $self->{_index} = $index;
    $self->{_iPortIndex} = $iPortIndex;
    $self->{_parallelRegion} = $parallelRegion;
    $self->{_owningOperIndex} = $owningOperIndex;
    $self->{_owningPortIndex} = $owningPortIndex;
    $self->{_parallelChannels} = [];
    for (my $i = 0; $i < $width; ++$i) {
        my $parallelChannel = ModelParallelChannel->new($i);
        push(@{$self->{_parallelChannels}}, $parallelChannel);
    }
    bless $self, $class;
    return $self;
}

sub owningOperator
{
    my ($self) = @_;
    my $owningOper = $Globals::modelOperators[$self->{_owningOperIndex}];
    return $owningOper;
}

sub isSplitter
{
    my ($self) = @_;
    return 1;
}

sub isPrimitive
{
    my ($self) = @_;
    return 0;
}

sub isComposite
{
    my ($self) = @_;
    return 0;
}

sub numberOfInputPorts
{
    return 1;
}

sub numberOfOutputPorts
{
    my ($self) = @_;
    return scalar @{$self->{_parallelChannels}};
}

sub index
{
    my ($self) = @_;
    return $self->{_index};
}

sub addChannelConnection
{
    my ($self, $channelIndex, $toOperIndex, $toPortIndex) = @_;
    my $parallelChannel = $self->{_parallelChannels}->[$channelIndex];
    $parallelChannel->addConnection($toOperIndex, $toPortIndex);
}

sub genADL
{
    my ($self, $indent) = @_;
    my $index = $self->{_index};
    $self->print($indent, "<splitter index=\"$index\">\n");
    $indent += 3;
    foreach my $parallelChannel (@{$self->{_parallelChannels}}) {
        $parallelChannel->genADL($indent);
    }
    $indent -= 3;
    $self->print($indent, "</splitter>\n");
}

sub graph
{
    my ($self, $graph) = @_;
    my $node = OperatorGraphNode->new($self, "purple");
    $graph->addNode($node);
    foreach my $parallelChannel (@{$self->{_parallelChannels}}) {
        $parallelChannel->graph($graph, $self);
    }
}

1;

#####################################################
package ModelOperator;
use strict;
use Data::Dumper;
our @ISA = qw(ModelNode);

sub new
{
    my ($class, $adlOperator, $owningComposite) = @_;
    my $self = {};
    my $name = $adlOperator->{name};
    $self->{_adlOperator} = $adlOperator;
    $self->{_owningComposite} = $owningComposite;
    $self->{_inputPorts} = [];
    $self->{_outputPorts} = [];
    die("Internal error: Index not defined") unless defined($adlOperator->{index});
    $self->{_index} = $adlOperator->{index};
    $name =~ /^(?:.*\.)?(.*)/;
    $self->{_name} = $1;
    $self->{_startLine} = $adlOperator->{startLine};
    $self->{_endLine} = $adlOperator->{endLine};
    $self->{_sourceIndex} = $adlOperator->{sourceIndex};
    $self->{_isReplica} = 0;
    bless $self, $class;
    $Globals::modelOperators[$self->{_index}] = $self;
    return $self;
}

sub replicate
{
    my ($self) = @_;
    my $replica = {};
    $replica->{_index} = ++$Globals::maxOperIndex;
    $Globals::modelOperators[$replica->{_index}] = $replica;
    $replica->{_adlOperator} = $self->{_adlOperator};
    $replica->{_owningComposite} = $self->{_owningComposite};
    $replica->{_name} = $self->{_name};
    $replica->{_startLine} = $self->{_startLine};
    $replica->{_endLine} = $self->{_endLine};
    $replica->{_sourceIndex} = $self->{_sourceIndex};
    $replica->{_isReplica} = 1;
    $replica->{_inputPorts} = [];
    $replica->{_outputPorts} = [];
    foreach my $iPort (@{$self->{_inputPorts}}) {
        my $newPort = $iPort->replicate($replica);
        push(@{$replica->{_inputPorts}}, $newPort);
    }
    foreach my $oPort (@{$self->{_outputPorts}}) {
        my $newPort = $oPort->replicate($replica);
        push(@{$replica->{_outputPorts}}, $newPort);
    }
    bless($replica, 'ModelOperator');
    return $replica;
}

sub isReplica
{
    my ($self) = @_;
    return $self->{_isReplica};
}

sub isPrimitive
{
    my ($self) = @_;
    return 0;
}

sub isComposite
{
    my ($self) = @_;
    return 0;
}

sub isImport
{
    my ($self) = @_;
    return 0;
}

sub isExport
{
    my ($self) = @_;
    return 0;
}

sub setParallelRegionInfo
{
    my ($self, $parallelRegion, $parallelChannel) = @_;
    $self->{_parallelRegion} = $parallelRegion;
    $self->{_parallelChannel} = $parallelChannel;
}

sub graph
{
    my ($self, $graph) = @_;
    foreach my $iPort (@{$self->{_inputPorts}}) {
        $iPort->graph($graph, $self);
    }
    foreach my $oPort (@{$self->{_outputPorts}}) {
        $oPort->graph($graph, $self);
    }
}

sub logicalName
{
    my ($self) = @_;
    return $self->{_name};
}

sub fullyQualifiedOwningLogicalCompositeName
{
    my ($self) = @_;
    if (defined($self->{_owningComposite})) {
        my $fqn = $self->{_owningComposite}->fullyQualifiedOwningLogicalCompositeName();
        $fqn .= '.' if ($fqn ne '');
        $fqn .= $self->logicalName();
        return $fqn;
    }
    return "";
}

sub fullyQualifiedOwningCompositeName
{
    my ($self) = @_;
    if (defined($self->{_owningComposite})) {
        my $fqn = $self->{_owningComposite}->fullyQualifiedOwningCompositeName();
        $fqn .= '.' if ($fqn ne '');
        $fqn .= $self->name();
        return $fqn;
    }
    return "";
}

sub fullyQualifiedLogicalName
{
    my ($self) = @_;
    my $fqn = (defined($self->{_owningComposite})) ? $self->{_owningComposite}->fullyQualifiedOwningLogicalCompositeName() : "";
    $fqn .= '.' if ($fqn ne '');
    $fqn .= $self->logicalName();
    return $fqn;
}

sub fullyQualifiedName
{
    my ($self) = @_;
    my $fqn = (defined($self->{_owningComposite})) ? $self->{_owningComposite}->fullyQualifiedOwningCompositeName() : "";
    $fqn .= '.' if ($fqn ne '');
    $fqn .= $self->name();
    return $fqn;
}

sub name
{
    my ($self) = @_;
    my $name = $self->{_name};
    $name .= "[" . $self->{_parallelChannel} . "]" if (defined($self->{_parallelChannel}));
    return $name;
}

sub numberOfInputPorts
{
    my ($self) = @_;
    return scalar @{$self->{_inputPorts}};
}

sub numberOfOutputPorts
{
    my ($self) = @_;
    return scalar @{$self->{_outputPorts}};
}

sub isMainComposite
{
    my ($self) = @_;
    return 1 if ($self->isComposite() && !defined($self->{_owningComposite}));
    return 0;
}

sub index
{
    my ($self) = @_;
    return $self->{_index};
}

# Is this operator in a parallel region.  This is true if this operator is a parallel region
# or if it is contained within a composite that is a parallel region
sub isInParallelRegion
{
    my ($self) = @_;
    return 1 if (defined($self->{_parallelRegion}));
    if (defined($self->{_owningComposite})) {
        return $self->{_owningComposite}->isInParallelRegion();
    }
    return 0;
}

sub isParallelRegion
{
    my ($self) = @_;
    return 1 if (defined($self->{_parallelRegion}));
    return 0;
}

sub parallelChannelIndexes
{
    my ($self) = @_;
    my $channelIndexes;
    if (defined($self->{_owningComposite}) && $self->{_owningComposite}->isInParallelRegion()) {
        my $parentIndexes = $self->{_owningComposite}->parallelChannelIndexes();
        $channelIndexes .= $parentIndexes;
    }
    if (defined($self->{_parallelChannel})) {
        $channelIndexes .= '[' . $self->{_parallelChannel} . ']';
    }
    return $channelIndexes;
}

# Returns the closest parallel region to the given operator
sub containingParallelRegion
{
    my ($self) = @_;
    if (defined($self->{_parallelRegion})) {
        return $self->{_parallelRegion};
    }
    die("Internal error") unless defined($self->{_owningComposite});
    return $self->{_owningComposite}->containingParallelRegion();
}

sub containingChannelIndex
{
    my ($self) = @_;
    if (defined($self->{_parallelChannel})) {
        return $self->{_parallelChannel};
    }
    die("Internal error") unless defined($self->{_owningComposite});
    return $self->{_owningComposite}->containingChannelIndex();
}

1;
#####################################################
package PhysicalNameBasedImport;
use strict;
use Data::Dumper;
use Carp('longmess');
our @ISA = qw(PhysicalNode);

sub new
{
    my ($class, $index, $logicalIndex, $applicationName, $streamName, $importOperName, $logicalImportOperName, $filter) = @_;
    my $self = {};
    $self->{_index} = $index;
    $self->{_logicalIndex} = $logicalIndex;
    $self->{_applicationName} = $applicationName;
    $self->{_streamName} = $streamName;
    $self->{_importOperName} = $importOperName;
    $self->{_logicalImportOperName} = $logicalImportOperName;
    $self->{_filter} = $filter if defined($filter);
    bless $self, $class;
    return $self;
}

sub filter
{
    my ($self) = @_;
    return $self->{_filter};
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    my $index = $self->{_index};
    my $logicalIndex = $self->{_logicalIndex};
    my $importOperName = $self->{_importOperName};
    my $logicalImportOperName = $self->{_logicalImportOperName};
    my $applicationName = $self->{_applicationName};
    my $streamName = $self->{_streamName};
    $self->print($indent, "<nameBasedImport index=\"$index\" logicalIndex=\"$logicalIndex\" importOperName=\"$importOperName\" logicalImportOperName=\"$logicalImportOperName\" applicationName=\"$applicationName\" streamName=\"$streamName\" xsi:type=\"physical:physNameBasedImportType\"/>\n");
}

1;
#####################################################

package PhysicalPropertyBasedImport;
use strict;
use Data::Dumper;
use Carp('longmess');
our @ISA = qw(PhysicalNode);

sub new
{
    my ($class, $index, $logicalIndex, $subscription, $importOperName, $logicalImportOperName, $filter) = @_;
    my $self = {};
    $self->{_index} = $index;
    $self->{_logicalIndex} = $logicalIndex;
    $self->{_subscription} = $subscription;
    $self->{_importOperName} = $importOperName;
    $self->{_logicalImportOperName} = $logicalImportOperName;
    $self->{_filter} = $filter if defined($filter);
    bless $self, $class;
    return $self;
}

sub filter
{
    my ($self) = @_;
    return $self->{_filter};
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    my $index = $self->{_index};
    my $logicalIndex = $self->{_logicalIndex};
    my $importOperName = $self->{_importOperName};
    my $logicalImportOperName = $self->{_logicalImportOperName};
    my $subscription = $self->{_subscription};
    $subscription=~s/\&/&amp;/g;
    $subscription=~s/\"/&quot;/g;
    $self->print($indent, "<propertyBasedImport index=\"$index\" logicalIndex=\"$logicalIndex\" importOperName=\"$importOperName\" logicalImportOperName=\"$logicalImportOperName\" subscription=\"$subscription\" xsi:type=\"physical:physPropertyBasedImportType\"/>\n");
}

1;
#####################################################
package ModelNameBasedImport;
use strict;
use Data::Dumper;
use Carp('longmess');
our @ISA = qw(ModelNode);

sub new
{
    my ($class, $adlImport, $owningModelOperator) = @_;
    my $self = {};
    $self->{_logicalIndex} = $adlImport->{index};
    $self->{_applicationName} = $adlImport->{applicationName};
    $self->{_streamName} = $adlImport->{streamName};
    $self->{_filter} = $adlImport->{filter} if defined($adlImport->{filter});
    $self->{_owningModelOperator} = $owningModelOperator;
    bless $self, $class;
    return $self;
}

sub replicate
{
    my ($self, $owningModelOperator) = @_;
    my $replica = {};
    $replica->{_logicalIndex} = $self->{_logicalIndex};
    $replica->{_applicationName} = $self->{_applicationName};
    $replica->{_streamName} = $self->{_streamName};
    $replica->{_filter} = $self->{_filter} if defined($self->{_filter});
    $replica->{_owningModelOperator} = $owningModelOperator;
    bless($replica, 'ModelNameBasedImport');
    return $replica;
}

sub physicalImport
{
    my ($self, $index) = @_;
    my $physicalImport = PhysicalNameBasedImport->new($index, $self->{_logicalIndex}, $self->{_applicationName}, 
                                                      $self->{_streamName}, $self->{_owningModelOperator}->fullyQualifiedName(), 
                                                      $self->{_owningModelOperator}->fullyQualifiedLogicalName(),
                                                      $self->{_filter});
    return $physicalImport;
}

sub genADL
{
    my ($self, $indent) = @_;
    my $importOperName = $self->{_owningModelOperator}->fullyQualifiedName();
    my $logicalImportOperName = $self->{_owningModelOperator}->fullyQualifiedLogicalName();
    my $applicationName = $self->{_applicationName};
    my $streamName = $self->{_streamName};
    my $filter = " filter=\"$self->{_filter}\"" if defined($self->{_filter});
    $self->print($indent, "<nameBaseImport importOperName=\"$importOperName\" logicalImportOperName=\"$logicalImportOperName\" applicationName=\"$applicationName\" streamName=\"$streamName\"$filter>\n");
}

1;
#####################################################
package ModelPropertyBasedImport;
use strict;
use Data::Dumper;
use Carp('longmess');
our @ISA = qw(ModelNode);

sub new
{
    my ($class, $adlImport, $owningModelOperator) = @_;
    my $self = {};
    $self->{_logicalIndex} = $adlImport->{index};
    $self->{_subscription} = $adlImport->{subscription};
    $self->{_owningModelOperator} = $owningModelOperator;
    $self->{_filter} = $adlImport->{filter} if defined($adlImport->{filter});
    bless $self, $class;
    return $self;
}

sub replicate
{
    my ($self, $owningModelOperator) = @_;
    my $replica = {};
    $replica->{_logicalIndex} = $self->{_logicalIndex};
    $replica->{_subscription} = $self->{_subscription};
    $replica->{_filter} = $self->{_filter} if defined($self->{_filter});
    $replica->{_owningModelOperator} = $owningModelOperator;
    bless($replica, 'ModelPropertyBasedImport');
    return $replica;
}

sub physicalImport
{
    my ($self, $index) = @_;
    my $physicalImport = PhysicalPropertyBasedImport->new($index, $self->{_logicalIndex}, 
                                                          $self->{_subscription}, $self->{_owningModelOperator}->fullyQualifiedName(), 
                                                          $self->{_owningModelOperator}->fullyQualifiedLogicalName(), 
                                                          $self->{_filter});
    return $physicalImport;
}

sub genADL
{
    my ($self, $indent) = @_;
    my $logicalIndex = $self->{_logicalIndex};
    my $importOperName = $self->{_owningModelOperator}->fullyQualifiedName();
    my $logicalImportOperName = $self->{_owningModelOperator}->fullyQualifiedLogicalName();
    my $subscription = $self->{_subscription};
    my $streamName = $self->{_streamName};
    my $filter = " filter=\"$self->{_filter}\"" if defined($self->{_filter});
    $self->print($indent, "<nameBaseImport logicalIndex=\"$logicalIndex\" importOperName=\"$importOperName\" logicalImportOperName=\"$logicalImportOperName\" subscription=\"$subscription\"$filter>\n");
}

1;
#####################################################
package ModelExportedStream;
use strict;
use Data::Dumper;
use Carp('longmess');
our @ISA = qw(ModelNode);

sub new
{
    my ($class, $adlExport, $owningModelOperator) = @_;
    my $self = {};
    $self->{_adlExport} = $adlExport;
    $self->{_owningModelOperator} = $owningModelOperator;
    bless $self, $class;
    return $self;
}

sub name
{
    my ($self) = @_;
    die("Internal error") unless defined($self->{_adlExport}->{name});
    return $self->{_adlExport}->{name};
}

sub specifyAllowFilter
{
    my ($self) = @_;
    return defined($self->{_adlExport}->{allowFilter});
}

sub allowFilter
{
    my ($self) = @_;
    die("Internal error") unless defined($self->{_adlExport}->{allowFilter});
    return $self->{_adlExport}->{allowFilter};
}

sub isNameBased
{
    my ($self) = @_;
    return defined($self->{_adlExport}->{name});
}

sub properties
{
    my ($self) = @_;
    die("Internal error") unless defined($self->{_adlExport}->{_properties});
    return $self->{_adlExport}->{_properties}->{_property};
}

sub owningModelOperator
{
    my ($self) = @_;
    return $self->{_owningModelOperator};
}

sub replicate
{
    my ($self, $owningModelOperator) = @_;
    my $replica = {};
    $replica->{_adlExport} = $self->{_adlExport};
    $replica->{_owningModelOperator} = $owningModelOperator;
    bless($replica, 'ModelExportedStream');
    return $replica;
}

sub physicalExport
{
    my ($self, $index) = @_;
    my $physicalExport = PhysicalExportedStream->new($self);
    return $physicalExport;
}

sub genADL
{
    my ($self, $indent) = @_;
    my $exportOperName = $self->{_owningModelOperator}->fullyQualifiedName();
    my $logicalExportOperName = $self->{_owningModelOperator}->fullyQualifiedLogicalName();
    if (defined($self->{_adlExport}->{name})) {
        my $streamId = $self->{_name};
        $self->print($indent, "<nameBaseExport exportOperName=\"$exportOperName\" logicalExportOperName=\"$logicalExportOperName\" streamId=\"$streamId\"/>\n");
    } else {
        $self->print($indent, "<propertyBasedExport exportOperName=\"$exportOperName\" logicalExportOperName=\"$logicalExportOperName\"/>\n");
        $indent += 3;
die;
        foreach my $property (@{$self->{_properties}}) {
            $property->genADL($indent);
        }
        $indent -= 3;
        $self->print($indent, "</propertyBasedExport>\n");
    }
}

1;
#####################################################
package PhysicalExportedStream;
use strict;
use Data::Dumper;
use Carp('longmess');
our @ISA = qw(PhysicalNode);

sub new
{
    my ($class, $modelExport) = @_;
    my $self = {};
    $self->{_modelExport} = $modelExport;
    bless $self, $class;
    return $self;
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    my $exportOperName = $self->{_modelExport}->owningModelOperator()->fullyQualifiedName();
    my $logicalExportOperName = $self->{_modelExport}->owningModelOperator()->fullyQualifiedLogicalName();
    my $allowFilter = "";
    $allowFilter = " allowFilter=\"" . $self->{_modelExport}->allowFilter() . "\"" if ($self->{_modelExport}->specifyAllowFilter());
    if ($self->{_modelExport}->isNameBased()) {
        my $name = $self->{_modelExport}->name();
        $self->print($indent, "<exportedStream exportOperName=\"$exportOperName\" logicalExportOperName=\"$logicalExportOperName\" name=\"$name\"$allowFilter xsi:type=\"physical:physExportedStreamType\"/>\n")
    } else {
        my $properties = $self->{_modelExport}->properties();
        $self->print($indent, "<exportedStream exportOperName=\"$exportOperName\" logicalExportOperName=\"$logicalExportOperName\"$allowFilter xsi:type=\"physical:physExportedStreamType\">\n");
        $indent += 3;
        $self->print($indent, "<properties>\n");
        $indent += 3;
        foreach my $property (@{$properties}) {
            $property->genADL($indent);
        }   
        $indent -= 3;
        $self->print($indent, "</properties>\n");
        $indent -= 3;
        $self->print($indent, "</exportedStream>\n");
    }
}

1;
#####################################################
package ModelPrimitiveImportOperator;
use strict;
use Data::Dumper;
use Carp('longmess');
our @ISA = qw(ModelOperator);

sub new
{
    my ($class, $adlPrimitive, $owningComposite) = @_;
    my $self = $class->SUPER::new($adlPrimitive, $owningComposite);
    $self->{_kind} = $adlPrimitive->{kind};
    $self->{_toolkitIndex} = $adlPrimitive->{toolkitIndex};
    my $logicalOperatorIndex = $adlPrimitive->{index};

    # Build the output ports and their connections
    my $adlOutputPorts = $adlPrimitive->{_outputPorts};
    $adlOutputPorts = $adlOutputPorts->{_port} if defined($adlOutputPorts);
    foreach my $outputPort (@{$adlOutputPorts}) {
        my $modelOutputPort = ModelPrimitiveImportOutputPort->new($outputPort, $self);
        push(@{$self->{_outputPorts}}, $modelOutputPort);
    }
    my $adlImport = $Globals::importOperatorInfoMap{$adlPrimitive->{name}};
    if (ref($adlImport) eq 'nameBasedImportType') {
        $self->{_importInfo} = ModelNameBasedImport->new($adlImport, $self);
    } else {
        $self->{_importInfo} = ModelPropertyBasedImport->new($adlImport, $self);
    }
    bless $self, $class;
    return $self;
}

sub fixConnections
{
    my ($self, $state) = @_;
    foreach my $port (@{$self->{_outputPorts}}) {
        print STDERR "Fixing connections for primitive import operator $self->{_index} output port $port->{_index}\n" if ($Globals::verbose);
        $port->fixConnections($state);
    }
}

sub importInfo
{
    my ($self) = @_;
    return $self->{_importInfo};
}

sub isImport
{
    return 1;
}

sub replicate
{
    my ($self, $state, $owningComposite) = @_;
    my $replica = $self->SUPER::replicate();
    $replica->{_owningComposite} = $owningComposite;
    $replica->{_kind} = $self->{_kind};
    $replica->{_toolkitIndex} = $self->{_toolkitIndex};
    $replica->{_outputPorts} = [];
    $replica->{_importInfo} = $self->{_importInfo}->replicate($replica);

    print STDERR "Adding mapping from primitive import operator $self->{_index} to primitive import operator $replica->{_index} to state\n" if ($Globals::verbose);
    $state->{_operatorIndexMap}->{$self->index()} = $replica->index();

    foreach my $oPort (@{$self->{_outputPorts}}) {
        my $newPort = $oPort->replicate($replica);
        push(@{$replica->{_outputPorts}}, $newPort);
    }

    bless($replica, 'ModelPrimitiveImportOperator');
    return $replica;
}

sub getOutputPortPhysicalConnections
{
    die;
}

sub genADL
{
    my ($self, $indent) = @_;
    my $index = $self->{_index};
    my $kind = $self->{_kind};
    my $name = $self->fullyQualifiedName();
    my $startLine = $self->{_startLine};
    my $endLine = $self->{_endLine};
    my $toolkitIndex = $self->{_toolkitIndex};
    my $sourceIndex = $self->{_sourceIndex};
    $self->print($indent, "<primitiveOperInstance index=\"$index\" kind=\"$kind\" name=\"$name\" startLine=\"$startLine\" endLine=\"$endLine\" toolkitIndex=\"$toolkitIndex\" sourceIndex=\"$sourceIndex\">\n");
    $indent += 3;
    $self->{_importInfo}->genADL($indent);
    if (scalar @{$self->{_outputPorts}} > 0) {
        $self->print($indent, "<outputPorts>\n");
        $indent += 3;
        foreach my $port (@{$self->{_outputPorts}}) {
            $port->genADL($indent);
        }
        $indent -= 3;
        $self->print($indent, "</outputPorts>\n");
    }
    $indent -= 3;
    $self->print($indent, "</primitiveOperInstance>\n");
}

1;
#####################################################
package ModelPrimitiveExportOperator;
use strict;
use Data::Dumper;
use Carp('longmess');
our @ISA = qw(ModelOperator);

sub new
{
    my ($class, $adlPrimitive, $owningComposite) = @_;
    my $self = $class->SUPER::new($adlPrimitive, $owningComposite);
    $self->{_kind} = $adlPrimitive->{kind};
    $self->{_toolkitIndex} = $adlPrimitive->{toolkitIndex};
    my $logicalOperatorIndex = $adlPrimitive->{index};

    # Build the input ports and their connections
    my $adlInputPorts = $adlPrimitive->{_inputPorts};
    $adlInputPorts = $adlInputPorts->{_port} if defined($adlInputPorts);
    foreach my $inputPort (@{$adlInputPorts}) {
        my $modelInputPort = ModelPrimitiveExportInputPort->new($inputPort, $self);
        push(@{$self->{_inputPorts}}, $modelInputPort);
    }
    my $adlExport = $Globals::exportOperatorInfoMap{$adlPrimitive->{name}};
    die("Internal error") unless (ref($adlExport) eq 'exportedStreamType');
    $self->{_exportInfo} = ModelExportedStream->new($adlExport, $self);
    bless $self, $class;
    return $self;
}

sub fixConnections
{
    my ($self, $state) = @_;
    foreach my $port (@{$self->{_inputPorts}}) {
        print STDERR "Fixing connections for primitive export operator $self->{_index} input port $port->{_index}\n" if ($Globals::verbose);
        $port->fixConnections($state);
    }
}

sub exportInfo
{
    my ($self) = @_;
    return $self->{_exportInfo};
}

sub isExport
{
    return 1;
}

sub replicate
{
    my ($self, $state, $owningComposite) = @_;
    my $replica = $self->SUPER::replicate();
    $replica->{_owningComposite} = $owningComposite;
    $replica->{_kind} = $self->{_kind};
    $replica->{_toolkitIndex} = $self->{_toolkitIndex};
    $replica->{_inputPorts} = [];
    $replica->{_exportInfo} = $self->{_exportInfo}->replicate($replica);

    print STDERR "Adding mapping from primitive export operator $self->{_index} to primitive export operator $replica->{_index} to state\n" if ($Globals::verbose);
    $state->{_operatorIndexMap}->{$self->index()} = $replica->index();

    foreach my $iPort (@{$self->{_inputPorts}}) {
        my $newPort = $iPort->replicate($replica);
        push(@{$replica->{_inputPorts}}, $newPort);
    }

    bless($replica, 'ModelPrimitiveExportOperator');
    return $replica;
}

sub getInputPortPhysicalConnections
{
    die;
}

sub genADL
{
    my ($self, $indent) = @_;
    my $index = $self->{_index};
    my $kind = $self->{_kind};
    my $name = $self->fullyQualifiedName();
    my $startLine = $self->{_startLine};
    my $endLine = $self->{_endLine};
    my $toolkitIndex = $self->{_toolkitIndex};
    my $sourceIndex = $self->{_sourceIndex};
    $self->print($indent, "<primitiveOperInstance index=\"$index\" kind=\"$kind\" name=\"$name\" startLine=\"$startLine\" endLine=\"$endLine\" toolkitIndex=\"$toolkitIndex\" sourceIndex=\"$sourceIndex\">\n");
    $indent += 3;
    $self->{_exportInfo}->genADL($indent);
    if (scalar @{$self->{_inputPorts}} > 0) {
        $self->print($indent, "<inputPorts>\n");
        $indent += 3;
        foreach my $port (@{$self->{_inputPorts}}) {
            $port->genADL($indent);
        }
        $indent -= 3;
        $self->print($indent, "</inputPorts>\n");
    }
    $indent -= 3;
    $self->print($indent, "</primitiveOperInstance>\n");
}

1;
#####################################################
package ModelPrimitiveOperator;
use strict;
use Data::Dumper;
use Carp('longmess');
our @ISA = qw(ModelOperator);

sub new
{
    my ($class, $adlPrimitive, $owningComposite) = @_;
    print STDERR "Creating model operator for index $adlPrimitive->{index}\n" if ($Globals::verbose); 
    my $self = $class->SUPER::new($adlPrimitive, $owningComposite);
    $self->{_kind} = $adlPrimitive->{kind};
    $self->{_toolkitIndex} = $adlPrimitive->{toolkitIndex};
    my $logicalOperatorIndex = $adlPrimitive->{index};
    my $operInstance = $Globals::operInstances{$logicalOperatorIndex};
    my $owningPE = $operInstance->owningPE();

    $self->{_definitionIndex} = $operInstance->{definitionIndex};
    $self->{_singleThreadedOnInputs} = $operInstance->{singleThreadedOnInputs};
    $self->{_singleThreadedOnOutputs} = $operInstance->{singleThreadedOnOutputs};
    $self->{_restartable} = $operInstance->{restartable};
    $self->{_relocatable} = $operInstance->{relocatable};
    $self->{_class} = $operInstance->{class};
    $self->{_originalPE} = $owningPE->index();
    $self->{_physicalIndex} = $Globals::physicalOperatorMaxIndex++;

    # Build the input ports and their connections
    my $adlInputPorts = $adlPrimitive->{_inputPorts};
    $adlInputPorts = $adlInputPorts->{_port} if defined($adlInputPorts);
    foreach my $inputPort (@{$adlInputPorts}) {
        my $modelInputPort = ModelPrimitiveInputPort->new($inputPort, $self);
        push(@{$self->{_inputPorts}}, $modelInputPort);
    }

    # Build the output ports and their connections
    my $adlOutputPorts = $adlPrimitive->{_outputPorts};
    $adlOutputPorts = $adlOutputPorts->{_port} if defined($adlOutputPorts);
    foreach my $outputPort (@{$adlOutputPorts}) {
        my $modelOutputPort = ModelPrimitiveOutputPort->new($outputPort, $self);
        push(@{$self->{_outputPorts}}, $modelOutputPort);
    }

    bless $self, $class;
    return $self;
}

# This create a copy of the given operator with a new index
sub replicate
{
    my ($self, $state, $owningComposite) = @_;
    my $replica = $self->SUPER::replicate();
    $replica->{_owningComposite} = $owningComposite;
    $replica->{_kind} = $self->{_kind};
    $replica->{_definitionIndex} = $self->{_definitionIndex};
    $replica->{_singleThreadedOnInputs} = $self->{_singleThreadedOnInputs};
    $replica->{_singleThreadedOnOutputs} = $self->{_singleThreadedOnOutputs};
    $replica->{_restartable} = $self->{_restartable};
    $replica->{_relocatable} = $self->{_relocatable};
    $replica->{_originalPE} = $self->{_originalPE};
    $replica->{_physicalIndex} = $self->{_physicalIndex};
    $replica->{_class} = $self->{_class};
    $replica->{_toolkitIndex} = $self->{_toolkitIndex};
    $replica->{_physicalIndex} = $Globals::physicalOperatorMaxIndex++;
    print STDERR "Adding mapping from primitive operator $self->{_index} to primitive operator $replica->{_index} to state\n" if ($Globals::verbose);
    $state->{_operatorIndexMap}->{$self->index()} = $replica->index();
    bless($replica, 'ModelPrimitiveOperator');
    return $replica;
}

sub hasNonColocatedSplitter
{
    my ($self)  = @_;
    foreach my $inputPort (@{$self->{_inputPorts}}) {
        return 1 if ($inputPort->hasNonColocatedSplitter());
    }
    return 0;
}

sub findColocatedOperator
{
    my ($self) = @_;
    foreach my $inputPort (@{$self->{_inputPorts}}) {
        my $oper = $inputPort->findColocatedOperator();
        return $oper if defined($oper);
    }
    return undef;
}

sub fixConnections
{
    my ($self, $state) = @_;
    foreach my $port (@{$self->{_inputPorts}}) {
        print STDERR "Fixing connections for primitive operator $self->{_index} input port $port->{_index}\n" if ($Globals::verbose);
        $port->fixConnections($state);
    }
    foreach my $port (@{$self->{_outputPorts}}) {
        print STDERR "Fixing connections for primitive operator $self->{_index} output port $port->{_index}\n" if ($Globals::verbose);
        $port->fixConnections($state);
    }
}

sub originalPE
{
    my ($self) = @_;
    die("Internal error") unless defined($self->{_originalPE});
    return $self->{_originalPE};
}

sub getIPort
{
    my ($self, $portIndex) = @_;
    return $self->{_inputPorts}[$portIndex];
}

sub getOPort
{
    my ($self, $portIndex) = @_;
    return $self->{_outputPorts}[$portIndex];
}

sub physicalOperatorIndex
{
    my ($self) = @_;
    return $self->{_physicalIndex};
}

sub logicalOperator
{
    my ($self) = @_;
    return $self->{_adlOperator};
}

sub isPrimitive
{
    my ($self) = @_;
    return 1;
}

sub addInputConnection
{
    my ($self, $iPortIndex, $toOperIndex, $toPortIndex) = @_;
    foreach my $inputPort (@{$self->{_inputPorts}}) {
        if ($inputPort->index() == $iPortIndex) {
            $inputPort->addConnection($toOperIndex, $toPortIndex);
            return;
        }
    }
    die("Internal error"); # We should not reach here
}

# Called after creating a replica for a parallel region
# $self here is the replica.
sub addConnections
{
    my ($self, $channelIndex) = @_;
    # Add connections for the input ports.  This replica was created from the first operator which already 
    # has a connection to the splitter feeding it.  We just need to fix the channel and add a connection to the splitter
    # for each input port
    foreach my $inputPort (@{$self->{_inputPorts}}) {
        $inputPort->addConnections($self, $channelIndex);
    }
    
    # Add connections for the output ports
    # Downstream operators need connections to this operator
    foreach my $outputPort (@{$self->{_outputPorts}}) {
        $outputPort->addConnections($self);
    }
}

sub convertConnectionToSplitter
{
    my ($self, $parallelRegion, $fromPortIndex, $toOperIndex, $toPortIndex) = @_;
    # Find the output port
    foreach my $port (@{$self->{_outputPorts}}) {
        if ($port->index() == $fromPortIndex) {
            my $splitter = $port->convertConnectionToSplitter($self, $parallelRegion, $toOperIndex, $toPortIndex);
            return $splitter;
        }
    }
    die("Internal error: invalid port specified");
}

# This instance represents the channel 0 operator in a primitive parallel region.  Any operator
# feeding this operator's input ports needs to have a splitter added
sub addSplitters
{
    my ($self, $parallelRegion) = @_;
    foreach my $inputPort (@{$self->{_inputPorts}}) {
        $inputPort->addSplitters($self, $parallelRegion);
    }
}

sub genADL
{
    my ($self, $indent) = @_;
    my $index = $self->{_index};
    my $kind = $self->{_kind};
    my $name = $self->fullyQualifiedName();
    my $startLine = $self->{_startLine};
    my $endLine = $self->{_endLine};
    my $toolkitIndex = $self->{_toolkitIndex};
    my $sourceIndex = $self->{_sourceIndex};
    $self->print($indent, "<primitiveOperInstance index=\"$index\" kind=\"$kind\" name=\"$name\" startLine=\"$startLine\" endLine=\"$endLine\" toolkitIndex=\"$toolkitIndex\" sourceIndex=\"$sourceIndex\">\n");
    $indent += 3;
    my $originalPEIndex = $self->{_originalPE};
    my $class = $self->{_class};
    my $definitionIndex = $self->{_definitionIndex};
    my $singleThreadedOnInputs = $self->{_singleThreadedOnInputs};
    my $singleThreadedOnOutputs = $self->{_singleThreadedOnOutputs};
    $self->print($indent, "<augmentedOperInfo originalPEIndex=\"$originalPEIndex\" class=\"$class\" definitionIndex=\"$definitionIndex\" singleThreadedOnInputs=\"$singleThreadedOnInputs\" singleThreadedOnOutputs=\"$singleThreadedOnOutputs\"/>\n");
    if (scalar @{$self->{_inputPorts}} > 0) {
        $self->print($indent, "<inputPorts>\n");
        $indent += 3;
        foreach my $port (@{$self->{_inputPorts}}) {
            $port->genADL($indent);
        }
        $indent -= 3;
        $self->print($indent, "</inputPorts>\n");
    }
    if (scalar @{$self->{_outputPorts}} > 0) {
        $self->print($indent, "<outputPorts>\n");
        $indent += 3;
        foreach my $port (@{$self->{_outputPorts}}) {
            $port->genADL($indent);
        }
        $indent -= 3;
        $self->print($indent, "</outputPorts>\n");
    }
    $indent -= 3;
    $self->print($indent, "</primitiveOperInstance>\n");
}

sub graph
{
    my ($self, $graph) = @_;
    my $node = OperatorGraphNode->new($self, "light blue");
    $graph->addNode($node);
    $self->SUPER::graph($graph);
}

1;
#####################################################
package ParallelTransformState;
use strict;

sub new
{
    my ($class, $parallelRegions) = @_;
    my $self = {};
    $self->{_parallelRegions} = $parallelRegions;
    $self->{_parallelRegionStack} = [];
    $self->{_operatorIndexMap} = {};
    bless $self, $class;
    return $self;
}

1;
#####################################################
package ModelCompositeOperator;
use strict;
use Data::Dumper;
use Carp qw(longmess);
our @ISA = qw(ModelOperator);

sub new1
{
    my ($class, $adlComposite, $owningComposite) = @_;
    my $self = $class->SUPER::new($adlComposite, $owningComposite);
    bless $self, $class;
    $self->{_compositeOperators} = [];
    $self->{_primitiveOperators} = [];
}

sub isComposite
{
    my ($self) = @_;
    return 1;
}

sub new
{
    my ($class, $adlComposite, $owningComposite) = @_;
    my $self = $class->SUPER::new($adlComposite, $owningComposite);
    $self->{_compositeOperIndex} = $adlComposite->{compositeOperIndex};
    bless $self, $class;
    $self->{_compositeOperators} = [];
    $self->{_primitiveOperators} = [];

    # Add the input ports and their connections
    my $adlInputPorts = $adlComposite->{_inputPorts};
    $adlInputPorts = $adlInputPorts->{_port} if defined($adlInputPorts);
    foreach my $inputPort (@{$adlInputPorts}) {
        my $modelInputPort = ModelCompositeInputPort->new($inputPort, $self);
        push(@{$self->{_inputPorts}}, $modelInputPort);   
    }

    # Add the output ports and their connections
    my $adlOutputPorts = $adlComposite->{_outputPorts};
    $adlOutputPorts = $adlOutputPorts->{_port} if defined($adlOutputPorts);
    foreach my $outputPort (@{$adlOutputPorts}) {
        my $modelOutputPort = ModelCompositeOutputPort->new($outputPort, $self);
        push(@{$self->{_outputPorts}}, $modelOutputPort);
    }

    # Add the primitive operators
    my $adlPrimitives = $adlComposite->{_primitiveOperInstance};
    foreach my $adlPrimitive (@{$adlPrimitives}) {
        my $modelPrimitive ;
        if ($adlPrimitive->isImport()) {
            $modelPrimitive = ModelPrimitiveImportOperator->new($adlPrimitive, $self);
        } elsif ($adlPrimitive->isExport()) {
            $modelPrimitive = ModelPrimitiveExportOperator->new($adlPrimitive, $self);
        } else {
            $modelPrimitive = ModelPrimitiveOperator->new($adlPrimitive, $self);
        }
        push(@{$self->{_primitiveOperators}}, $modelPrimitive);
    }
    # Add the nested composite operators
    my $adlComposites = $adlComposite->{_compositeOperInstance};
    foreach my $adlComp (@{$adlComposites}) {
        my $modelComposite = ModelCompositeOperator->new($adlComp, $self);
        push(@{$self->{_compositeOperators}}, $modelComposite);
    }

    return $self;
}

sub replicate
{
    my ($self, $state) = @_;
    print STDERR "Replicating composite operator $self->{_index}\n" if ($Globals::verbose);
    my $replica = $self->SUPER::replicate();
    bless($replica, 'ModelCompositeOperator');
    $replica->{_compositeOperIndex} = $self->{_compositeOperIndex};

    print STDERR "Adding mapping from composite operator $self->{_index} to composite operator $replica->{_index} to state\n" if ($Globals::verbose);
    $state->{_operatorIndexMap}->{$self->index()} = $replica->index();
    foreach my $composite (@{$self->{_compositeOperators}}) {
        my $newComp = $composite->replicate($state);
        push(@{$replica->{_compositeOperators}}, $newComp);
    }
    foreach my $primitive (@{$self->{_primitiveOperators}}) {
        my $newPrim = $primitive->replicate($state, $replica);
        push(@{$replica->{_primitiveOperators}}, $newPrim);
    }
    # We need to fix all the connections within the replicated composite.
    foreach my $composite (@{$replica->{_compositeOperators}}) {
        $composite->fixConnections($state);
    }
    foreach my $primitive (@{$replica->{_primitiveOperators}}) {
        $primitive->fixConnections($state);
    }
    foreach my $iPort (@{$replica->{_inputPorts}}) {
        $iPort->fixOutgoingConnections($state);
    }
    foreach my $oPort (@{$replica->{_outputPorts}}) {
        $oPort->fixIncomingConnections($state);
    }
    return $replica;
}

sub getInputPortImports
{
    my ($self, $portIndex, $portKind) = @_;
    my $iPort = $self->{_inputPorts}->[$portIndex];
    if ($portKind eq 'oportIndex') {
        return $iPort->getIncomingImports($portKind);
    } else {
        die("Internal error: not expected");
    }
    die("Internal error");  # We shouldn't get her
}

sub getInputPortPhysicalConnections
{
    my ($self, $fromPhysicalOperIndex, $fromModelOperPort, $portIndex, $portKind) = @_;
    my $iPort = $self->{_inputPorts}->[$portIndex];
    if ($portKind eq 'oportIndex') {
        return $iPort->getIncomingPhysicalConnections($fromPhysicalOperIndex, $fromModelOperPort, $portKind);
    } else {
        return $iPort->getOutgoingPhysicalConnections($fromPhysicalOperIndex, $fromModelOperPort, $portKind);
    }

    die("Internal error");  # We shouldn't get here
}

sub getOutputPortPhysicalConnections
{
    my ($self, $fromPhysicalOperIndex, $fromModelOperPort, $portIndex, $portKind) = @_;
    my $oPort = $self->{_outputPorts}->[$portIndex];
    if ($portKind eq 'oportIndex') {
        return $oPort->getIncomingPhysicalConnections($fromPhysicalOperIndex, $fromModelOperPort, $portKind);
    } else {
        return $oPort->getOutgoingPhysicalConnections($fromPhysicalOperIndex, $fromModelOperPort, $portKind);
    }

    die("Internal error");  # We shouldn't get here
}

# Find any export operators fed by the input port of this composite
sub getInputPortExports
{
    my ($self, $portIndex, $portKind) = @_;
    my $iPort = $self->{_inputPorts}->[$portIndex];
    if ($portKind eq 'oportIndex') {
        die("Internal error: not expected");
    } else {
        return $iPort->getOutgoingExports($portKind);
    }
    die("Internal error");  # We shouldn't get here
}

# Find any export operators being fed by this composite output port
sub getOutputPortExports
{
    my ($self, $portIndex, $portKind) = @_;
    my $oPort = $self->{_outputPorts}->[$portIndex];
    if ($portKind eq 'oportIndex') {
        die("Internal error: not expected");
    } else {
        return $oPort->getOutgoingExports($portKind);
    }
    die("Internal error");  # We shouldn't get here
}

sub getOutputPortImports
{
    my ($self, $portIndex, $portKind) = @_;
    my $oPort = $self->{_outputPorts}->[$portIndex];
    if ($portKind eq 'oportIndex') {
        return $oPort->getIncomingImports($portKind);
    } else {
        die("Internal error: not expected");
    }
    die("Internal error");  # We shouldn't get here
}

sub addConnections
{
    my ($self, $channelIndex) = @_;
    foreach my $iPort (@{$self->{_inputPorts}}) {
        $iPort->addIncomingConnections($self, $channelIndex);
    }
    foreach my $oPort (@{$self->{_outputPorts}}) {
        $oPort->addOutgoingConnections($self);
    }
}

# This method adds splitters to the output ports of every operator that feeds this composite operator
# The instance getting this call represents channel 0
sub addSplitters
{
    my ($self, $parallelRegion) = @_;
    foreach my $inputPort (@{$self->{_inputPorts}}) {
        $inputPort->addSplitters($self, $parallelRegion);
    }
}

sub performParallelTransformations
{
    my ($self, $state) = @_;

    print STDERR "Performing parallel transforms on composite operator $self->{_index}\n" if ($Globals::verbose);

    # Walk any contained composites and generate the parallel model for them
    my @composites = @{$self->{_compositeOperators}};
    foreach my $composite (@composites) {
        # First perform any nested transforms
        $composite->performParallelTransformations($state);
        my $operIndex = $composite->index();
        if ($state->{_parallelRegions}->isParallelRegion($operIndex)) {
            my $parallelRegion = $state->{_parallelRegions}->parallelRegion($operIndex);
            my $regionWidth = $parallelRegion->width();

            # This composite represents a parallel region.  First we must associate the existing composite with channel 0 of that region
            $composite->setParallelRegionInfo($parallelRegion, 0);
            $composite->addSplitters($parallelRegion);

            # Then we must create width-1 replicas
            push(@{$state->{_parallelRegionStack}}, $parallelRegion);
            --$regionWidth;
            print STDERR "Need to replicate operator $operIndex $regionWidth times\n" if ($Globals::verbose);
            for (my $i = 1; $i <= $regionWidth; ++$i) {
                my $replica = $composite->replicate($state);
                $replica->setParallelRegionInfo($parallelRegion, $i);
                $replica->addConnections($i);
                push(@{$self->{_compositeOperators}}, $replica);
            }
            pop(@{$state->{_parallelRegionStack}});
        }
    }

    # Walk the contained primitives and perform any parallel transformations
    my @primitives = @{$self->{_primitiveOperators}};
    foreach my $primitive (@primitives) {
        my $operIndex = $primitive->index();
        if ($state->{_parallelRegions}->isParallelRegion($operIndex)) {
            my $parallelRegion = $state->{_parallelRegions}->parallelRegion($operIndex);
            my $regionWidth = $parallelRegion->width();

            # This primitive represents a parallel region.  We need to replicate the primitive, giving it a new index and adding/fixing connections
            $primitive->setParallelRegionInfo($parallelRegion, 0);
            $primitive->addSplitters($parallelRegion);

            push(@{$state->{_parallelRegionStack}}, $parallelRegion);
            --$regionWidth;
            print STDERR "Need to replicate operator $operIndex $regionWidth times\n" if ($Globals::verbose);
            for (my $i = 1; $i <= $regionWidth; ++$i) {
                my $replica = $primitive->replicate($state, $self);
                $replica->setParallelRegionInfo($parallelRegion, $i);
                $replica->addConnections($i);
                push(@{$self->{_primitiveOperators}}, $replica);
            }
            pop(@{$state->{_parallelRegionStack}});
        }
    }
}

sub genADL
{
    my ($self, $indent) = @_;
    my $index = $self->{_index};
    my $compositeOperIndex = $self->{_compositeOperIndex};
    my $name = $self->fullyQualifiedName();
    my $startLine = $self->{_startLine};
    my $endLine = $self->{_endLine};
    my $sourceIndex = $self->{_sourceIndex};
    $self->print($indent, "<compositeOperInstance index=\"$index\" compositeOperIndex=\"$compositeOperIndex\" name=\"$name\" startLine=\"$startLine\" endLine=\"$endLine\" sourceIndex=\"$sourceIndex\">\n");
    $indent += 3;
    if (scalar @{$self->{_inputPorts}} > 0) {
        $self->print($indent, "<inputPorts>\n");
        $indent += 3;
        foreach my $port (@{$self->{_inputPorts}}) {
            $port->genADL($indent);
        }
        $indent -= 3;
        $self->print($indent, "</inputPorts>\n");
    }
    if (scalar @{$self->{_outputPorts}} > 0) {
        $self->print($indent, "<outputPorts>\n");
        $indent += 3;
        foreach my $port (@{$self->{_outputPorts}}) {
            $port->genADL($indent);
        }
        $indent -= 3;
        $self->print($indent, "</outputPorts>\n");
    }
    foreach my $composite (@{$self->{_compositeOperators}}) {
        $composite->genADL($indent);
    }
    foreach my $primitive (@{$self->{_primitiveOperators}}) {
        $primitive->genADL($indent);
    }
    $indent -= 3;
    $self->print($indent, "</compositeOperInstance>\n");
}

sub graph
{
    my ($self, $graph) = @_;
    my $node = OperatorGraphNode->new($self, "cyan");
    $graph->addNode($node);
    foreach my $composite (@{$self->{_compositeOperators}}) {
        $composite->graph($graph);
    }
    foreach my $primitive (@{$self->{_primitiveOperators}}) {
        $primitive->graph($graph);
    }
    $self->SUPER::graph($graph);
    return $graph;
}

1;
#####################################################
#####################################################
#####################################################
package Node;
use strict;
use Data::Dumper;

sub new
{
   my ($class, $kind, $el) = @_;
   my $self = {_kind => $kind};
   if (defined($el)) {
       my $attrs = $el->{'Attributes'};
       foreach my $key (keys %{$attrs}) {
          my $name = $attrs->{$key}->{'Name'};
          my $value = $attrs->{$key}->{'Value'};
          $self->{$name} = $value;
       }
   }

   bless $self, $class;
   return $self;
}

sub copyCtor
{
    my ($self) = @_;
    die("$self->{_kind} must override copyCtor");
}

sub copyCtorInternal
{
    my ($class, $self) = @_;
    my $clone = {};
    foreach my $key (keys %{$self}) {
        $clone->{$key} = $self->{$key};
    }
    bless $clone, $class;
    return $clone;
}

sub start_element
{
    die('This must be overridden');
}

sub end_element
{
}

sub chars
{
    my ($self, $param) = @_;
}

sub indent
{
   my ($self, $indent) = @_;
   for (my $i = 0; $i < $indent; ++$i) {
      print " ";
   }
}

sub print
{
    my ($self, $indent, $string) = @_;
    $self->indent($indent);
    print $string;
}

sub printAttributes
{
    my ($self) = @_;
    my @keys = keys %$self;
    foreach my $key (keys %$self) {
        next if $key=~/^_/;
        my $value = $self->{$key};
        $value =~ s/\&/&amp;/g;
        $value =~ s/\"/&quot;/g;
        $value =~ s/\</&lt;/g;
        $self->print(0, " $key=\"$value\"");
    }
}

sub genAttributeOnlyElement
{
    my ($self, $indent, $name) = @_;
    $self->print($indent, "<$name");
    $self->printAttributes();
    $self->print(0, "/>\n");
}

sub gen
{
   my ($self, $indent) = @_;
   if ($Globals::physicalADL == 1) {
       $self->genPhysicalADL($indent);
   } else {
       $self->genADL($indent);
   }
}

sub genADL
{
    my ($self) = @_;
    die("$self->{_kind} must override genADL");
}

sub genPhysicalADL
{
   my ($self, $indent) = @_;
   $self->genADL($indent);
}

sub enter
{
    my ($self, $function) = @_;
    return if ($Globals::trace == 0);
    for (my $i = 0; $i < $Globals::functionIndent; ++$i) {
        print STDERR " ";
    }
    print STDERR "$function: - enter\n" if ($Globals::trace);
    $Globals::functionIndent += 3;
}

sub trace
{
    my ($self, $string) = @_;
    return if ($Globals::trace == 0);

    for (my $i = 0; $i < $Globals::functionIndent; ++$i) {
        print STDERR " ";
    }
    print STDERR $string, "\n";
}

sub exit
{
    my ($self, $function) = @_;
    return if ($Globals::trace == 0);
    $Globals::functionIndent -= 3;
    for (my $i = 0; $i < $Globals::functionIndent; ++$i) {
        print STDERR " ";
    }
    print STDERR "$function: - exit\n" if ($Globals::trace);
}

1;
#####################################################
#####################################################
#####################################################
#####################################################
#####################################################
#####################################################
#####################################################
#####################################################
#####################################################
#####################################################
#####################################################
#####################################################
#####################################################
package DocumentType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class) = @_;
   my $self = $class->SUPER::new($class, undef);
   $self->{_applicationSet} = undef;
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'applicationSet') {
        $elem = applicationSetType->new($el);
        $self->{_applicationSet} = $elem;
    } elsif ($element eq 'application') {
        my $appSet = applicationSetType->new(undef);
        $appSet->{'xmlns'} = "http://www.ibm.com/xmlns/prod/streams/application";
        $appSet->{'name'} = "Main.appset";
        $appSet->{'xmlns:tt'} = "http://www.ibm.com/xmlns/prod/streams/spl/tupleType";
        $appSet->{'xmlns:xsi'} = "http://www.w3.org/2001/XMLSchema-instance";
        $appSet->{'xmlns:physical'} = "http://www.ibm.com/xmlns/prod/streams/application/physical";
        $appSet->{'productVersion'} = "3.2.0.0";
        $self->{'_applicationSet'} = $appSet;
        $elem = applicationType->new($el);
        $self->{_applicationSet}->{_application} = $elem;
    } else {
        die("unsupported type: $element");
    }
    return $elem;
}

sub  end_element
{
   my ($self, $el) = @_;
}

sub getApplicationSet
{
    my ($self) = @_;
    return $self->{_applicationSet};
}

sub genADL
{
    my ($self) = @_;
    $self->{_applicationSet}->gen(0);
}

1;
#####################################################
package applicationSetType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_description} = undef;
   $self->{_application} = undef;
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'description') {
        $elem = descriptionType->new($el);
        $self->{_description} = $elem;
    } elsif ($element eq 'application') {
        $elem = applicationType->new($el);
        $self->{_application} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<applicationSet");
   $self->printAttributes();
   $self->print(0, ">\n");
   $indent += 3;
   $self->{_description}->gen($indent) if (defined($self->{_description}));
   $self->{_application}->gen($indent);
   $indent -= 3;
   $self->print($indent, "</applicationSet>\n");
}

sub getApplication
{
    my ($self) = @_;
    return $self->{_application};
}

1;

#####################################################
package applicationType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_libraries} = undef;
   $self->{_hostpools} = undef;
   $self->{_tupleTypes} = undef;
   $self->{_pes} = undef;
   $self->{_operDefinitions} = undef;
   $self->{_composites} = undef;
   $self->{_toolkits} = undef;
   $self->{_customMetrics} = undef;
   $self->{_parallelRegions} = undef;
   $self->{_submissionTimeValues} = undef;
   $self->{_submissionTimeConfiguration} = undef;
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'libraries') {
        $elem = librariesType->new($el);
        $self->{_libraries} = $elem;
    } elsif ($element eq 'hostpools') {
        $elem = hostpoolsType->new($el);
        $self->{_hostpools} = $elem;
    } elsif ($element eq 'tupleTypes') {
        $elem = tupleTypesType->new($el);
        $self->{_tupleTypes} = $elem;
    } elsif ($element eq 'pes') {
        $elem = pesType->new($el);
        $self->{_pes} = $elem;
    } elsif ($element eq 'operDefinitions') {
        $elem = operDefinitionsType->new($el);
        $self->{_operDefinitions} = $elem;
    } elsif ($element eq 'composites') {
        $elem = compositesType->new($el);
        $self->{_composites} = $elem;
    } elsif ($element eq 'toolkits') {
        $elem = toolkitsType->new($el);
        $self->{_toolkits} = $elem;
    } elsif ($element eq 'customMetrics') {
        $elem = customMetricsType->new($el);
        $self->{_customMetrics} = $elem;
    } elsif ($element eq 'parallelRegions') {
        $elem = parallelRegionsType->new($el);
        $self->{_parallelRegions} = $elem;
    } elsif ($element eq 'submissionTimeValues') {
        $elem = submissionTimeValuesType->new($el);
        $self->{_submissionTimeValues} = $elem;
    } elsif ($element eq 'submissionTimeConfiguration') {
        $elem = submissionTimeConfigurationType->new($el);
        $self->{_submissionTimeConfiguration} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<application");
   $self->printAttributes();
   $self->print(0, ">\n");
   $indent += 3;
   $self->{_libraries}->gen($indent)                    if (defined($self->{_libraries}));
   $self->{_hostpools}->gen($indent)                    if (defined($self->{_hostpools}));
   $self->{_tupleTypes}->gen($indent)                   if (defined($self->{_tupleTypes}));
   $self->{_pes}->gen($indent)                          if (defined($self->{_pes}));
   $self->{_operDefinitions}->gen($indent)              if (defined($self->{_operDefinitions}));
   $self->{_composites}->gen($indent)                   if (defined($self->{_composites}));
   $self->{_toolkits}->gen($indent)                     if (defined($self->{_toolkits}));
   $self->{_customMetrics}->gen($indent)                if (defined($self->{_customMetrics}));
   $self->{_parallelRegions}->gen($indent)              if (defined($self->{_parallelRegions}));
   $self->{_submissionTimeValues}->gen($indent)         if (defined($self->{_submissionTimeValues}));
   $self->{_submissionTimeConfiguration}->gen($indent)  if (defined($self->{_submissionTimeConfiguration}));
   $indent -= 3;
   $self->print($indent, "</application>\n");
}

sub genPhysicalADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<application");
   $self->printAttributes();
   $self->print(0, " xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"") unless defined($self->{'xmlns:xs'});
   $self->print(0, " xmlns=\"http://www.ibm.com/xmlns/prod/streams/application\"") unless defined($self->{'xmlns'});
   $self->print(0, " xmlns:tt=\"http://www.ibm.com/xmlns/prod/streams/spl/tupleType\"") unless defined($self->{'xmlns:tt'});
   $self->print(0, " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"") unless defined($self->{'xmlns:xsi'});
   $self->print(0, " xmlns:physical=\"http://www.ibm.com/xmlns/prod/streams/application/physical\"");
   $self->print(0, ">\n");
   $indent += 3;
   $self->{_libraries}->gen($indent)                    if (defined($self->{_libraries}));
   $self->{_hostpools}->gen($indent)                    if (defined($self->{_hostpools}));
   $self->{_tupleTypes}->gen($indent)                   if (defined($self->{_tupleTypes}));
   $self->{_pes}->gen($indent)                          if (defined($self->{_pes}));
   $self->{_operDefinitions}->gen($indent)              if (defined($self->{_operDefinitions}));
   $self->{_composites}->gen($indent)                   if (defined($self->{_composites}));
   $self->{_toolkits}->gen($indent)                     if (defined($self->{_toolkits}));
   $self->{_customMetrics}->gen($indent)                if (defined($self->{_customMetrics}));
   $self->{_parallelRegions}->gen($indent)              if (defined($self->{_parallelRegions}));
   $self->{_submissionTimeValues}->gen($indent)         if (defined($self->{_submissionTimeValues}));
   $self->{_submissionTimeConfiguration}->gen($indent)  if (defined($self->{_submissionTimeConfiguration}));
   $indent -= 3;
   $self->print($indent, "</application>\n");
}

1;
#####################################################
package submissionTimeConfigurationType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    bless $self, $class;
    $self->{_submissionTimeConfigParm} = [];
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'submissionTimeConfigParm') {
        $elem = submissionTimeConfigurationParameterType->new($el);
        push(@{$self->{_submissionTimeConfigParm}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<submissionTimeConfiguration>\n");
    $indent += 3;
    foreach my $param (@{$self->{_submissionTimeConfigParm}}) {
        $param->gen($indent);
    }
    $indent -= 3;
    $self->print($indent, "</submissionTimeConfiguration>\n");
}
1;
#####################################################
package submissionTimeConfigurationParameterType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    bless $self, $class;
    return $self;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->genAttributeOnlyElement($indent, "submissionTimeConfigParm");
}

1;
#####################################################
package librariesType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_library} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'library') {
        $elem = libraryType->new($el);
        push(@{$self->{_library}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<libraries");
   if (scalar @{$self->{_library}} > 0) {
      $self->print(0, ">\n");
      $indent += 3;
      foreach my $library (@{$self->{_library}}) {
          $library->gen($indent);
      }
      $indent -= 3;
      $self->print($indent, "</libraries>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package hostpoolsType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_hostpool} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'hostpool') {
        $elem = hostpoolType->new($el);
        push(@{$self->{_hostpool}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<hostpools>\n");
   $indent += 3;
   foreach my $hostPool (@{$self->{_hostpool}}) {
      $hostPool->gen($indent);
   }
   $indent -= 3;
   $self->print($indent, "</hostpools>\n");
}

1;
#####################################################
package hostpoolType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_host} = [];
   $self->{_tag} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'host') {
        $elem = hostType->new($el);
        push(@{$self->{_host}}, $elem);
    } elsif ($element eq 'tag') {
        $elem = tagType->new($el);
        push(@{$self->{_tag}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<hostpool");
   $self->printAttributes();
   if (scalar @{$self->{_host}} == 0 && scalar @{$self->{_tag}} == 0) {
       $self->print(0, "/>\n");
   } else {
       $self->print(0, ">\n");
       $indent += 3;
       foreach my $host (@{$self->{_host}}) {
           $host->gen($indent);
       }
       foreach my $tag (@{$self->{_tag}}) {
           $tag->gen($indent);
       }
       $indent -= 3;
       $self->print($indent, "</hostpool>\n");
   }
}

1;
#####################################################
package hostType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
    die("Unexpected");
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->genAttributeOnlyElement($indent, "host");
}

1;
#####################################################
package displayType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
    die("Unexpected");
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->genAttributeOnlyElement($indent, "display");
}

1;
#####################################################
package profilingType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
    die("Unexpected");
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->genAttributeOnlyElement($indent, "profiling");
}

1;
#####################################################
package checkpointingType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
    die("Unexpected");
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->genAttributeOnlyElement($indent, "checkpointing");
}

1;
#####################################################
package threadedPortType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub create
{
   my ($class) = @_;
   my $self = {};
   $self->{congestionPolicy} = "wait";
   $self->{singleThreadedOnInput} = "true";
   bless $self, $class;
   return $self;
}


sub start_element
{
    die("Unexpected");
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->genAttributeOnlyElement($indent, "threadedPort");
}

1;
#####################################################
package tagType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
    die("Unexpected");
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->genAttributeOnlyElement($indent, "tag");
}

1;
#####################################################
package hostLocationType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
    die("Unexpected");
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->genAttributeOnlyElement($indent, "hostLocation");
}

1;
#####################################################
package exLocationType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
    die("Unexpected");
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->genAttributeOnlyElement($indent, "exLocation");
}

1;
#####################################################
package coLocationType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
    die("Unexpected");
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->genAttributeOnlyElement($indent, "coLocation");
}

1;
#####################################################
package tupleTypesType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_tupleType} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'tupleType') {
        $elem = tupleTypeType->new($el);
        push(@{$self->{_tupleType}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<tupleTypes>\n");
   $indent += 3;
   foreach my $tupleType (@{$self->{_tupleType}}) {
      $tupleType->gen($indent);
   }
   $indent -= 3;
   $self->print($indent, "</tupleTypes>\n");
}

1;
#####################################################
package tupleTypeType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_attribute} = [];
   $self->{_tuple} = undef;
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'attribute') {
        $elem = attributeType->new($el);
        push(@{$self->{_attribute}}, $elem);
    } elsif ($element eq 'tuple') {
        $elem = tupleType->new($element, $el);
        $self->{_tuple} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<tupleType");
   $self->printAttributes();
   $self->print(0, ">\n");
   $indent += 3;
   foreach my $attribute (@{$self->{_attribute}}) {
      $attribute->gen($indent);
   }
   $self->{_tuple}->gen($indent) if (defined($self->{_tuple}));
   $indent -= 3;
   $self->print($indent, "</tupleType>\n");
}

1;
#####################################################
package attributeType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
   die('not expected');
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<attribute");
   $self->printAttributes();
   $self->print(0, "/>\n");
}

1;
#####################################################
package tupleType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $name, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_name} = $name;
   $self->{_attr} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'attr' || $element eq 'tt:attr') {
        $elem = attrType->new($el);
        push(@{$self->{_attr}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<$self->{_name}>\n");
   $indent += 3;
   foreach my $attr (@{$self->{_attr}}) {
      $attr->gen($indent);
   }
   $indent -= 3;
   $self->print($indent, "</$self->{_name}>\n");
}

1;
#####################################################
package attrType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_collectionType} = undef;
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'list' || $element eq 'tt:list') {
        $elem = listOrSetType->new($element, $el);
        die("Internal error") if defined($self->{_collectionType});
        $self->{_collectionType} = $elem;
    } elsif ($element eq 'set' || $element eq 'tt:set') {
        $elem = listOrSetType->new($element, $el);
        die("Internal error") if defined($self->{_collectionType});
        $self->{_collectionType} = $elem;
    } elsif ($element eq 'map' || $element eq 'tt:map') {
        $elem = mapType->new($el);
        die("Internal error") if defined($self->{_collectionType});
        $self->{_collectionType} = $elem;
    } elsif ($element eq 'tuple' || $element eq 'tt:tuple') {
        $elem = tupleType->new("tt:tuple", $el);
        die("Internal error") if defined($self->{_collectionType});
        $self->{_collectionType} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<tt:attr");
    $self->printAttributes();
    if (defined($self->{_collectionType})) {
        $self->print(0, ">\n");
        $indent += 3;
        $self->{_collectionType}->gen($indent);
        $indent -= 3;
        $self->print($indent, "</tt:attr>\n");
    } else {
        $self->print(0, "/>\n");
    }
}

1;
#####################################################
package typeType;
use strict;
our @ISA = qw(Node);

sub new
{
    my ($class, $type, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_type} = $type;
    $self->{_collectionType} = undef;
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'list' || $element eq 'tt:list') {
        $elem = listOrSetType->new($element, $el);
        die("Internal error") if defined($self->{_collectionType});
        $self->{_collectionType} = $elem;
    } elsif ($element eq 'set' || $element eq 'tt:set') {
        $elem = listOrSetType->new($element, $el);
        die("Internal error") if defined($self->{_collectionType});
        $self->{_collectionType} = $elem;
    } elsif ($element eq 'map' || $element eq 'tt:map') {
        $elem = mapType->new($el);
        die("Internal error") if defined($self->{_collectionType});
        $self->{_collectionType} = $elem;
    } elsif ($element eq 'tuple' || $element eq 'tt:tuple') {
        $elem = tupleType->new("tt:tuple", $el);
        die("Internal error") if defined($self->{_collectionType});
        $self->{_collectionType} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<tt:$self->{_type}>\n");
    $indent += 3;
    $self->{_collectionType}->gen($indent);
    $indent -= 3;
    $self->print($indent, "</tt:$self->{_type}>\n");
}

1;
#####################################################
package mapType;
use strict;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_key} = undef;
    $self->{_value} = undef;
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'key' || $element eq 'tt:key') {
        $elem = typeType->new($element, $el);
        $self->{_key} = $elem;
    } elsif ($element eq 'value' || $element eq 'tt:value') {
        $elem = typeType->new($element, $el);
        $self->{_value} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<tt:map");
    $self->printAttributes();
    if (defined($self->{_key} || defined($self->{_value}))) {
        $self->print(0, ">\n");
        $indent += 3;
        if (defined($self->{_key})) {
            $self->{_key}->gen($indent);
        }
        if (defined($self->{_value})) {
            $self->{_value}->gen($indent);
        }
        $indent -= 3;
        $self->print($indent, "</tt:map>\n");
    } else {
        $self->print(0, "/>\n");
    }
}

1;
#####################################################
package listOrSetType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $type, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_type} = $type;
    $self->{_collectionType} = undef;
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'list' || $element eq 'tt:list') {
        $elem = listOrSetType->new($element, $el);
        die("Internal error") if defined($self->{_collectionType});
        $self->{_collectionType} = $elem;
    } elsif ($element eq 'set' || $element eq 'tt:set') {
        $elem = listOrSetType->new($element, $el);
        die("Internal error") if defined($self->{_collectionType});
        $self->{_collectionType} = $elem;
    } elsif ($element eq 'map' || $element eq 'tt:map') {
        $elem = mapType->new($el);
        die("Internal error") if defined($self->{_collectionType});
        $self->{_collectionType} = $elem;
    } elsif ($element eq 'tuple' || $element eq 'tt:tuple') {
        $elem = tupleType->new("tt:tuple", $el);
        die("Internal error") if defined($self->{_collectionType});
        $self->{_collectionType} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<tt:$self->{_type}");
    $self->printAttributes();
    if (defined($self->{_collectionType})) {
        $self->print(0, ">\n");
        $indent += 3;
        $self->{_collectionType}->gen($indent);
        $indent -= 3;
        $self->print($indent, "</tt:$self->{_type}>\n");
    } else {
        $self->print(0, "/>\n");
    }
}

1;
#####################################################
package pesType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_pe} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'pe') {
        $elem = peType->new($el);
        push(@{$self->{_pe}}, $elem);
        $Globals::currentPE = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub end_element
{
    $Globals::currentPE = undef;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<pes>\n");
   $indent += 3;
   foreach my $pe (@{$self->{_pe}}) {
      $pe->gen($indent);
   }
   $indent -= 3;
   $self->print($indent, "</pes>\n");
}

sub genPhysicalADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<pes>\n");
    $indent += 3;
    foreach my $pe (@Globals::physicalPEs) {
        $pe->genPhysicalADL($indent);
    }
    $indent -= 3;
    $self->print($indent, "</pes>\n");
}

1;
#####################################################
package envVarsType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_envVar} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'envVar') {
        $elem = envVarType->new($el);
        push(@{$self->{_envVar}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<envVars");
   if (scalar @{$self->{_envVar}} > 0) {
      $self->print(0, ">\n");
      $indent += 3;
      foreach my $envVar (@{$self->{_envVar}}) {
          $envVar->gen($indent);
      }
      $indent -= 3;
      $self->print($indent, "</envVars>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package envVarType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
   die('not expected');
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<envVar");
   $self->printAttributes();
   $self->print(0, "/>\n");
}

1;
#####################################################
package peType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);

    $self->{_envVars} = undef;
    $self->{_executable} = undef;
    $self->{_operInstances} = undef;
    $self->{_display} = undef;
    $self->{_tracing} = undef;
    $self->{_inputPorts} = undef;
    $self->{_outputPorts} = undef;
    bless $self, $class;
    return $self;
}

sub class
{
    my ($self) = @_;
    return $self->{class};
}

sub index
{
    my ($self) = @_;
    return $self->{index};
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'envVars') {
        $elem = envVarsType->new($el);
        $self->{_envVars} = $elem;
    } elsif ($element eq 'executable') {
        $elem = executableType->new($el);
        $self->{_executable} = $elem;
    } elsif ($element eq 'operInstances') {
        $elem = operInstancesType->new($el);
        $self->{_operInstances} = $elem;
    } elsif ($element eq 'display') {
        $elem = displayType->new($el);
        $self->{_display} = $elem;
    } elsif ($element eq 'tracing') {
        $elem = tracingType->new($el);
        $self->{_tracing} = $elem;
    } elsif ($element eq 'inputPorts') {
        $elem = peInputPortsType->new($el);
        $self->{_inputPorts} = $elem;
    } elsif ($element eq 'outputPorts') {
        $elem = peOutputPortsType->new($el);
        $self->{_outputPorts} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub end_element
{
    my ($self, $el) = @_;
    my $physicalPE = PhysicalPE->new($self);
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<pe");
    $self->printAttributes();
    $self->print(0, ">\n");
    $indent += 3;
    $self->{_envVars}->gen($indent)       if (defined($self->{_envVars}));
    $self->{_executable}->gen($indent)    if (defined($self->{_executable}));
    $self->{_operInstances}->gen($indent) if (defined($self->{_operInstances}));
    $self->{_display}->gen($indent)       if (defined($self->{_display}));
    $self->{_tracing}->gen($indent)       if (defined($self->{_tracing}));
    $self->{_inputPorts}->gen($indent)    if (defined($self->{_inputPorts}));
    $self->{_outputPorts}->gen($indent)   if (defined($self->{_outputPorts}));
    $indent -= 3;
    $self->print($indent, "</pe>\n");
}

sub genPhysicalADL
{
    die("Internal error");
}

1;
#####################################################
package peOutputPortsType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_outputPort} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'outputPort') {
        $elem = peOutputPortType->new($el);
        push(@{$self->{_outputPort}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<outputPorts");
   if (scalar @{$self->{_outputPort}} > 0) {
      $self->print(0, ">\n");
      $indent += 3;
      foreach my $outputPort (@{$self->{_outputPort}}) {
          $outputPort->gen($indent);
      }
      $indent -= 3;
      $self->print($indent, "</outputPorts>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package peOutputPortType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_exportedStream} = undef;
    $self->{_staticConnections} = undef;
    $self->{_operInstanceConnection} = undef;
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'exportedStream') {
        $elem = exportedStreamType->new($el);
        $self->{_exportedStream} = $elem;
    } elsif ($element eq 'staticConnections') {
        $elem = outgoingStaticConnectionsType->new($el);
        $self->{_staticConnections} = $elem;
    } elsif ($element eq 'operInstanceConnection') {
        $elem = operInstancePEOutputConnectionType->new($el);
        $self->{_operInstanceConnection} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub end_element
{
    my ($self, $el) = @_;
    my $operInstanceIndex = $self->{_operInstanceConnection}->{operInstanceIndex};
    my $portIndex = $self->{_operInstanceConnection}->{oportIndex};
    my $oper = $Globals::operInstances{$operInstanceIndex};
    $oper->setOutputPortAttributes($portIndex, $self->{transport}, $self->{encoding}, $self->{singleThreadedOnOutput});
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<outputPort");
   $self->printAttributes();
   $self->print(0, ">\n");
   $indent += 3;
   $self->{_exportedStream}->gen($indent)  if (defined($self->{_exportedStream}));
   $self->{_staticConnections}->gen($indent)  if (defined($self->{_staticConnections}));
   $self->{_operInstanceConnection}->gen($indent)  if (defined($self->{_operInstanceConnection}));
   $indent -= 3;
   $self->print($indent, "</outputPort>\n");
}

1;
#####################################################
package streamPropertiesType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    bless $self, $class;
    $self->{_property} = [];
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'property') {
        $elem = streamPropertyType->new($el);
        push(@{$self->{_property}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<properties>\n");
    $indent += 3;
    foreach my $property (@{$self->{_property}}) {
        $property->gen($indent);
    }
    $indent -= 3;
    $self->print($indent, "</properties>\n");
}
1;
#####################################################
package exportedStreamType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    bless $self, $class;
    $self->{_properties} = undef;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'properties') {
        $elem = streamPropertiesType->new($el);
        die("Internal error") if defined($self->{_properties});
        $self->{_properties} = $elem;
    } else {
        die('unsupported type');
    }
}

sub end_element
{
    my ($self, $el) = @_;
    my $operName = $self->{exportOperName};
    $Globals::exportOperatorInfoMap{$operName} = $self;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<exportedStream");
    $self->printAttributes();
    if (defined($self->{_properties})) {
        $self->print(0, ">\n");
        $indent += 3;
        $self->{_properties}->gen($indent);
        $indent -= 3;
        $self->print($indent, "</exportedStream>\n");
    } else {
        $self->print(0, "/>\n");
    }
}

1;
#####################################################
package streamPropertyType;
use strict;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_values} = [];
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'value') {
        $elem = valueValueType->new($el);
        push(@{$self->{_values}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<property");
    $self->printAttributes();
    $self->print(0, ">\n");
    $indent += 3;
    foreach my $value (@{$self->{_values}}) {
       $value->gen($indent);
    }
    $indent -= 3;
    $self->print($indent, "</property>\n");
}

1;
#####################################################
package executableType;
use strict;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_wrapper} = undef;
    $self->{_executableUri} = undef;
    $self->{_arguments} = undef;
    $self->{_dependencies} = undef;
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'wrapper') {
        $elem = wrapperType->new($el);
        $self->{_wrapper} = $elem;
    } elsif ($element eq 'executableUri') {
        $elem = executableUriType->new($el);
        $self->{_executableUri} = $elem;
    } elsif ($element eq 'arguments') {
        $elem = argumentsType->new($el);
        $self->{_arguments} = $elem;
    } elsif ($element eq 'dependencies') {
        $elem = dependenciesType->new($el);
        $self->{_dependencies} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<executable");
    $self->printAttributes();
    $self->print(0, ">\n");
    $indent += 3;
    $self->{_wrapper}->gen($indent)  if (defined($self->{_wrapper}));
    $self->{_executableUri}->gen($indent)  if (defined($self->{_executableUri}));
    $self->{_arguments}->gen($indent)  if (defined($self->{_arguments}));
    $self->{_dependencies}->gen($indent)  if (defined($self->{_dependencies}));
    $indent -= 3;
    $self->print($indent, "</executable>\n");
}

1;
#####################################################
package valueType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_value} = '';
   bless $self, $class;
   return $self;
}

sub chars
{
    my ($self, $param) = @_;
    $self->{_value} = $param->{'Data'};
}
1;
#####################################################
package descriptionType;
use strict;
use Data::Dumper;
our @ISA = qw(valueType);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($el);
   bless $self, $class;
   return $self;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<description>");
   $self->print(0, $self->{_value});
   $self->print(0, "</description>\n");
}

1;
#####################################################
package constantWidthType;
use strict;
use Data::Dumper;
our @ISA = qw(valueType);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($el);
   bless $self, $class;
   return $self;
}

sub width
{
    my ($self) = @_;
    return $self->{_value};
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<constantWidth>");
   $self->print(0, $self->{_value});
   $self->print(0, "</constantWidth>\n");
}

1;
#####################################################
package wrapperType;
use strict;
use Data::Dumper;
our @ISA = qw(valueType);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($el);
    bless $self, $class;
    return $self;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<wrapper>");
    $self->print(0, $self->{_value});
    $self->print(0, "</wrapper>\n");
}

1;
#####################################################
package executableUriType;
use strict;
use Data::Dumper;
our @ISA = qw(valueType);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($el);
    bless $self, $class;
    return $self;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<executableUri>");
    $self->print(0, $self->{_value});
    $self->print(0, "</executableUri>\n");
}

1;
#####################################################
package customMetricIndexType;
use strict;
use Data::Dumper;
our @ISA = qw(valueType);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($el);
    bless $self, $class;
    return $self;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<customMetricIndex>");
    $self->print(0, $self->{_value});
    $self->print(0, "</customMetricIndex>\n");
}

1;
#####################################################
package argumentsType;
use strict;
use Data::Dumper;
our @ISA = qw(valueType);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($el);
   bless $self, $class;
   return $self;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<arguments");
   if ($self->{_value} eq '') {
       $self->print(0, "/>\n");
   } else {
       $self->print(0, ">");
       $self->print(0, $self->{_value});
       $self->print(0, "</arguments>\n");
   }
}

1;
#####################################################
package valueValueType;
use strict;
use Data::Dumper;
our @ISA = qw(valueType);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($el);
    bless $self, $class;
    return $self;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<value");
    if ($self->{_value} eq '') {
         $self->print(0, "/>\n");
    } else {
         $self->print(0, ">");
         $self->print(0, $self->{_value});
         $self->print(0, "</value>\n");
    }
}

1;
#####################################################
package splAnnotationValueType;
use strict;
use Data::Dumper;
our @ISA = qw(valueType);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($el);
    bless $self, $class;
    return $self;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<value");
    $self->printAttributes();
    if ($self->{_value} eq '') {
         $self->print(0, "/>\n");
    } else {
         $self->print(0, ">");
         $self->print(0, $self->{_value});
         $self->print(0, "</value>\n");
    }
}

1;
#####################################################
package compositeOperInstanceIndexType;
use strict;
use Data::Dumper;
our @ISA = qw(valueType);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($el);
    bless $self, $class;
    return $self;
}

sub operatorIndex
{
    my ($self) = @_;
    return $self->{_value};
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<compositeOperInstanceIndex>");
    $self->print(0, $self->{_value});
    $self->print(0, "</compositeOperInstanceIndex>\n");
}

1;
#####################################################
package primitiveOperInstanceIndexType;
use strict;
use Data::Dumper;
our @ISA = qw(valueType);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($el);
    bless $self, $class;
    return $self;
}

sub operatorIndex
{
    my ($self) = @_;
    return $self->{_value};
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<primitiveOperInstanceIndex>");
    $self->print(0, $self->{_value});
    $self->print(0, "</primitiveOperInstanceIndex>\n");
}

1;
#####################################################
package dependenciesType;
use strict;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_dependency} = [];
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'dependency') {
        $elem = libraryDependencyType->new($el);
        push(@{$self->{_dependency}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<dependencies");
    if (scalar @{$self->{_dependency}} > 0) {
        $self->print(0, ">\n");
        $indent += 3;
        foreach my $dependency (@{$self->{_dependency}}) {
            $dependency->gen($indent);
        }
        $indent -= 3;
        $self->print($indent, "</dependencies>\n");
    } else {
        $self->print(0, "/>\n");
    }
}

1;
#####################################################
package operInstancesType;
use strict;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_operInstance} = [];
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'operInstance') {
        $elem = operInstanceType->new($el);
        push(@{$self->{_operInstance}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<operInstances>\n");
    $indent += 3;
    foreach my $operInstance (@{$self->{_operInstance}}) {
        $operInstance->gen($indent);
    }
    $indent -= 3;
    $self->print($indent, "</operInstances>\n");
}

1;
#####################################################
package operInstanceInputPortsType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_inputPort} = [];
    bless $self, $class;
    return $self;
}

sub getPort
{
    my ($self, $portIndex) = @_;
    my $port = $self->{_inputPort}[$portIndex];
    return $port;
}

sub setPortAttributes
{
    my ($self, $portIndex, $transport, $encoding) = @_;
    my $port = $self->{_inputPort}[$portIndex];
    $port->setAttributes($transport, $encoding);
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'inputPort') {
        $elem = operInstanceInputPortType->new($el);
        push(@{$self->{_inputPort}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<inputPorts");
   if (scalar @{$self->{_inputPort}} > 0) {
      $self->print(0, ">\n");
      $indent += 3;
      foreach my $inputPort (@{$self->{_inputPort}}) {
          $inputPort->gen($indent);
      }
      $indent -= 3;
      $self->print($indent, "</inputPorts>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package operInstanceInputPortType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_interPeConnection} = [];
    $self->{_intraPeConnection} = [];
    $self->{_threadedPort} = undef;
    $self->{_peConnection} = undef;
    $self->{_owningOp} = undef;
    bless $self, $class;
    return $self;
}

sub setAttributes
{
    my ($self, $transport, $encoding) = @_;
    $self->{_transport} = $transport;
    $self->{_encoding} = $encoding;
}

sub start_element
{
    my ($self, $el) = @_;
    my $elementType = $el->{'LocalName'};
    my $elem = undef;
    if ($elementType eq 'interPeConnection') {
        $elem = operInstanceIncomingConnectionType->new($el);
        push(@{$self->{_interPeConnection}}, $elem);
    } elsif ($elementType eq 'intraPeConnection') {
        $elem = operInstanceIncomingConnectionType->new($el);
        push(@{$self->{_intraPeConnection}}, $elem);
    } elsif ($elementType eq 'threadedPort') {
        $elem = threadedPortType->new($el);
        $self->{_threadedPort} = $elem;
    } else {
        $elem = $elementType->new($el);
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<inputPort");
   $self->printAttributes();
   $self->print(0, ">\n");
   $indent += 3;
   if (scalar @{$self->{_interPeConnection}} > 0) {
      foreach my $interPeConnection (@{$self->{_interPeConnection}}) {
         $self->print($indent, "<interPeConnection");
         $interPeConnection->printAttributes();
         $self->print(0, "/>\n");
      }
   }
   if (scalar @{$self->{_intraPeConnection}} > 0) {
      foreach my $intraPeConnection (@{$self->{_intraPeConnection}}) {
         $self->print($indent, "<intraPeConnection");
         $intraPeConnection->printAttributes();
         $self->print(0, "/>\n");
      }
   }
   $self->{_threadedPort}->gen($indent) if (defined($self->{_threadedPort}));
   $indent -= 3;
   $self->print($indent, "</inputPort>\n");
}

1;
#####################################################
package operInstanceIncomingConnectionType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    bless $self, $class;
    return $self;
}

sub start_element
{
   die('not expected');
}

1;
#####################################################
package incomingStaticConnectionsType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_staticConnection} = [];
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'staticConnection') {
        $elem = incomingStaticConnectionType->new($el);
        push(@{$self->{_staticConnection}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<staticConnections");
   if (scalar @{$self->{_staticConnection}} > 0) {
      $self->print(0, ">\n");
      $indent += 3;
      foreach my $staticConnection (@{$self->{_staticConnection}}) {
          $staticConnection->gen($indent);
      }
      $indent -= 3;
      $self->print($indent, "</staticConnections>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package incomingStaticConnectionType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    bless $self, $class;
    return $self;
}

sub start_element
{
   die('not expected');
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<staticConnection");
   $self->printAttributes();
   $self->print(0, "/>\n");
}

1;
#####################################################
package operInstancePEInputConnectionType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    bless $self, $class;
    return $self;
}

sub start_element
{
   die('not expected');
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<operInstanceConnection");
   $self->printAttributes();
   $self->print(0, "/>\n");
}

1;
#####################################################
package operInstanceType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_resources} = undef;
   $self->{_profiling} = undef;
   $self->{_checkpointing} = undef;
   $self->{_runtimeConstants} = undef;
   $self->{_inputPorts} = undef;
   $self->{_outputPorts} = undef;
   die("Internal error: currntPE not defined") unless defined($Globals::currentPE);
   $self->{_owningPE} = $Globals::currentPE;
   $Globals::operInstances{$self->{index}} = $self;
   bless $self, $class;
   return $self;
}

sub setInputPortAttributes
{
    my ($self, $portIndex, $transport, $encoding) = @_;
    $self->{_inputPorts}->setPortAttributes($portIndex, $transport, $encoding);
}

sub setOutputPortAttributes
{
    my ($self, $portIndex, $transport, $encoding, $singleThreadedOnOutput) = @_;
    $self->{_outputPorts}->setPortAttributes($portIndex, $transport, $encoding, $singleThreadedOnOutput);
}

sub getIPort
{
    my ($self, $portIndex) = @_;
    return $self->{_inputPorts}->getPort($portIndex);
}

sub getOPort
{
    my ($self, $portIndex) = @_;
    return $self->{_outputPorts}->getPort($portIndex);
}

sub getSplitter
{
    my ($self, $outputPortIndex, $splitterIndex) = @_;
    return $self->{_outputPorts}->getSplitter($outputPortIndex, $splitterIndex);
}

sub owningPE
{
    my ($self) = @_;
    return $self->{_owningPE};
}

sub start_element
{
    my ($self, $el) = @_;
    my $elementType = $el->{'LocalName'};
    my $elem = undef;
    if ($elementType eq 'resources') {
        $elem = resourcesType->new($el);
        $self->{_resources} = $elem;
    } elsif ($elementType eq 'profiling') {
        $elem = profilingType->new($el);
        $self->{_profiling} = $elem;
    } elsif ($elementType eq 'checkpointing') {
        $elem = checkpointingType->new($el);
        $self->{_checkpointing} = $elem;
    } elsif ($elementType eq 'runtimeConstants') {
        $elem = runtimeConstantsType->new($el);
        $self->{_runtimeConstants} = $elem;
    } elsif ($elementType eq 'inputPorts') {
        $elem = operInstanceInputPortsType->new($el);
        $self->{_inputPorts} = $elem;
    } elsif ($elementType eq 'outputPorts') {
        $elem = operInstanceOutputPortsType->new($el);
        $self->{_outputPorts} = $elem;
    } else {
        $elem = $elementType->new($el);
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<operInstance");
   $self->printAttributes();
   $self->print(0, ">\n");
   $indent += 3;
   $self->{_resources}->gen($indent)  if (defined($self->{_resources}));
   $self->{_profiling}->gen($indent)  if (defined($self->{_profiling}));
   $self->{_checkpointing}->gen($indent)  if (defined($self->{_checkpointing}));
   $self->{_runtimeConstants}->gen($indent)  if (defined($self->{_runtimeConstants}));
   $self->{_inputPorts}->gen($indent)  if (defined($self->{_inputPorts}));
   $self->{_outputPorts}->gen($indent)  if (defined($self->{_outputPorts}));
   $indent -= 3;
   $self->print($indent, "</operInstance>\n");
}

1;
#####################################################
package resourcesType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_hostLocation} = undef;
   $self->{_poolLocation} = undef;
   $self->{_coLocation} = [];
   $self->{_exLocation} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $elementType = $el->{'LocalName'};
    my $elem = undef;
    if ($elementType eq 'hostLocation') {
        $elem = hostLocationType->new($el);
        $self->{_hostLocation} = $elem;
    } elsif ($elementType eq 'poolLocation') {
        $elem = poolLocationType->new($el);
        $self->{_poolLocation} = $elem;
    } elsif ($elementType eq 'coLocation') {
        $elem = coLocationType->new($el);
        push(@{$self->{_coLocation}}, $elem);
    } elsif ($elementType eq 'exLocation') {
        $elem = exLocationType->new($el);
        push(@{$self->{_exLocation}}, $elem);
    } else {
        $elem = $elementType->new($el);
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<resources>\n");
   $indent += 3;
   $self->{_hostLocation}->gen($indent)  if (defined($self->{_hostLocation}));
   $self->{_poolLocation}->gen($indent)  if (defined($self->{_poolLocation}));
   foreach my $coLocation (@{$self->{_coLocation}}) {
      $coLocation->gen($indent);
   }
   foreach my $exLocation (@{$self->{_exLocation}}) {
      $exLocation->gen($indent);
   }
   $indent -= 3;
   $self->print($indent, "</resources>\n");
}

1;
#####################################################
package parallelWidthType;
use strict;
our @ISA = qw(Node);
use Data::Dumper;

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_width} = undef;
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'constantWidth') {
        $elem = constantWidthType->new($el);
        $self->{_width} = $elem;
    } elsif ($element eq 'submissionTimeWidth') {
        $elem = submissionTimeValueType->new($el);
        $self->{_width} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub width
{
    my ($self) = @_;
    return $self->{_width}->width();
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<parallelWidth>\n");
   $indent += 3;
   die("Internal error") unless (defined($self->{_width}));
   $self->{_width}->gen($indent);
   $indent -= 3;
   $self->print($indent, "</parallelWidth>\n");
}

1;
#####################################################
package parallelRegionSplitterType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_attributes} = undef;
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'attributes') {
        $elem = partitioningAttributesType->new($el);
        $self->{_attributes} = $elem;
    } else {
        die("unsupported type: $element");
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<splitter kind=\"$self->{kind}\" iportIndex=\"$self->{iportIndex}\">\n");
    $indent += 3;
    $self->{_attributes}->gen($indent) if defined($self->{_attributes});
    $indent -= 3;
    $self->print($indent, "</splitter>\n");
}

1;
#####################################################
package parallelOperatorType;
use strict;
our @ISA = qw(Node);
use Data::Dumper;

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_splitter} = [];
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'splitter') {
        $elem = parallelRegionSplitterType->new($el);
        push(@{$self->{_splitter}}, $elem);
    } else {
        die("unsupported type: $element");
    }
    return $elem;
}

sub getSplitter
{
    my ($self, $portIndex) = @_;
    foreach my $splitter (@{$self->{_splitter}}) {
        return $splitter if ($portIndex == $splitter->{iportIndex});
    }
    die("Internal error");  # Should never get here
}

# Return the index of the operator for this parallel region
sub operatorIndex
{
    my ($self) = @_;
    return $self->{operIndex};
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<parallelOperator operIndex=\"$self->{operIndex}\">\n");
    $indent += 3;
    foreach my $splitter (@{$self->{_splitter}}) {
        $splitter->gen($indent);
    }
    $indent -= 3;
    $self->print($indent, "</parallelOperator>\n");
}

1;
#####################################################
package parallelRegionType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_parallelOperator} = undef;
   $self->{_parallelWidth} = undef;
   bless $self, $class;
   return $self;
}

sub width
{
    my ($self) = @_;
    return $self->{_parallelWidth}->width();
}

sub getSplitter
{
    my ($self, $portIndex) = @_;
    return $self->{_parallelOperator}->getSplitter($portIndex);
}

sub operatorIndex
{
    my ($self) = @_;
    return $self->{_parallelOperator}->operatorIndex();
}

sub index
{
    my ($self) = @_;
    die("Internal error") unless defined($self->{index});
    return $self->{index};
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'parallelOperator') {
        $elem = parallelOperatorType->new($el);
        $self->{_parallelOperator} = $elem;
    } elsif ($element eq 'parallelWidth') {
        $elem = parallelWidthType->new($el);
        $self->{_parallelWidth} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<parallelRegion");
   $self->printAttributes();
   $self->print(0, ">\n");
   $indent += 3;
   $self->{_parallelOperator}->gen($indent) if (defined($self->{_parallelOperator}));
   $self->{_parallelWidth}->gen($indent) if (defined($self->{_parallelWidth}));
   $indent -= 3;
   $self->print($indent, "</parallelRegion>\n");
}

1;
#####################################################
package parallelRegionsType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_parallelRegions} = [];
    bless $self, $class;
    $Globals::parallelRegions = $self;
    return $self;
}

sub parallelRegion
{
    my ($self, $operIndex) = @_;
    foreach my $region (@{$self->{_parallelRegions}}) {
        return $region if ($region->operatorIndex() == $operIndex);
    }
    die("Internal error");  # Should not get here
}

sub isParallelRegion
{
    my ($self, $operIndex) = @_;
    foreach my $region (@{$self->{_parallelRegions}}) {
        return 1 if ($region->operatorIndex() == $operIndex);
    }
    return 0;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'parallelRegion') {
        $elem = parallelRegionType->new($el);
        push(@{$self->{_parallelRegions}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub end_element
{
    my ($self, $el) = @_;
}

sub hasParallelRegions
{
    my ($self) = @_;
    return scalar @{$self->{_parallelRegions}} != 0;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<parallelRegions>\n");
    $indent += 3;
    foreach my $parallelRegion (@{$self->{_parallelRegions}}) {
        $parallelRegion->gen($indent);
    }
    $indent -= 3;
    $self->print($indent, "</parallelRegions>\n");
}

1;
#####################################################
package customMetricType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_description} = undef;
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'description') {
        $elem = descriptionType->new($el);
        $self->{_description} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<customMetric");
    $self->printAttributes();
    $self->print(0, ">\n");
    $indent += 3;
    $self->{_description}->gen($indent);
    $indent -= 3;
    $self->print($indent, "</customMetric>\n");
}

1;
#####################################################
package customMetricsType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_customMetric} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'customMetric') {
        $elem = customMetricType->new($el);
        push(@{$self->{_customMetric}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<customMetrics>\n");
    $indent += 3;
    foreach my $customMetric (@{$self->{_customMetric}}) {
        $customMetric->gen($indent);
    }
    $indent -= 3;
    $self->print($indent, "</customMetrics>\n");
}

1;
#####################################################
package toolkitType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
   die('not expected');
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<toolkit");
   $self->printAttributes();
   $self->print(0, "/>\n");
}

1;
#####################################################
package toolkitsType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_toolkit} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'toolkit') {
        $elem = toolkitType->new($el);
        push(@{$self->{_toolkit}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<toolkits");
   if (scalar @{$self->{_toolkit}} > 0) {
      $self->print(0, ">\n");
      $indent += 3;
      foreach my $toolkit (@{$self->{_toolkit}}) {
          $toolkit->gen($indent);
      }
      $indent -= 3;
      $self->print($indent, "</toolkits>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package primitiveOperInstanceType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_description} = undef;
    $self->{_inputPorts} = undef;
    $self->{_outputPorts} = undef;
    $self->{_splAnnotation} = [];
    $self->{_owningRegion} = undef;
    $Globals::maxOperIndex = $self->{index} if ($self->{index} > $Globals::maxOperIndex);
    bless $self, $class;
    return $self;
}

sub index
{
    my ($self) = @_;
    return $self->{index};
}

sub name
{
    my ($self) = @_;
    return $self->{name};
}

sub isImport
{
    my ($self) = @_;
    return 1 if($self->{kind} eq 'spl.adapter::Import');
    return 0;
}

sub isExport
{
    my ($self) = @_;
    return 1 if($self->{kind} eq 'spl.adapter::Export');
    return 0;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'description') {
        $elem = descriptionType->new($el);
        $self->{_description} = $elem;
    } elsif ($element eq 'inputPorts') {
        $elem = primitiveOperInstancePortsType->new($el);
        $self->{_inputPorts} = $elem;
    } elsif ($element eq 'outputPorts') {
        $elem = primitiveOperInstancePortsType->new($el);
        $self->{_outputPorts} = $elem;
    } elsif ($element eq 'splAnnotation') {
        $elem = splAnnotationType->new($el);
        push(@{$self->{_splAnnotationType}}, $elem);
    } else {
        die("unsupported type $element");
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<primitiveOperInstance");
   $self->printAttributes();
   $self->print(0, ">\n");
   $indent += 3;
   $self->{_description}->gen($indent)  if (defined($self->{_description}));
   if (defined($self->{_inputPorts})) {
      $self->print($indent, "<inputPorts>\n");
      $self->{_inputPorts}->gen($indent);
      $self->print($indent, "</inputPorts>\n");
   }
   if (defined($self->{_outputPorts})) {
      $self->print($indent, "<outputPorts>\n");
      $self->{_outputPorts}->gen($indent);
      $self->print($indent, "</outputPorts>\n");
   }
   foreach my $splAnnotation (@{$self->{_splAnnotation}}) {
      $splAnnotation->gen($indent);
   }
   $indent -= 3;
   $self->print($indent, "</primitiveOperInstance>\n");
}

1;
#####################################################
package primitiveOperInstancePortsType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_port} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'port') {
        $elem = primitiveOperInstancePortType->new($el);
        push(@{$self->{_port}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

# This class is generic to input and output ports so the element is written by the owner
sub genADL
{
   my ($self, $indent) = @_;
   $indent += 3;
   foreach my $port (@{$self->{_port}}) {
      $port->gen($indent);
   }
   $indent -= 3;
}
1;
#####################################################
package primitiveOperInstancePortType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_connections} = undef;
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'connections') {
        $elem = operInstancePortConnectionsType->new($el);
        $self->{_connections} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<port");
   $self->printAttributes();
   if (defined($self->{_connections})) {
      $self->print(0, ">\n");
      $indent += 3;
      $self->print($indent, "<connections>\n");
      $indent += 3;
      $self->{_connections}->gen($indent);
      $indent -= 3;
      $self->print($indent, "</connections>\n");
      $indent -= 3;
      $self->print($indent, "</port>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package operInstancePortConnectionsType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_connection} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'connection') {
        $elem = operInstancePortConnectionType->new($el);
        push(@{$self->{_connection}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   # Containing element writes the wrapping element name
   foreach my $connection (@{$self->{_connection}}) {
      $connection->gen($indent);
   }
}

1;
#####################################################
package operInstancePortConnectionType;
use strict;
our @ISA = qw(Node);

sub new 
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
   die('not expected');
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<connection");
   $self->printAttributes();
   $self->print(0, "/>\n");
}

1;
#####################################################
package splAnnotationType;
use strict;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_value} = [];
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'value') {
        $elem = splAnnotationValueType->new($el);
        push(@{$self->{_value}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<splAnnotation");
    $self->printAttributes();
    if (scalar @{$self->{_value}} > 0) {
        $self->print(0, ">\n");
        $indent += 3;
        foreach my  $value (@{$self->{_value}}) {
            $value->gen($indent);
        }
        $indent -= 3;
        $self->print($indent, "</splAnnotation>\n");
    } else {
        $self->print(0, "/>\n");
    }
}


1;
#####################################################
package compositeOperInstanceType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_description} = undef;
    $self->{_inputPorts} = undef;
    $self->{_outputPorts} = undef;
    $self->{_compositeOperInstance} = [];
    $self->{_primitiveOperInstance} = [];
    $self->{_splAnnotation} = [];
    $self->{_owningRegion} = undef;
    $Globals::maxOperIndex = $self->{index} if ($self->{index} > $Globals::maxOperIndex);
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'description') {
        $elem = descriptionType->new($el);
        $self->{_description} = $elem;
    } elsif ($element eq 'inputPorts') {
        $elem = compositeOperInstancePortsType->new($el);
        $self->{_inputPorts} = $elem;
    } elsif ($element eq 'outputPorts') {
        $elem = compositeOperInstancePortsType->new($el);
        $self->{_outputPorts} = $elem;
    } elsif ($element eq 'compositeOperInstance') {
        $elem = compositeOperInstanceType->new($el);
        push(@{$self->{_compositeOperInstance}}, $elem);
    } elsif ($element eq 'primitiveOperInstance') {
        $elem = primitiveOperInstanceType->new($el);
        push(@{$self->{_primitiveOperInstance}}, $elem);
    } elsif ($element eq 'splAnnotation') {
        $elem = splAnnotationType->new($el);
        push(@{$self->{_splAnnotation}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub buildModel
{
    my ($self) = @_;
    my $model = ModelCompositeOperator->new($self, undef);
}

sub end_element
{
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<compositeOperInstance");
    $self->printAttributes();
    $self->print(0, ">\n");
    $indent += 3;
    $self->{_description}->gen($indent)  if (defined($self->{_description}));
    # input and output ports use a common type so we need to render the containing element here
    if (defined($self->{_inputPorts})) {
        $self->print($indent, "<inputPorts>\n");
        $indent += 3;
        $self->{_inputPorts}->gen($indent);
        $indent -= 3;
        $self->print($indent, "</inputPorts>\n");
    }
    if (defined($self->{_outputPorts})) {
        $self->print($indent, "<outputPorts>\n");
        $indent += 3;
        $self->{_outputPorts}->gen($indent);
        $indent -= 3;
        $self->print($indent, "</outputPorts>\n");
    }

    foreach my $compositeOperInstance (@{$self->{_compositeOperInstance}}) {
        $compositeOperInstance->gen($indent);
    }
    foreach my $primitiveOperInstance (@{$self->{_primitiveOperInstance}}) {
        $primitiveOperInstance->gen($indent);
    }
    foreach my $splAnnotation (@{$self->{_splAnnotation}}) {
        $splAnnotation->gen($indent);
    }
    $indent -= 3;
    $self->print($indent, "</compositeOperInstance>\n");
}

1;
#####################################################
package compositeOperInstancePortsType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_port} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'port') {
        $elem = compositeOperInstancePortType->new($el);
        push(@{$self->{_port}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    foreach my $port (@{$self->{_port}}) {
        $port->gen($indent);
    }
}

1;
#####################################################
package compositeOperInstancePortType;
use strict;
our @ISA = qw(Node);

sub new 
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_incomingConnections} = undef;
   $self->{_outgoingConnections} = undef;
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'incomingConnections') {
        $elem = operInstancePortConnectionsType->new($el);
        $self->{_incomingConnections} = $elem;
    } elsif ($element eq 'outgoingConnections') {
        $elem = operInstancePortConnectionsType->new($el);
        $self->{_outgoingConnections} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<port");
    $self->printAttributes();
    $self->print(0, ">\n");
    $indent += 3;
    if (defined($self->{_incomingConnections})) {
        $self->print($indent, "<incomingConnections>\n");
        $indent += 3;
        $self->{_incomingConnections}->gen($indent);
        $indent -= 3;
        $self->print($indent, "</incomingConnections>\n");
    }
    if (defined($self->{_outgoingConnections})) {
        $self->print($indent, "<outgoingConnections>\n");
        $indent += 3;
        $self->{_outgoingConnections}->gen($indent);
        $indent -= 3;
        $self->print($indent, "</outgoingConnections>\n");
    }
    $indent -= 3;
    $self->print($indent, "</port>\n");
}

1;
#####################################################
package compositeOperInstancesType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_compositeOperInstances} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'compositeOperInstance') {
        $elem = compositeOperInstanceType->new($el);
        push(@{$self->{_compositeOperInstances}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub end_element
{
    my ($self, $el) = @_;
    die("Internal error: Wrong number of composites") if (scalar @{$self->{_compositeOperInstances}} != 1);
    $Globals::mainComposite = $self->{_compositeOperInstances}->[0];
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<compositeOperInstances");
   if (scalar @{$self->{_compositeOperInstances}} > 0) {
      $self->print(0, ">\n");
      $indent += 3;
      foreach my $compositeOperInstance (@{$self->{_compositeOperInstances}}) {
          $compositeOperInstance->gen($indent);
      }
      $indent -= 3;
      $self->print($indent, "</compositeOperInstances>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package compositeOperType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_description} = undef;
   $self->{_splAnnotation} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'description') {
        $elem = descriptionType->new($el);
        $self->{_description} = $elem;
    } elsif ($element eq 'splAnnotation') {
        $elem = splAnnotationType->new($el);
        push(@{$self->{_splAnnotation}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<compositeOper");
   $self->printAttributes();
   $self->print(0, ">\n");
   $indent += 3;
   $self->{_description}->gen($indent)  if (defined($self->{_description}));
   foreach my $splAnnotation (@{$self->{_splAnnotation}}) {
      $splAnnotation->gen($indent);
   }
   $indent -= 3;
   $self->print($indent, "</compositeOper>\n");
}

1;
#####################################################
package compositeOpersType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_compositeOper} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'compositeOper') {
        $elem = compositeOperType->new($el);
        push(@{$self->{_compositeOper}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<compositeOpers");
   if (scalar @{$self->{_compositeOper}} > 0) {
      $self->print(0, ">\n");
      $indent += 3;
      foreach my $compositeOper (@{$self->{_compositeOper}}) {
          $compositeOper->gen($indent);
      }
      $indent -= 3;
      $self->print($indent, "</compositeOpers>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package uriType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
   die('not expected');
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<uri");
   $self->printAttributes();
   $self->print(0, "/>\n");
}

1;
#####################################################
package urisType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_uri} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'uri') {
        $elem = uriType->new($el);
        push(@{$self->{_uri}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<sourceUris");
   if (scalar @{$self->{_uri}} > 0) {
      $self->print(0, ">\n");
      $indent += 3;
      foreach my $uri (@{$self->{_uri}}) {
          $uri->gen($indent);
      }
      $indent -= 3;
      $self->print($indent, "</sourceUris>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package compositesType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_sourceUris} = undef;
   $self->{_compositeOpers} = undef;
   $self->{_compositeOperInstances} = undef;
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'sourceUris') {
        $elem = urisType->new($el);
        $self->{_sourceUris} = $elem;
    } elsif ($element eq 'compositeOpers') {
        $elem = compositeOpersType->new($el);
        $self->{_compositeOpers} = $elem;
    } elsif ($element eq 'compositeOperInstances') {
        $elem = compositeOperInstancesType->new($el);
        $self->{_compositeOperInstances} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<composites>\n");
   $indent += 3;
   $self->{_sourceUris}->gen($indent)  if (defined($self->{_sourceUris}));
   $self->{_compositeOpers}->gen($indent)  if (defined($self->{_compositeOpers}));
   $self->{_compositeOperInstances}->gen($indent)  if (defined($self->{_compositeOperInstances}));
   $indent -= 3;
   $self->print($indent, "</composites>\n");
}

1;
#####################################################
package operDefinitionType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_customMetricIndicies} = undef;
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'customMetricIndicies') {
        $elem = customMetricIndiciesType->new($el);
        $self->{_customMetricIndicies} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<operDefinition");
   $self->printAttributes();
   if (defined($self->{_customMetricIndicies})) {
      $self->print(0, ">\n");
      $indent += 3;
      $self->{_customMetricIndicies}->gen($indent);
      $indent -= 3;
      $self->print($indent, "</operDefinition>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package customMetricIndiciesType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_customMetricIndex} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'customMetricIndex') {
        $elem = customMetricIndexType->new($el);
        push(@{$self->{_customMetricIndex}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<customMetricIndicies>\n");
    $indent += 3;
    foreach my $customMetricIndex (@{$self->{_customMetricIndex}}) {
        $customMetricIndex->gen($indent);
    }
    $indent -= 3;
    $self->print($indent, "</customMetricIndicies>\n");
}

1;
#####################################################
package operDefinitionsType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_operDefinition} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'operDefinition') {
        $elem = operDefinitionType->new($el);
        push(@{$self->{_operDefinition}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<operDefinitions");
   if (scalar @{$self->{_operDefinition}} > 0) {
      $self->print(0, ">\n");
      $indent += 3;
      foreach my $operDefinition (@{$self->{_operDefinition}}) {
          $operDefinition->gen($indent);
      }
      $indent -= 3;
      $self->print($indent, "</operDefinitions>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package parallelChannelType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_staticConnection} = [];
   $self->{_intraPeConnection} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'staticConnection') {
        $elem = outgoingStaticConnectionType->new($el);
        push(@{$self->{_staticConnection}}, $elem);
    } elsif ($element eq 'intraPeConnection') {
        $elem = operInstanceOutgoingConnectionType->new($el);
        push(@{$self->{_intraPeConnection}}, $elem);
    } elsif ($element eq 'interPeConnection') {
        $elem = operInstanceOutgoingConnectionType->new($el);
        push(@{$self->{_intraPeConnection}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<parallelChannel>\n");
    $indent += 3;
    foreach my $staticConnection (@{$self->{_staticConnection}}) {
        $staticConnection->gen($indent);
    }
    foreach my $intraPeConnection (@{$self->{_intraPeConnection}}) {
      $self->print($indent, "<intraPeConnection");
      $intraPeConnection->printAttributes();
      $self->print(0, "/>\n");
    }
    $indent -= 3;
    $self->print($indent, "</parallelChannel>\n");
}
1;
#####################################################
package splitterType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_parallelChannel} = [];
    $self->{_attributes} = undef;
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'attributes') {
        $elem = partitioningAttributesType->new($el);
        $self->{_attributes} = $elem;
    } else {
        die("unsupported type: $element");
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<splitter");
   $self->printAttributes();
   $self->print(0, ">\n");
   $indent += 3;
   foreach my $parallelChannel (@{$self->{_parallelChannel}}) {
      $parallelChannel->gen($indent);
   }
   $self->{_attributes}->gen($indent)  if (defined($self->{_attributes}));
   $indent -= 3;
   $self->print($indent, "</splitter>\n");
}

1;
#####################################################
package partitioningAttributesType;
use strict;
our @ISA = qw(Node);
use Data::Dumper;

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_attribute} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'attribute') {
        $elem = partitioningAttributeType->new($el);
        push(@{$self->{_attribute}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<attributes>\n");
    $indent += 3;
    foreach my $attr (@{$self->{_attribute}}) {
        $attr->gen($indent);
    }
    $indent -= 3;
    $self->print($indent, "</attributes>\n");
}

1;
#####################################################
package partitioningAttributeType;
use strict;
our @ISA = qw(Node);
use Data::Dumper;

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
   die('not expected');
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<attribute name=\"$self->{name}\"/>\n");
}

1;
#####################################################
package peInputPortType;
use strict;
use Data::Dumper;
use Carp('longmess');
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_importedStreams} = undef;
    $self->{_staticConnections} = undef;
    $self->{_operInstanceConnection} = undef;
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'importedStreams') {
        $elem = importedStreamsType->new($el);
        $self->{_importedStreams} = $elem;
    } elsif ($element eq 'staticConnections') {
        $elem = incomingStaticConnectionsType->new($el);
        $self->{_staticConnections} = $elem;
    } elsif ($element eq 'operInstanceConnection') {
        $elem = operInstancePEInputConnectionType->new($el);
        $self->{_operInstanceConnection} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub end_element
{
    my ($self, $el) = @_;
    my $operInstanceIndex = $self->{_operInstanceConnection}->{operInstanceIndex};
    my $iportIndex = $self->{_operInstanceConnection}->{iportIndex};
    my $oper = $Globals::operInstances{$operInstanceIndex};
    $oper->setInputPortAttributes($iportIndex, $self->{transport}, $self->{encoding}); 
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<inputPort");
   $self->printAttributes();
   $self->print(0, ">\n");
   $indent += 3;
   $self->{_importedStreams}->gen($indent)  if (defined($self->{_importedStreams}));
   $self->{_staticConnections}->gen($indent)  if (defined($self->{_staticConnections}));
   $self->{_operInstanceConnection}->gen($indent)  if (defined($self->{_operInstanceConnection}));
   $indent -= 3;
   $self->print($indent, "</inputPort>\n");
}

1;
#####################################################
package importedStreamsType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    bless $self, $class;
    $self->{_nameBasedImport} = [];
    $self->{_propertyBasedImport} = undef;
    return $self;
}

sub  start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'nameBasedImport') {
        $elem = nameBasedImportType->new($el);
        push(@{$self->{_nameBasedImport}}, $elem);
    } elsif ($element eq 'propertyBasedImport') {
        $elem = propertyBasedImportType->new($el);
        $self->{_propertyBasedImport} = $elem;
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub end_element
{
    my ($self, $el) = @_;
    foreach my $nameBasedImport (@{$self->{_nameBasedImport}}) {
        $nameBasedImport->{filter} = $self->{filter} if defined($self->{filter});
        my $operName = $nameBasedImport->{importOperName};
        $Globals::importOperatorInfoMap{$operName} = $nameBasedImport;
    }
    if (defined($self->{_propertyBasedImport})) {
        my $operName = $self->{_propertyBasedImport}->{importOperName};
        $self->{_propertyBasedImport}->{filter} = $self->{filter} if defined($self->{filter});
        $Globals::importOperatorInfoMap{$operName} = $self->{_propertyBasedImport};
    }
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<importedStreams");
    $self->printAttributes();
    $self->print(0, ">\n");
    $indent += 3;
    foreach my $nameBasedImport (@{$self->{_nameBasedImport}}) {
        $nameBasedImport->gen($indent);
    }
    $self->{_propertyBasedImport}->gen($indent) if defined($self->{_propertyBasedImport});
    $indent -= 3;
    $self->print($indent, "</importedStreams>\n");
}

1;
#####################################################
package propertyBasedImportType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub  start_element
{
    die("Not expected");
}

sub genPhysicalADL
{
die;
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<propertyBasedImport");
    $self->printAttributes();
    $self->print(0, "/>\n");
}
1;
#####################################################
package nameBasedImportType;
use strict;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    bless $self, $class;
    return $self;
}

sub  start_element
{
    die("Not expected");
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<nameBasedImport");
    $self->printAttributes();
    $self->print(0, "/>\n");
}

1;
#####################################################
package operInstanceConnection;
use strict;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    bless $self, $class;
    my $outputPort = $self->parent();
    $outputPort->setOperator($self->{_operInstanceIndex});
    return $self;
}

1;
#####################################################
package outgoingStaticConnectionType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
   die('not expected');
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<staticConnection");
    $self->printAttributes();
    $self->print(0, "/>\n");
}

1;
#####################################################
package outgoingStaticConnectionsType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_staticConnection} = [];
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'staticConnection') {
        $elem = outgoingStaticConnectionType->new($el);
        push(@{$self->{_staticConnection}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<staticConnections");
   if (scalar @{$self->{_staticConnection}} > 0) {
      $self->print(0, ">\n");
      $indent += 3;
      foreach my $staticConnection (@{$self->{_staticConnection}}) {
          $staticConnection->gen($indent);
      }
      $indent -= 3;
      $self->print($indent, "</staticConnections>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package tracingType;
use strict;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    bless $self, $class;
    return $self;
}

sub start_element
{
    die('not expected');
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<tracing");
    $self->printAttributes();
    $self->print(0, "/>\n");
}

1;
#####################################################
package interPeConnection;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

1;
#####################################################
package intraPeConnection;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    bless $self, $class;
    return $self;
}

1;
#####################################################
package operInstanceOutputPortType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_interPeConnection} = [];
    $self->{_intraPeConnection} = [];
    $self->{_splitter} = [];
    $self->{_peConnection} = undef;
    $self->{_owningOp} = undef;
    bless $self, $class;
    return $self;
}

sub setAttributes
{
    my ($self, $transport, $encoding, $singleThreadedOnOutput) = @_;
    $self->{_transport} = $transport;
    $self->{_encoding} = $encoding;
    $self->{_singleThreadedOnOutput} = $singleThreadedOnOutput;
}

sub getSplitter
{
    my ($self, $splitterIndex) = @_;
    return $self->{_splitter}->[$splitterIndex];
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'interPeConnection') {
        $elem = operInstanceOutgoingConnectionType->new($el);
        push(@{$self->{_interPeConnection}}, $elem);
    } elsif ($element eq 'intraPeConnection') {
        $elem = operInstanceOutgoingConnectionType->new($el);
        push(@{$self->{_intraPeConnection}}, $elem);
    } elsif ($element eq 'splitter') {
        $elem = splitterType->new($el);
        push(@{$self->{_splitter}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<outputPort");
   $self->printAttributes();
   $self->print(0, ">\n");
   $indent += 3;
   foreach my $interPeConnection (@{$self->{_interPeConnection}}) {
      $self->print($indent, "<interPeConnection");
      $interPeConnection->printAttributes();
      $self->print(0, "/>\n");
   }
   foreach my $intraPeConnection (@{$self->{_intraPeConnection}}) {
      $self->print($indent, "<intraPeConnection");
      $intraPeConnection->printAttributes();
      $self->print(0, "/>\n");
   }
   foreach my $splitter (@{$self->{_splitter}}) {
       $splitter->gen($indent);
   }
   $indent -= 3;
   $self->print($indent, "</outputPort>\n");
}

1;
#####################################################
package operInstanceOutgoingConnectionType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
   die('not expected');
}

sub genADL
{
die;
}

1;
#####################################################
package operInstancePEOutputConnectionType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    bless $self, $class;
    return $self;
}

sub start_element
{
    die('not expected');
}

sub genADL
{
    my ($self, $indent) = @_;
    $self->print($indent, "<operInstanceConnection");
    $self->printAttributes();
    $self->print(0, "/>\n");
}

1;
#####################################################
package operInstanceOutputPortsType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_outputPort} = [];
   bless $self, $class;
   return $self;
}

sub setPortAttributes
{
    my ($self, $portIndex, $transport, $encoding, $singleThreadedOnOutput) = @_;
    my $port = $self->{_outputPort}[$portIndex];
    $port->setAttributes($transport, $encoding, $singleThreadedOnOutput);
}

sub getPort
{
    my ($self, $portIndex) = @_;
    my $port = $self->{_outputPort}[$portIndex];
    return $port;
}

sub getSplitter
{
    my ($self, $outputPortIndex, $splitterIndex) = @_;
    my $port = $self->{_outputPort}->[$outputPortIndex];
    die("Internal error") unless defined($port);
    return $port->getSplitter($splitterIndex);
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'outputPort') {
        $elem = operInstanceOutputPortType->new($el);
        push(@{$self->{_outputPort}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<outputPorts");
   if (scalar @{$self->{_outputPort}} > 0) {
      $self->print(0, ">\n");
      $indent += 3;
      foreach my $outputPort (@{$self->{_outputPort}}) {
          $outputPort->gen($indent);
      }
      $indent -= 3;
      $self->print($indent, "</outputPorts>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package peInputPortsType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   $self->{_inputPort} = [];
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'inputPort') {
        $elem = peInputPortType->new($el);
        push(@{$self->{_inputPort}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<inputPorts");
   if (scalar @{$self->{_inputPort}} > 0) {
      $self->print(0, ">\n");
      $indent += 3;
      foreach my $inputPort (@{$self->{_inputPort}}) {
          $inputPort->gen($indent);
      }
      $indent -= 3;
      $self->print($indent, "</inputPorts>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package runtimeConstantType;
use strict;
use Data::Dumper;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   bless $self, $class;
   return $self;
}

sub start_element
{
    die('unexpected');
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<runtimeConstant");
   $self->printAttributes();
   $self->print(0, "/>\n");
}

1;
#####################################################
package runtimeConstantsType;
use strict;
our @ISA = qw(Node);

sub new
{
   my ($class, $el) = @_;
   my $self = $class->SUPER::new($class, $el);
   $self->{_runtimeConstant} = [];
   bless $self, $class;
   return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $elementType = $el->{'LocalName'};
    my $elem = undef;
    if ($elementType eq 'runtimeConstant') {
        $elem = runtimeConstantType->new($el);
        push(@{$self->{_runtimeConstant}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<runtimeConstants");
   if (scalar @{$self->{_runtimeConstant}} > 0) {
      $self->print(0, ">\n");
      $indent += 3;
      foreach my $runtimeConstant (@{$self->{_runtimeConstant}}) {
          $runtimeConstant->gen($indent);
      }
      $indent -= 3;
      $self->print($indent, "</runtimeConstants>\n");
   } else {
      $self->print(0, "/>\n");
   }
}

1;
#####################################################
package compositeOperInstanceIndex;
use strict;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_index} = undef;
    bless $self, $class;
    my $parallelRegion = $self->parent()->parent();
    $parallelRegion->setParallelOperator($self);
    return $self;
}

sub chars
{
    my ($self, $param) = @_;
    my $data = $param->{'Data'};
    my $myElem = $Globals::elementStack[-1];
    $myElem->{_index} = $data;
}

1;
#####################################################
package submissionTimeValuesType;
use strict;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    $self->{_submissionTimeValue} = [];
    bless $self, $class;
    return $self;
}

sub start_element
{
    my ($self, $el) = @_;
    my $element = $el->{'LocalName'};
    my $elem = undef;
    if ($element eq 'submissionTimeValue') {
        $elem = submissionTimeValueType->new($el);
        push(@{$self->{_submissionTimeValue}}, $elem);
    } else {
        die('unsupported type');
    }
    return $elem;
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<submissionTimeValues>\n");
   $indent += 3;
   foreach my $submissionTimeValue (@{$self->{_submissionTimeValue}}) {
      $submissionTimeValue->gen($indent);
   }
   $indent -= 3;
   $self->print($indent, "</submissionTimeValues>\n");
}

1;
#####################################################
package submissionTimeValueType;
use strict;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    bless $self, $class;
    return $self;
}

sub start_element
{
   die('not expected');
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<submissionTimeValue");
   $self->printAttributes();
   $self->print(0, "/>\n");
}

1;
#####################################################
package poolLocationType;
use strict;
our @ISA = qw(Node);

sub new
{
    my ($class, $el) = @_;
    my $self = $class->SUPER::new($class, $el);
    bless $self, $class;
    return $self;
}

sub start_element
{
    die('unexpected');
}

sub genADL
{
   my ($self, $indent) = @_;
   $self->print($indent, "<poolLocation");
   $self->printAttributes();
   $self->print(0, "/>\n");
}

1;
#####################################################
#####################################################
#####################################################
#####################################################
#####################################################
#####################################################
package MySAXHandler;
use base qw(XML::SAX::Base);
use Data::Dumper;

sub start_document 
{
    my $doc = DocumentType->new();
    $Globals::doc = $doc;
    push(@Globals::elementStack, $doc);
}

sub end_document 
{
    pop(@Globals::elementStack);
}

sub start_element
{
    my ($self, $el) = @_;
    my $current = $Globals::elementStack[-1];
    my $element = $el->{'LocalName'};
    my $new = $current->start_element($el);
    push(@Globals::elementStack, $new);
}

sub characters
{
   my ($self, $param) = @_;
   my $current = $Globals::elementStack[-1];
   $current->chars($param);
}

sub end_element
{
    my ($self, $el) = @_;
    my $current = $Globals::elementStack[-1];
    $current->end_element($el);
    pop(@Globals::elementStack);
}
1;
##################################################################
package Main;
use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case bundling);
use XML::SAX;
use Data::Dumper;
$Data::Dumper::Maxdepth=1;
use File::Basename;
use File::Temp qw(tempdir tempfile);

sub usage($);
sub readADL($);

#****************************************************

my $help = 0;
my $inFile = '';
my $outFile = '';
my $genADL = 0;
my $genVG = 0;

binmode STDOUT, ":utf8";
# Initialization
$Globals::parallelRegions = parallelRegionsType->new(undef);

GetOptions('help|h' => \$help, 't' => \$Globals::trace, 'a' => \$genADL, 'g' => \$genVG, 'inFile|i=s' => \$inFile, 'outFile|o=s' => \$outFile, 'v' => \$Globals::verbose) or usage(1);
usage(0) if ($help);
usage(1) if ($inFile eq "");
die("$inFile doesn't exist") unless (-e $inFile);
die("-o must be specified with -g") if ($genVG == 1 && $outFile eq '');

# Read in the ADL file
readADL($inFile);

# Build a model from the composites section
die("Internal error: Main composite not found") unless defined($Globals::mainComposite);
my $model = $Globals::mainComposite->buildModel();

my $state = ParallelTransformState->new($Globals::parallelRegions);
$model->performParallelTransformations($state) if ($Globals::parallelRegions->hasParallelRegions());;

$Globals::physicalADL=1;
if ($outFile ne '') {
    open STDOUT, '>', $outFile;
}
if ($genVG) {
    print "<compositeOperInstances>\n";
    $model->genADL(3);
    print "</compositeOperInstances>\n";
} else {
    # Create physical operators (builds operator to operator connections)
    foreach my $modelOperator (@Globals::modelOperators) {
        if ($modelOperator->isPrimitive()) {
            my $physOperator = PhysicalOperator->new($modelOperator);
            print STDERR "Adding physical operator $physOperator->{_index} to the list\n" if ($Globals::verbose);
            $Globals::physicalOperators[$physOperator->index()] = $physOperator;
        }
    }

    # Assign operators to PEs
    foreach my $physicalOperator (@Globals::physicalOperators) {
        $physicalOperator->assignPE();
    }

    # Allocate PE ports
    foreach my $pe (@Globals::physicalPEs) {
        $pe->allocatePorts();
    }

    # Build PE connections
    foreach my $pe (@Globals::physicalPEs) {
        $pe->buildStaticConnections();
    }

    my $appSet = $Globals::doc->getApplicationSet();
    my $app = $appSet->getApplication();
    $app->gen(0);
}
if ($outFile ne '') {
    close STDOUT;
}

exit(0);
#****************************************************

sub readADL($)
{
   my ($file) = @_;
   my $parser = XML::SAX::ParserFactory->parser(Handler => MySAXHandler->new);
   $parser->parse_uri($file);
}

sub usage($)
{
   my ($rc) = @_;

   my $name = basename($0);
   my $text = <<EOL;
   usage: $name -h | -a -i,--inFile <ladlFile> [-o,--outFile <padlFile>]
      -h                       This help
      -a                       Gen ADL rather than PADL
      -g                       Gen dot graph file
      -t                       Trace execution
      -i, --inFile  <ladlFile> The logical ADL file to be transformed
      -o, --outFile <padlFile> The physical ADL file to be generated.  Optional.  Generation is to stdout without it.

This utility takes an input logical ADL file and transforms it to a physical ADL file
EOL
   print STDERR $text;

   exit $rc;
}

