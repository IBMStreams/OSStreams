/*
 * Copyright 2021 IBM Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <SPL/Debugger/ApplicationModel.h>
#include <SPL/Debugger/BreakPoint.h>
#include <SPL/Debugger/InjectPoint.h>
#include <SPL/Debugger/ProbePointExpressionPredicate.h>
#include <SPL/Debugger/ProbePointServices.h>
#include <SPL/Debugger/SdbConsoleLogger.h>
#include <SPL/Debugger/StandaloneClient.h>
#include <SPL/Debugger/ValueDefinition.h>
#include <SPL/Runtime/Common/RuntimeException.h>
#include <SPL/Runtime/Function/SPLFunctions.h>
#include <SPL/Runtime/Operator/OperatorContext.h>
#include <SPL/Runtime/Operator/OperatorImpl.h>
#include <SPL/Runtime/Operator/Port/OperatorInputPortImpl.h>
#include <SPL/Runtime/Operator/Port/OperatorOutputPortImpl.h>
#include <SPL/Runtime/Operator/Port/PortSignal.h>
#include <SPL/Runtime/Operator/Port/ProcessSignal.h>
#include <TRC/DistilleryDebugLogger.h>

#include <cstdio>
#include <iomanip>
#include <iostream>
#include <list>
#include <sstream>
#include <string>
#include <utility>

using namespace SPL;
using namespace std;
using namespace std::tr1;

UTILS_NAMESPACE_USE
DEBUG_NAMESPACE_USE

static UTILS_NAMESPACE::Mutex _SDB_client_mutex;

// A list of output lines that were generated by one of the debugger's
// callback threads.  These lines are asynchronously handled by the
// standalone client using the outputHandler function defined below.
std::list<string*> _outputLines;
std::list<string*> _loggerLines;

#define GL_INDENT_L0 0
#define GL_INDENT_L1 3
#define GL_INDENT_L2 4

#define gl_display_and_flush_text(dum1, dum2, dum3, dum4, dum5, dum6, dum7, stro)                  \
    gl_display_text(dum1, dum2, dum3, dum4, dum5, dum6, dum7, stro);                               \
    cout << flush

// The minimum width of a table column for "s" command
#define MINWIDTH_ATTR_TABLEFORMAT 5
#define MAXWIDTH_ATTR_TABLEFORMAT 12
// the maximum width of a tuple field for key-vale format
#define MAXWIDTH_ATTR_KVFORMAT 30

// The break command used when launching GDB. We can't use rbreak for V2, as the
// process method handles all ports
#define GDB_BREAK_CMD "break"

static const Meta::TupleType& getTuple(OperatorImpl& op,
                                       PEImpl::PortType portType,
                                       uint32_t portIndex)
{
    const Meta::BaseType* bt;
    if (portType == PEImpl::INPUT) {
        bt = &op.getInputPortAt(portIndex).getTupleType();
    } else {
        bt = &op.getOutputPortAt(portIndex).getTupleType();
    }
    assert(bt->is<Meta::TupleType>());
    return bt->as<Meta::TupleType>();
}

static const Meta::TupleType& getTuple(PEImpl& pe,
                                       const std::string& opName,
                                       PEImpl::PortType portType,
                                       uint32_t portIndex)
{
    return getTuple(pe.getOperator(opName), portType, portIndex);
}

// tecla's callback to complete token's on the command line
// The gl_get_line method invokes this callback to complete tokens.
CPL_MATCH_FN(V2sdbCompletionFunction)
{
    int i, j;
    // Search backwards from the specified index.
    for (i = word_end - 1; i >= 0; i--) {
        int c = line[i];
        // Stop on unescaped spaces.
        if (isspace(c)) {
            // The space can't be escaped if we are at the start of the line.
            if (i == 0) {
                break;
            }
            // Find the extent of the escape characters which precedes the space.
            for (j = i - 1; j >= 0 && line[j] == '\\'; j--) {
                ;
            }
            // If there isn't an odd number of escape characters before the space,
            // then the space isn't escaped.
            if ((i - 1 - j) % 2 == 0) {
                break;
            }
        }
    }

    vector<string> tokens;
    tokenize(line, tokens, " ", false);

    string token = string(line + i + 1);

    ProbePointServices& _services = *((ProbePointServices*)data);
    const ApplicationModel& model = _services.getApplicationModel();
    // if performance is an issue, the operators may be cached in the
    // init() method
    unordered_map<string, OperatorImpl*> operators;
    unordered_map<string, OperatorImpl*>::const_iterator iter_p;
    model.getOperators(operators);

    if (tokens.size() == 0) {
        return 0;
    }

    string command = tokens[0];

    // Nothing to complete, yet.
    if (tokens.size() == 1 && token == "") {
        if (!command.compare("b") || !command.compare("i") || !command.compare("t") ||
            !command.compare("o") || !command.compare("gdb")) {
            // just list all the operators
            for (iter_p = operators.begin(); iter_p != operators.end(); iter_p++) {
                OperatorImpl* opProp = iter_p->second;
                const std::string name = opProp->getContext().getName() + ' ';
                if (cpl_add_completion(cpl, line, i + 1, word_end, name.c_str(), "", "")) {
                    return 1;
                }
            }
        }
        return 0;
    }

    // for a breakpoint, tracepoint or launch GDB command, complete the operator name
    if (!command.compare("b") || !command.compare("i") || !command.compare("t") ||
        !command.compare("o") || !command.compare("gdb")) {
        // for a breakpoint or trace command, attempt to complete the operator name

        if (tokens.size() == 2) {
            for (iter_p = operators.begin(); iter_p != operators.end(); iter_p++) {
                OperatorImpl* opProp = iter_p->second;
                const std::string& name = opProp->getContext().getName();
                if (strncmp(name.c_str(), token.c_str(), token.size()) == 0) {
                    string completionStr;
                    if (name.size() > token.size()) {
                        completionStr = name + ' ';
                        if (cpl_add_completion(cpl, line, i + 1, word_end,
                                               completionStr.c_str() + token.size(), "", "")) {
                            return 1;
                        }
                    }
                }
            }
            // End, if (tokens.size() == 2
        } else if (tokens.size() >= 6 && (!command.compare("b") || !command.compare("t"))) {
            // For Perl predicate variable name completeion when defining a breakpoint or tracepoint
            // Must have no wildcard in port spec, and the specified port must exist so we can get
            // its schema
            string opName = tokens[1];
            string portTypeStr = tokens[2];
            PEImpl::PortType portType;
            string portIndexStr = tokens[3];
            uint32_t portIndex;
            unordered_map<string, OperatorImpl*>::iterator opIter;
            opIter = operators.find(opName);
            if (opIter == operators.end()) {
                return 0; // Operator name
            }
            OperatorImpl* opProp = opIter->second;

            string digits = "0123456789";
            if (portIndexStr.find_first_not_of(digits) != string::npos) {
                return 0; // non-numeric port index
            }
            portIndex = atoi(portIndexStr.c_str());

            if (!portTypeStr.compare("i")) {
                portType = PEImpl::INPUT;
                if (portIndex >= opProp->getNumberOfInputPorts()) {
                    return 0; // bad port index
                }
            } else if (!portTypeStr.compare("o")) {
                portType = PEImpl::OUTPUT;
                if (portIndex >= opProp->getNumberOfOutputPorts()) {
                    return 0; // bad port index
                }
            } else {
                return 0; // bad port type
            }

            // Loop through optional args to see if "p" is specified to mark the beginning of a
            // predicate
            bool foundP = false;
            uint32_t tokIdx = 4;
            while (!foundP && tokIdx < tokens.size()) {
                foundP = (tokens[tokIdx++].compare("p") == 0);
            }

            if (foundP) {
                const Meta::TupleType& tuple = getTuple(*opProp, portType, portIndex);
                vector<string> attrNames;
                for (uint32_t att = 0, n = tuple.getNumberOfAttributes(); att < n; att++) {
                    attrNames.push_back(tuple.getAttributeName(att));
                }

                vector<string>::iterator varIter;
                for (varIter = attrNames.begin(); varIter != attrNames.end(); varIter++) {
                    if (strncmp((*varIter).c_str(), token.c_str(), token.size()) == 0) {
                        if (cpl_add_completion(cpl, line, i + 1, word_end,
                                               (*varIter).c_str() + token.size(), "", "")) {
                            return 1;
                        }
                    }
                }
            }
        } else if (!command.compare("u")) {
            // For an update command, attempt to complete tuple's attribute name.

            uint32_t probePointId;
            vector<uint32_t> stoppedIds;

            switch (tokens.size()) {
                case 2:
                    // If only two arguments are specified, assume that no probe point is specified.
                    // Use a default probe point, if possible; a single stopped breakpoint or
                    // injectpoint.
                    _services.getStoppedProbepoints(stoppedIds);
                    if (stoppedIds.size() != 1) {
                        return 0;
                    }
                    probePointId = stoppedIds.front();
                    break;
                case 3:
                    // If 3 arguments are entered, assume that the second argument is the probe
                    // point ID
                    probePointId = atoi(tokens[1].c_str());
                    break;
                default:
                    return 0;
            }

            Tuple* tuple = NULL;
            ProbePointPtr probePoint = _services.getProbePoint(probePointId);

            // If an invalid break point is entered, just return w/o attempting completion

            if (probePoint == NULL) {
                return 0;
            }
            if (probePoint->isType("Breakpoint")) {
                BreakPoint& breakPoint = dynamic_cast<BreakPoint&>(*probePoint);
                if (!breakPoint.isCondition("stopped", "true") ||
                    breakPoint.isCondition("dropped", "true")) {
                    return 0;
                }
                tuple = breakPoint.getStoppedTuple();
            } else if (probePoint->isType("Injectpoint")) {
                PEImpl& peHandle = _services.getPeHandle();
                tuple = &peHandle.retrieveTuple(probePointId);
            } else {
                return 0;
            }

            // if it's a punctuation, just return.
            if (tuple == NULL) {
                return 0;
            }
            unordered_map<string, uint32_t> const& attributes = tuple->getAttributeNames();
            unordered_map<string, uint32_t>::const_iterator iter;

            for (iter = attributes.begin(); iter != attributes.end(); iter++) {
                string attributeKey = iter->first;
                if (strncmp(attributeKey.c_str(), token.c_str(), token.size()) == 0) {
                    const ValueHandle attributeValueHandle = tuple->getAttributeValue(attributeKey);
                    // Add a opening bracket if the attribute is a list or a matrix
                    switch (attributeValueHandle.getMetaType()) {
                        case Meta::Type::LIST:
                        case Meta::Type::BLIST:
                            attributeKey += '[';
                            break;
                        case Meta::Type::SET:
                        case Meta::Type::BSET:
                        case Meta::Type::MAP:
                        case Meta::Type::BMAP:
                            attributeKey += '{';
                            break;
                        default:
                            attributeKey += ' ';
                            break;
                    }
                    if (cpl_add_completion(cpl, line, i + 1, word_end,
                                           attributeKey.c_str() + token.size(), "", "")) {
                        return 1;
                    }
                }
            }
        } else if (!command.compare("p")) {
            // For a predicate command, attempt to complete perl variable names.

            uint32_t probePointId;

            if (tokens.size() > 2) {
                probePointId = atoi(tokens[1].c_str());
            } else {
                return 0;
            }

            ProbePointPtr probePoint = _services.getProbePoint(probePointId);

            // If an invalid break point is entered, just return w/o attempting completion
            if (probePoint == NULL) {
                return 0;
            }

            // If not a break point or trace point, just return
            if (!probePoint->isType("Breakpoint") && !probePoint->isType("Tracepoint")) {
                return 0;
            }

            // Get the tuple for the port associated with the probe point
            const Meta::TupleType& tuple =
              getTuple(probePoint->getPeHandle(), probePoint->getOperationName(),
                       probePoint->getPortType(), probePoint->getPortIndex());
            vector<string> attrNames;
            for (uint32_t att = 0, n = tuple.getNumberOfAttributes(); att < n; att++) {
                attrNames.push_back(tuple.getAttributeName(att));
            }

            vector<string>::iterator varIter;
            for (varIter = attrNames.begin(); varIter != attrNames.end(); varIter++) {
                if (strncmp((*varIter).c_str(), token.c_str(), token.size()) == 0) {
                    if (cpl_add_completion(cpl, line, i + 1, word_end,
                                           (*varIter).c_str() + token.size(), "", "")) {
                        return 1;
                    }
                }
            }
        }
    }
    return 0;
}

/*
 * This is a callback invoked by tecla's gl_get_line() method to handle
 * async output. This function  is invoked whenever a read event
 * is available on a pipe.  The SDB writes a byte to the pipe whenever
 * a breakpoint is encountered, and breakpoint properties are to be output.
 */
GL_FD_EVENT_FN(outputHandler)
{
    // Set the terminal to a normal mode for output.  The gl_get_line() will
    // reset the terminal to a raw mode when this method returns.
    gl_normal_io(gl);

    // read the byte that activated this callback, and throw it away.
    char buffer[1];
    read(fd, buffer, sizeof(buffer));

    while (!_outputLines.empty()) {
        string* outputLine = _outputLines.front();
        gl_display_and_flush_text(gl, GL_INDENT_L2, NULL, NULL, ' ', 132, 0, outputLine->c_str());
        delete outputLine;
        _outputLines.pop_front();
    }
    return GLFD_REFRESH;
};

/*
 * This is a inactivity timer callback invoked by tecla's gl_get_line() after a defined
 * period of inactivity. This is used o write queued logger output, if any.
 */
GL_TIMEOUT_FN(loggerHandler)
{
    if (_loggerLines.empty()) {
        return GLTO_CONTINUE;
    }

    // Set the terminal to a normal mode for output.  The gl_get_line() will
    // reset the terminal to a raw mode when this method returns.
    gl_normal_io(gl);

    while (!_loggerLines.empty()) {
        string* outputLine = _loggerLines.front();
        gl_display_and_flush_text(gl, GL_INDENT_L0, NULL, NULL, ' ', 132, 0, outputLine->c_str());
        delete outputLine;
        _loggerLines.pop_front();
    }
    return GLTO_REFRESH;
};

StandaloneClient::StandaloneClient(ProbePointServices& probePointServices)
  : _probePointServices(probePointServices)
{
    _commandsUsageInfo.insert(pair<Commands, string>(StandaloneClient::HELP, "(h)elp"));
    _commandsUsageInfo.insert(
      pair<Commands, string>(StandaloneClient::GO, "(g)o start running the application"));
    _commandsUsageInfo.insert(pair<Commands, string>(StandaloneClient::QUIT, "(q)uit SDB"));
    _commandsUsageInfo.insert(pair<Commands, string>(
      StandaloneClient::CONTINUE, "(c)ontinue <probe point id> | * [p only|before|after]"));
    _commandsUsageInfo.insert(pair<Commands, string>(
      StandaloneClient::SET_BREAKPOINT,
      "(b)reakpoint <operator name> <port type (i|o)> <port index | *> [d] [p <expression>]"));
    _commandsUsageInfo.insert(
      pair<Commands, string>(StandaloneClient::SET_INJECTPOINT,
                             "(i)njectpoint <operator name> <port type (i|o)> <port index | *>"));
    _commandsUsageInfo.insert(
      pair<Commands, string>(StandaloneClient::SET_TRACEPOINT,
                             "(t)racepoint <operator name> <port type (i|o)> <port index> [max "
                             "tuples = 10] [d] [log] [p <expression>]"));
    _commandsUsageInfo.insert(pair<Commands, string>(StandaloneClient::SET_PREDICATE,
                                                     "(p)redicate <probe point id> <expression>"));
    _commandsUsageInfo.insert(pair<Commands, string>(
      StandaloneClient::SHOW_TRACEPOINT, "(s)how-probepoint <probe point id>  [t (table format)]"));
    _commandsUsageInfo.insert(
      pair<Commands, string>(StandaloneClient::LIST_PROBEPOINTS, "(l)ist-probepoints"));
    _commandsUsageInfo.insert(pair<Commands, string>(
      StandaloneClient::LIST_OPERATORS,
      "list-(o)perators [<operator-name>  [<port type (i|o)> <port index>] ]"));
    _commandsUsageInfo.insert(
      pair<Commands, string>(StandaloneClient::FIND_FIELDS,
                             "find [<field-name | *> [<field-type | *> | *] ]\n\tFinds fields "
                             "definitions for the available operators"));
    _commandsUsageInfo.insert(pair<Commands, string>(StandaloneClient::REMOVE_PROBEPOINT,
                                                     "(r)emove-probepoint <probe point id | *>"));
    _commandsUsageInfo.insert(pair<Commands, string>(StandaloneClient::ENABLE_PROBEPOINT,
                                                     "(e)nable-probepoint <probe point id | *>"));
    _commandsUsageInfo.insert(pair<Commands, string>(StandaloneClient::DISABLE_PROBEPOINT,
                                                     "(d)isable-probepoint <probe point id | *>"));
    _commandsUsageInfo.insert(
      pair<Commands, string>(StandaloneClient::UPDATE_TUPLE,
                             "(u)pdate-tuple <probe point id> <attribute name> <attribute value>"));
    _commandsUsageInfo.insert(
      pair<Commands, string>(StandaloneClient::DROP_TUPLE,
                             "e(x)clude-tuple <probe point id> | * >\n\tToggles drop of tuple"));
    _commandsUsageInfo.insert(
      pair<Commands, string>(StandaloneClient::SAVE,
                             "(save) <probe point id> <file name>\n\tSaves the cached tuples for a "
                             "specified probe point to a file"));
    _commandsUsageInfo.insert(pair<Commands, string>(
      StandaloneClient::LOG, "(log) <probe point id> <start | stop>\n\tStarts or stops logging "
                             "tracepoint tuples to a file"));
    _commandsUsageInfo.insert(pair<Commands, string>(
      StandaloneClient::CLEAR,
      "(clear) <probe point id>\n\tClears the cached tuples for the specified trace point"));
    _commandsUsageInfo.insert(pair<Commands, string>(
      StandaloneClient::SAVECFG,
      "(savecfg) [<cfg-name>]\n\tSaves the current probe point definitions"));
    _commandsUsageInfo.insert(pair<Commands, string>(
      StandaloneClient::LOADCFG,
      "(loadcfg) [<cfg-name>]\n\tLoads previously saved probe point definitions"));
    _commandsUsageInfo.insert(pair<Commands, string>(
      StandaloneClient::SETDBG,
      "(setdbg) [<name>          <value>]\n             loglevel        0|1|2|3\n             "
      "logformat       log|syslog\n             tracelevel      0|1|2|3|4|5\n             "
      "traceformat     default|short|long"));
    _commandsUsageInfo.insert(pair<Commands, string>(
      StandaloneClient::GDB,
      "(gdb) <[breakpoint id] | operator name>\n\tLaunch GDB, break on process method(s)"));

    // Get a handle to the libtecla's command line processor
    _gl = new_GetLine(256, 2048);

    if (gl_ignore_signal(_gl, SIGWINCH) != 0) {
        cerr << "Error configuring tecla to ignore SIGWINCH !" << endl;
        return;
    }

    if (gl_ignore_signal(_gl, SIGINT) != 0) {
        cerr << "Error configuring tecla to ignore SIGINT !" << endl;
        return;
    }

    if (gl_ignore_signal(_gl, SIGQUIT) != 0) {
        cerr << "Error configuring tecla to ignore SIGQUIT !" << endl;
        return;
    }

    if (gl_ignore_signal(_gl, SIGCONT) != 0) {
        cerr << "Error configuring tecla to ignore SIGCONT !" << endl;
        return;
    }

    if (gl_ignore_signal(_gl, SIGTSTP) != 0) {
        cerr << "Error configuring tecla to ignore SIGTSTP !" << endl;
        return;
    }

    // Create a pipe used to activate the tecla's gl_get_line() callback.
    if (pipe(_outputEventPipe) != 0) {
        cerr << "Error creating pipe!" << endl;
        return;
    }

    // Register the callback method using the pipe's read file descriptor.
    if (gl_watch_fd(_gl, _outputEventPipe[0], GLFD_READ, outputHandler, this) != 0) {
        cerr << "Error registering output handler! fd: " << _outputEventPipe[0] << endl;
        return;
    }

    // Register an inactivity callback to fire after ten milliseconds (10 million nanoseconds) of
    // inactivity
    if (gl_inactivity_timeout(_gl, loggerHandler, this, (uint32_t)0, (uint32_t)10000000)) {
        cerr << "Error registering logger output handler! " << endl;
        return;
    }

    stringstream welcomeMessage;
    welcomeMessage << "IBM Stream Debugger (SDB), pid: " << getpid() << "\n";
    gl_display_and_flush_text(_gl, GL_INDENT_L0, NULL, NULL, ' ', 132, 0,
                              welcomeMessage.str().c_str());
};

StandaloneClient::~StandaloneClient()
{
    if (_gl != NULL) {
        del_GetLine(_gl);
    }
    if (gl_watch_fd(_gl, _outputEventPipe[0], GLFD_READ, NULL, NULL) != 0) {
        cerr << "Error unregistering output handler!" << endl;
    }
};

void StandaloneClient::init()
{
    //    const ApplicationModel model = _probePointServices.getApplicationModel();
    //  model.getOperators(_opPropMap);

    if (gl_customize_completion(_gl, &_probePointServices, V2sdbCompletionFunction) != 0) {
        cerr << "Error registering completion function " << endl;
        return;
    }
}

void StandaloneClient::asyncPrintTuple(uint32_t hookId, ProbePoint* probePoint, Tuple* tuple)
{
    // Ensure the serial output of concurrent probe points
    AutoMutex am(_SDB_client_mutex);

    asyncPrintProbePoint(hookId, probePoint);
    asyncPrintTuple(tuple);

    // activate the gl_get_line() callback with a read event
    write(_outputEventPipe[1], "r", 1);
}

void StandaloneClient::asyncPrintPunctuation(uint32_t hookId,
                                             ProbePoint* probePoint,
                                             Punctuation& p)
{
    // Ensure the serial output of concurrent probe points
    AutoMutex am(_SDB_client_mutex);

    asyncPrintProbePoint(hookId, probePoint);
    asyncPrintPunctuation(p);

    // activate the gl_get_line() callback with a read event
    write(_outputEventPipe[1], "r", 1);
}

/*
 * Queue a message to be output asynchronously by tecla's gl_get_line() callback.
 */
void StandaloneClient::asyncPrintMessage(const string& message)
{
    string* line = new string();
    line->append(message).append("\n");
    _loggerLines.push_back(line);

    // activate the gl_get_line() callback with a read event
    // write(_outputEventPipe[1], "r", 1); // Passing the "l" tells the handler this is a log
    // message vs, breakpoint related output
}

/*
 * Format the contents of the probe point as a string suitable for output.
 */

void StandaloneClient::formatProbePoint(uint32_t hookId,
                                        ProbePoint* probePoint,
                                        string* outputString)
{
    stringstream outputLine;
    string portTypeString;

    if (probePoint->getPortType() == PEImpl::INPUT) {
        portTypeString = "i";
    } else {
        portTypeString = "o";
    }

    string enabledState;
    if (probePoint->isEnabled() == true) {
        enabledState = "+";
    } else {
        enabledState = "-";
    }

    outputLine.setf(ios::left);
    outputLine << setw(3) << enabledState << setw(4) << hookId << setw(12)
               << probePoint->getProbePointType() << setw(46) << probePoint->getOperationName()
               << setw(4) << portTypeString << setw(6) << probePoint->getPortIndex();

    // Print out the conditions for this probe point, if any.  The conditions contain runtime
    // information specific to the probe point type.
    ProbePoint::ProbePointConditionsType& conditions = probePoint->getConditions();
    ProbePoint::ProbePointConditionsType::const_iterator iter;
    for (iter = conditions.begin(); iter != conditions.end(); iter++) {
        outputLine << iter->first << ":" << iter->second << ' ';
    }
    outputLine << endl;
    *outputString = outputLine.str();
}

/*
 * Format the contents of the given tuple as a string suitable for output.
 * The format of the output is [<key>, <value>, (<type>)
 */
void StandaloneClient::formatTuple(Tuple* tuple, string* outputString)
{
    stringstream outputLine;

    uint32_t nattr = tuple->getNumberOfAttributes();
    const Meta::TupleType& tupleType =
      dynamic_cast<const Meta::TupleType&>(Meta::BaseType::makeType(*tuple));
    for (uint32_t i = 0; i < nattr; ++i) {
        string attributeKey = tuple->getAttributeName(i);
        const ValueHandle attributeValueHandle = tuple->getAttributeValue(i);
        outputLine << attributeKey << ", "
                   << truncateAttributeField(attributeValueHandle.toString(),
                                             MAXWIDTH_ATTR_KVFORMAT)
                   << ", " << tupleType.getAttributeType(i).getName() << "\n";
    }

    *outputString = outputLine.str();
}

/*
 * Format the contents of a header record for a tuple
 * The format of the output is [<attribute key0> <attribute key1> <attribute key2> ...]
 */
void StandaloneClient::formatTupleRecordHeader(Tuple* tuple, string* outputString)
{
    stringstream outputLine;
    outputLine.setf(ios::left);

    uint32_t nattr = tuple->getNumberOfAttributes();
    for (uint32_t i = 0; i < nattr; ++i) {
        string attributeKey = tuple->getAttributeName(i);
        outputLine << setw(MAXWIDTH_ATTR_TABLEFORMAT)
                   << truncateAttributeField(attributeKey, MAXWIDTH_ATTR_TABLEFORMAT);
    }

    *outputString = outputLine.str();
}

/*
 * Format the contents of the given tuple as a a record suitable for output.
 * The format of the output is [<val0> <val1> <val2> ...]
 */
void StandaloneClient::formatTupleRecord(Tuple* tuple, string* outputString)
{
    stringstream outputLine;
    outputLine.setf(ios::left);

    uint32_t nattr = tuple->getNumberOfAttributes();
    for (uint32_t i = 0; i < nattr; ++i) {
        const ValueHandle attributeValueHandle = tuple->getAttributeValue(i);
        string valueString =
          truncateAttributeField(attributeValueHandle.toString(), MAXWIDTH_ATTR_TABLEFORMAT);
        outputLine << setw(MAXWIDTH_ATTR_TABLEFORMAT) << valueString;
    }

    *outputString = outputLine.str();
}

/*
 * Return the string representation of a data type
 */
string StandaloneClient::getDatatypeString(const Meta::BaseType& dataType)
{
    return dataType.getName();
}

void StandaloneClient::formatPunctuation(Punctuation& p, string* outputString)
{
    stringstream outputLine;
    outputLine << "   "
               << "[ punctuation: " << p << "]" << endl;
    *outputString = outputLine.str();
}

/*
 * Print the contents of the probe point to the console
 */
void StandaloneClient::printProbePoint(uint32_t hookId, ProbePoint* probePoint)
{
    string formattedProbePoint;
    formatProbePoint(hookId, probePoint, &formattedProbePoint);
    gl_display_and_flush_text(_gl, GL_INDENT_L2, NULL, NULL, ' ', 132, 0,
                              formattedProbePoint.c_str());
}

/*
 * Queue the content of a probe point to be output asynchronously by tecla's gl_get_line() callback.
 */
void StandaloneClient::asyncPrintProbePoint(uint32_t hookId, ProbePoint* probePoint)
{
    string* formattedProbePoint = new string();
    formatProbePoint(hookId, probePoint, formattedProbePoint);
    _outputLines.push_back(formattedProbePoint);
}

/*
 * Print the contents of the given tuple to the SDB's console.
 */
void StandaloneClient::printTuple(Tuple* tuple)
{
    string formattedTuple;
    formatTuple(tuple, &formattedTuple);
    // formattedTuple += "\n";
    gl_display_and_flush_text(_gl, GL_INDENT_L2, NULL, NULL, ' ', 132, 0, formattedTuple.c_str());
}

/*
 * Print the contents of the given tuple using tecla getline library.  For each attribute in the
 * tuple, the format of the output is [<key>, <value>, (<type>)
 */
void StandaloneClient::asyncPrintTuple(Tuple* tuple)
{
    string* formattedTuple = new string();
    formatTuple(tuple, formattedTuple);
    _outputLines.push_back(formattedTuple);
}

/*
 * Print the contents the header for a tuple record SDB's console.
 */
void StandaloneClient::printTupleRecordHeader(Tuple* tuple)
{
    string formattedTupleHeader;
    formatTupleRecordHeader(tuple, &formattedTupleHeader);
    formattedTupleHeader += "\n";
    gl_display_and_flush_text(_gl, GL_INDENT_L2, NULL, NULL, ' ', 132, 0,
                              formattedTupleHeader.c_str());
}

/*
 * Print the contents of the given tuple as a record to the SDB's console.
 */
void StandaloneClient::printTupleRecord(Tuple* tuple)
{
    string formattedTuple;
    formatTupleRecord(tuple, &formattedTuple);
    formattedTuple += "\n";
    gl_display_and_flush_text(_gl, GL_INDENT_L2, NULL, NULL, ' ', 132, 0, formattedTuple.c_str());
}

/*
 * Print the contents of the given punctuation to the SDB's condole.
 */
void StandaloneClient::printPunctuation(Punctuation& p)
{
    string formattedPunc;
    formatPunctuation(p, &formattedPunc);
    formattedPunc += "\n";
    gl_display_and_flush_text(_gl, GL_INDENT_L2, NULL, NULL, ' ', 132, 0, formattedPunc.c_str());
}

/*
 * Print the contents of the given punctuation to the SDB's condole.
 */
void StandaloneClient::asyncPrintPunctuation(Punctuation& p)
{
    string* formattedPunc = new string();
    formatPunctuation(p, formattedPunc);
    _outputLines.push_back(formattedPunc);
}

void StandaloneClient::printProbePoints()
{
    vector<uint32_t> probePointIds;
    _probePointServices.getProbePoints(probePointIds);
    string formattedProbePoint;

    if (probePointIds.size() == 0) {
        return;
    }

    stringstream headerLine;
    headerLine.setf(ios::left);
    headerLine << setw(3) << "On" << setw(4) << "Id" << setw(12) << "Type" << setw(46) << "Operator"
               << setw(4) << "i|o" << setw(6) << "Port#"
               << "Properties"
               << "\n";

    gl_display_and_flush_text(_gl, GL_INDENT_L2, NULL, NULL, ' ', 132, 0, headerLine.str().c_str());

    for (vector<uint32_t>::iterator iter = probePointIds.begin(); iter != probePointIds.end();
         iter++) {
        stringstream outputLine;
        uint32_t hookId = *iter;
        ProbePointPtr probePoint = _probePointServices.getProbePoint(hookId);
        formatProbePoint(hookId, probePoint.get(), &formattedProbePoint);
        gl_display_and_flush_text(_gl, GL_INDENT_L2, NULL, NULL, ' ', 132, 0,
                                  formattedProbePoint.c_str());
    }
}

// Print a status message to report change in the status (e.g. set, enable, disable, etc) of
// a probe point.  This method prints the status message (statusMsg), and the probe point's
// properties.
void StandaloneClient::printProbePointStatus(uint32_t id, const char* statusMsg)
{
    ProbePointPtr probePoint = _probePointServices.getProbePoint(id);
    string formattedProbePoint;
    formatProbePoint(id, probePoint.get(), &formattedProbePoint);
    formattedProbePoint = string(statusMsg) + ' ' + formattedProbePoint;
    gl_display_and_flush_text(_gl, GL_INDENT_L2, NULL, NULL, ' ', 132, 0,
                              formattedProbePoint.c_str());
}

void StandaloneClient::printOperators()
{
    unordered_map<string, OperatorImpl*> opPropMap;
    const ApplicationModel model = _probePointServices.getApplicationModel();
    model.getOperators(opPropMap);

    if (opPropMap.size() == 0) {
        return;
    }

    stringstream headerLine;
    headerLine.setf(ios::left);
    headerLine << setw(5) << "#in" << setw(5) << "#out" << setw(46) << "Operator" << setw(46)
               << "Class"
               << "\n";
    gl_display_and_flush_text(_gl, GL_INDENT_L1, NULL, NULL, ' ', 132, 0, headerLine.str().c_str());
    unordered_map<string, OperatorImpl*>::const_iterator iter_p;
    for (iter_p = opPropMap.begin(); iter_p != opPropMap.end(); iter_p++) {
        OperatorImpl* opProp = iter_p->second;
        const OperatorContext& opContext = opProp->getContext();
        stringstream outputLine;
        outputLine.setf(ios::left);
        outputLine << setw(5) << opProp->getNumberOfInputPorts() << setw(5)
                   << opProp->getNumberOfOutputPorts() << setw(46) << opContext.getName()
                   << setw(46) << opContext.getClassName() << "\n";
        gl_display_and_flush_text(_gl, GL_INDENT_L1, NULL, NULL, ' ', 132, 0,
                                  outputLine.str().c_str());
    }
}

void StandaloneClient::printOperator(const string& opName,
                                     PEImpl::PortType portType,
                                     uint32_t portIndex)
{
    const Meta::TupleType& tuple =
      getTuple(_probePointServices.getPeHandle(), opName, portType, portIndex);
    vector<string> attrNames;

    stringstream headerLine;
    headerLine.setf(ios::left);
    headerLine << (portType == PEImpl::INPUT ? "Input " : "Output ") << "port: " << opName
               << (portType == PEImpl::INPUT ? " i " : " o ") << portIndex << "\n";
    gl_display_and_flush_text(_gl, GL_INDENT_L1, NULL, NULL, ' ', 132, 0, headerLine.str().c_str());

    size_t maxAttrLen = 0;

    for (uint32_t i = 0, n = tuple.getNumberOfAttributes(); i < n; i++) {
        maxAttrLen = std::max(maxAttrLen, tuple.getAttributeName(i).size());
    }

    bool twoColumn = false;
    if (maxAttrLen <= 16) {
        twoColumn = true;
    }
    twoColumn = false; // Force back into one column mode

    string defaultValue;
    bool rightColumn = false;
    stringstream outputLine;
    outputLine.setf(ios::left);
    for (uint32_t i = 0, n = tuple.getNumberOfAttributes(); i < n; i++) {
        outputLine << setw(maxAttrLen) << tuple.getAttributeName(i) << " : " << setw(16)
                   << tuple.getAttributeType(i).getName();
        if (!twoColumn || rightColumn) {
            outputLine << endl;
            gl_display_and_flush_text(_gl, GL_INDENT_L2, NULL, NULL, ' ', 132, 0,
                                      outputLine.str().c_str());
            outputLine.str(string()); // Clear line
        } else {
            outputLine << setw(10) << ' '; // Ten space gutter between columns
        }
        rightColumn = !rightColumn;
    }
    if (twoColumn && rightColumn) {
        // Output last line if there was an odd number of attributes
        outputLine << endl;
        gl_display_and_flush_text(_gl, GL_INDENT_L2, NULL, NULL, ' ', 132, 0,
                                  outputLine.str().c_str());
    }
    gl_display_and_flush_text(_gl, GL_INDENT_L1, NULL, NULL, ' ', 132, 0, "\n");
}

PEImpl::PortType StandaloneClient::getPortTypeEnum(const string& portTypeString)
{
    if (!portTypeString.compare("i")) {
        return PEImpl::INPUT;
    } else {
        return PEImpl::OUTPUT;
    }
}

bool StandaloneClient::isProbePointArgsValid(const string& opName,
                                             const string& opType,
                                             const string& portType,
                                             uint32_t portIndex)
{
    const ApplicationModel model = _probePointServices.getApplicationModel();
    OperatorImpl* opProp = model.getOperator(opName);
    if (!opProp) {
        cerr << "Unknown operator '" << opName << '\'' << endl;
        return false;
    }
    if (opProp == NULL) {
        cerr << "operation " << opName << " not defined!" << endl;
        return false;
    }
    if ((portType.compare("i") != 0) && (portType.compare("o") != 0)) {
        cerr << "Invalid port type - should be \"i\" or \"o\"" << endl;
        return false;
    }
    if (!portType.compare("i") && (portIndex + 1 > opProp->getNumberOfInputPorts())) {
        cerr << "Invalid port index! Operator has only " << opProp->getNumberOfInputPorts()
             << " input port(s)" << endl;
        return false;
    }
    if (!portType.compare("o") && (portIndex + 1 > opProp->getNumberOfOutputPorts())) {
        cerr << "Invalid port index! Operator has only " << opProp->getNumberOfOutputPorts()
             << " output port(s)" << endl;
        return false;
    }
    int hookId;
    if ((hookId = _probePointServices.getProbePoint(opName, opType, getPortTypeEnum(portType),
                                                    portIndex)) != -1) {
        cerr << "Identical probe point already defined! id: " << hookId << endl;
        return false;
    }

    return true;
}

// Given a probe point, this method forms the set of GDB commands to define the corresponding
// breakpoint.  The commands saved in a file.  The file name is returned in outputFileName.
// This method returns a 1 if no error is encountered, and a 0 otherwise.
int StandaloneClient::createGdbCommands(ProbePointPtr probePoint, string& outputFileName)
{
    stringstream fileName;
    string portTypeString;

    if (probePoint == NULL) {
        cerr << "Invalid probe point ID specified" << endl;
        return 0;
    }
    if (!probePoint->isType("Breakpoint")) {
        cerr << "Probepoint is not a breakpoint. GDB can only be launched on an breakpoint defined "
                "on operator's input port"
             << endl;
        return 0;
    }

    if (probePoint->getPortType() != PEImpl::INPUT) {
        cerr << "Breakpoint is not on an input port.  GDB can only be launched on an operator's "
                "input port"
             << endl;
        return 0;
    }

    if (probePoint->getPortType() == PEImpl::INPUT) {
        portTypeString = "i";
    } else {
        portTypeString = "o";
    }

    string opProcessMethod;
    string opName = probePoint->getOperationName();

    // Use the application model to acquire the class name of the operator
    const ApplicationModel model = _probePointServices.getApplicationModel();
    OperatorImpl* opProp = model.getOperator(opName);
    const OperatorContext& context = opProp->getContext();

    // We have to figure out if this is a mutating port or not
    stringstream breakpointCmd;

#if 0 // old code is wrong: gdb takes function names WITHOUT args
    // First, stop on the punctuation processRaw in the base class
    breakpointCmd << GDB_BREAK_CMD << " SPL::_Operator::" << context.getClassName()
                  << "_Base::processRaw (SPL::Punctuation const&, unsigned int)";

    // Is there more than one port?
    if(opProp->getNumberOfInputPorts() > 1) // Need to care which port we are using
        breakpointCmd << " if port == " << probePoint->getPortIndex();
    breakpointCmd << '\n';

    // Now the Tuple handling
    breakpointCmd << GDB_BREAK_CMD << " SPL::_Operator::" << context.getClassName()
                  << "_Base::processRaw (SPL::Tuple";
    if(!opProp->process_[probePoint->getPortIndex()]->isMutating())
        breakpointCmd << " const";
    breakpointCmd << "&, unsigned int)";
    if(opProp->getNumberOfInputPorts() > 1) // Need to care which port we are using
        breakpointCmd << " if port == " << probePoint->getPortIndex();
    breakpointCmd << '\n';
#endif

    // New code simply breaks on the function name
    // So there will be 2 breakspoints set: 1 for punct and 1 for Tuple
    breakpointCmd << GDB_BREAK_CMD << " SPL::_Operator::" << context.getClassName()
                  << "_Base::processRaw";
    if (opProp->getNumberOfInputPorts() > 1) { // Need to care which port we are using
        breakpointCmd << " if port == " << probePoint->getPortIndex();
    }
    breakpointCmd << '\n';

    fileName << _probePointServices.getPeHandle().getDataDirectory() << "/"
             << probePoint->getOperationName() << "." << portTypeString << "."
             << probePoint->getPortIndex() << "."
             << "gdb";

    outputFileName = fileName.str();
    ofstream of;
    of.open(outputFileName.c_str());
    if (!of) {
        cerr << "Failed to open output file '" << outputFileName << "'" << endl;
        return 0;
    }

    // Output breakpoint command
    of << breakpointCmd.str() << flush;

    // Output continue command - GDB continue and control returns to SDB
    of << "cont\n" << flush;

    if (of.fail()) {
        cerr << "Failed to write probe point definitions to output file '" << outputFileName << "'"
             << endl;
        return 0;
    }

    of.close();

    cout << "Wrote GDB commands to file " << outputFileName << endl << flush;
    return 1;
}

// Given an operator name, this method forms the set of GDB commands to
// breakpoint on the operator's methods that process inbound tuples.  For source
// operators, a single breakpoint is defined for the source's process(unsigned int)
// method. For non-source operators, a breakpoint is defined for the
// process(Tuple&, unsigned int) and/or process(Tuple const &, unsigned int) methods
// (depending on the mutability of the ports) and the process(Punctuation const
// &, unsigned int) method. This method returns a 1 if no error is encountered, and
// a 0 otherwise.
int StandaloneClient::createGdbCommands(const string& opName, string& outputFileName)
{
    // Use the application model to acquire the operator's properties
    const ApplicationModel model = _probePointServices.getApplicationModel();
    OperatorImpl* opProp = model.getOperator(opName);
    const OperatorContext& context = opProp->getContext();

    stringstream breakpointCmd;

    // Source operator has a single process() method
    if (opProp->getNumberOfInputPorts() == 0) {
        breakpointCmd << GDB_BREAK_CMD << " SPL::" << context.getClassName() << "::"
                      << "process(unsigned int)\n";
    } else {
        // We have to figure out if this is a mutating port or not

        // First, stop on the punctuation processRaw in the base class
        breakpointCmd << GDB_BREAK_CMD << " SPL::" << context.getClassName()
                      << "_Base::processRaw (SPL::Punctuation const&, unsigned int)\n";

        // Now the Tuple handling
        // Figure out what types of port we have
        bool mutating = false;
        bool nonMutating = false;
        for (uint32_t i = 0, n = opProp->getNumberOfInputPorts(); i < n; i++) {
            if (opProp->process_[i]->isMutating()) {
                mutating = true;
            } else {
                nonMutating = true;
            }
        }

        if (mutating) {
            breakpointCmd << GDB_BREAK_CMD << " SPL::" << context.getClassName()
                          << "_Base::processRaw (SPL::Tuple&, unsigned int)\n";
        }
        if (nonMutating) {
            breakpointCmd << GDB_BREAK_CMD << " SPL::" << context.getClassName()
                          << "_Base::processRaw (SPL::Tuple const&, unsigned int)\n";
        }
    }

    stringstream fileName;
    fileName << _probePointServices.getPeHandle().getDataDirectory() << "/" << opName << ".gdb";

    outputFileName = fileName.str();
    ofstream of;
    of.open(outputFileName.c_str());
    if (!of) {
        cerr << "Failed to open output file '" << outputFileName << "'" << endl << flush;
        return 0;
    }

    of << breakpointCmd.str();

    // Output continue command - GDB continue and control returns to SDB
    of << "cont\n" << flush;

    if (of.fail()) {
        cerr << "Failed to write probe point definitions to output file '" << outputFileName << "'"
             << endl
             << flush;
        return 0;
    }

    of.close();

    cout << "Wrote GDB commands to file " << outputFileName << endl << flush;
    return 1;
}

// Copied from StandaloneApplication
void StandaloneClient::getExecutableLocation(string& exeDirPath, string& exeFileName)
{
    string exeLink("/proc/");
    pid_t pid;
    stringstream osPid;
    int rc;
    char exePathBuf[4096];
    string exePath;

    exeDirPath = "";
    exeFileName = "";

    pid = getpid(); // Get process ID
    osPid << pid;
    exeLink.append(osPid.str());
    exeLink.append("/exe");
    rc = readlink(exeLink.c_str(), exePathBuf, sizeof(exePathBuf));
    if (rc != -1) {
        exePathBuf[rc] = '\0';
        exePath = exePathBuf;
        int idx = exePath.find_last_of('/');
        exeDirPath = exePath.substr(0, idx + 1);
        exeFileName = exePath.substr(idx + 1);
    }
}

bool StandaloneClient::queryUser()
{

    /*
     * Using TECLA for input processing
     */
    cout << flush;
    char* inputLine;
    if ((inputLine = gl_get_line(_gl, "(sdb) ", NULL, -1)) == NULL) {
        GlReturnStatus rc = gl_return_status(_gl);
        if (rc == GLR_SIGNAL) {
            if (_probePointServices.isStandaloneApplication()) {
                cout << "quitting SDB" << endl << flush;
                strcpy(inputLine, "q");
            } else {
                return false; // Stop running debugger
            }
        } else {
            return true;
        }
    }
    string inputCommandString(inputLine);
    gl_normal_io(_gl);
    cout << flush;

    // For deployed PE (not standalone), intercept quit request
    if (!_probePointServices.isStandaloneApplication()) {
        istringstream testStream(inputCommandString);
        string testCmd;
        testStream >> testCmd;
        if (testCmd.compare("q") == 0 || testCmd.compare("quit") == 0) {
            _probePointServices.stopDebugger();
            return false; // Stop running debugger
        }
    }

    istringstream inputCommand;
    inputCommand.str(inputCommandString);

    executeCommand(inputCommand);
    return true;
}

void StandaloneClient::executeCommand(istringstream& inputCommand)
{
    string commandName;
    inputCommand >> commandName;

    // use only the first character
    // commandName = commandName.substr(0,1);

    if (!commandName.compare("")) { /* no command */
        return;
    }

    if (!commandName.compare("h")) { /* help */
        for (CommandsUsageInfoType::const_iterator iter = _commandsUsageInfo.begin();
             iter != _commandsUsageInfo.end(); ++iter) {
            cout << "   " << iter->second << endl << flush;
        }
    } else if (!commandName.compare("c")) { /* continue */
        if (_probePointServices.isStartup()) {
            cerr << "   Invalid application state for Continue command. Start application using "
                    "\"g\" command"
                 << endl
                 << flush;
            return;
        }
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::CONTINUE);
        string usage = iter->second;
        string probePointId = "";
        bool probePointIdSpecified = false;
        string punctOption = "";
        string punctOrder = "";

        // The probe point id is either "*" or not specified.
        // A probePointId == "p" implies that no probe id is specified and that
        // this continue command applies to an inject point referenced by the detault
        // probe point ID, if any
        if ((inputCommand >> probePointId)) {
            if (probePointId.compare("p")) {
                probePointIdSpecified = true;
            } else {
                punctOption = "p";
            }
        }

        // Either the "p" option has already been specified, or maybe the next arg ...
        if (!punctOption.compare("p") || (inputCommand >> punctOption)) { /* 'p' option */
            if (punctOption.compare("p")) {
                cerr << "Invalid argument" << endl << flush;
                cerr << "usage: " << usage << endl << flush;
                return;
            }
            if (!(inputCommand >> punctOrder)) {
                cerr << "Missing order argument for punctuation" << endl << flush;
                cerr << "usage: " << usage << endl << flush;
                return;
            }
            punctOrder = punctOrder.substr(0, 1);
            if (punctOrder.compare("o")       /* only */
                && punctOrder.compare("b")    /* before */
                && punctOrder.compare("a")) { /* after */
                cerr << "Punctuation order argument incorrect" << endl << flush;
                cerr << "usage: " << usage << endl << flush;
                return;
            }
        }

        if (probePointIdSpecified && (trim(probePointId).compare("*") == 0)) {
            // Only breakpoints, and not injectpoints, are included in the wildcard.
            // Including injectpoints would likely result in inadvertantly submitting
            // the default tuple associated with injectpoints.
            vector<uint32_t> stoppedIds;
            _probePointServices.getProbepoints(stoppedIds, "Breakpoint", "stopped", "true");
            if (stoppedIds.size() == 0) {
                cerr << "No breakpoint stopped; nothing to continue!" << endl << flush;
            }
            vector<uint32_t>::const_iterator iter1;
            for (iter1 = stoppedIds.begin(); iter1 != stoppedIds.end(); iter1++) {
                cout << "Continuing breakpoint " << *iter1 << endl << flush;
                ProbePointPtr probePoint = _probePointServices.getProbePoint(*iter1);
                _probePointServices.continueRunning(*iter1, dynamic_cast<BreakPoint&>(*probePoint));
            }
            return;
        }

        uint32_t probePointId_int;
        if (probePointIdSpecified) {
            probePointId_int = (uint32_t)atoi(probePointId.c_str());
        } else {
            vector<uint32_t> stoppedIds;
            _probePointServices.getStoppedProbepoints(stoppedIds);
            if (stoppedIds.size() == 1) {
                probePointId_int = stoppedIds.front();
            } else if (stoppedIds.size() == 0) {
                cerr << "No breakpoint stopped; nothing to continue!" << endl << flush;
                return;
            } else {
                cerr << "Ambiguous. Specify one of the stopped breakpoints or injectpoints, or '*' "
                        "to continue all"
                     << endl
                     << flush;
                return;
            }
        }

        ProbePointPtr probePoint = _probePointServices.getProbePoint(probePointId_int);
        if (probePoint.get() == NULL) {
            cerr << "Probe point " << probePointId_int << " does not exist" << endl << flush;
            return;
        }

        if (probePoint->isType("Breakpoint")) {
            _probePointServices.continueRunning(probePointId_int,
                                                dynamic_cast<BreakPoint&>(*probePoint));
        } else {
            _probePointServices.continueRunning(
              probePointId_int, dynamic_cast<InjectPoint&>(*probePoint), punctOrder);
        }
    } else if (!commandName.compare("b")) { /* set breakpoint */
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::SET_BREAKPOINT);
        string usage = iter->second;
        string opName, portType;
        string portIndexString;

        if (!(inputCommand >> opName)) {
            cerr << "opName not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
            return;
        } else if (!(inputCommand >> portType)) {
            cerr << "port type (i or o) not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
            return;
        } else if (!(inputCommand >> portIndexString)) {
            cerr << "port index not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
            return;
        }

        const ApplicationModel model = _probePointServices.getApplicationModel();
        OperatorImpl* opProp = model.getOperator(opName);
        if (!opProp) {
            cerr << "Unknown operator '" << opName << '\'' << endl << flush;
            return;
        }

        // Add port indexes for breakpoint, where "*" implies all ports (input or output)
        vector<uint32_t> portIndexVector;
        if (!portIndexString.compare("*")) {
            uint32_t numPorts;
            if (!portType.compare("i")) {
                numPorts = opProp->getNumberOfInputPorts();
            } else {
                numPorts = opProp->getNumberOfOutputPorts();
            }
            for (uint32_t portIndex = 0; portIndex < numPorts; portIndex++) {
                portIndexVector.push_back(portIndex);
            }
        } else {
            portIndexVector.push_back(atoi(portIndexString.c_str()));
        }

        string optionalArg;
        bool disable = false;
        string predicate;
        bool done = false;
        while (!done) {
            if (!(inputCommand >> optionalArg)) {
                done = true;
            } else {
                if (!optionalArg.compare("d")) {
                    disable = true;
                } else if (!optionalArg.compare("p")) {
                    char strbuf[2049];
                    inputCommand.getline(strbuf, 2048);
                    predicate = strbuf;
                    predicate = trim(predicate);
                    done = true;
                    if (predicate.size() == 0) {
                        cerr << "predicate option, p, specified without a predicate expression"
                             << endl
                             << flush;
                    }
                } else {
                    cerr << "unrecognized command option: '" << optionalArg << "'" << endl << flush;
                }
            }
        }

        vector<uint32_t>::iterator portIndexIter;
        vector<ProbePointPtr> probePoints;
        // Verify syntax of parameters
        for (portIndexIter = portIndexVector.begin(); portIndexIter != portIndexVector.end();
             portIndexIter++) {
            uint32_t portIndex = *portIndexIter;
            if (!isProbePointArgsValid(opName, "Breakpoint", portType, portIndex)) {
                return;
            }

            // Construct the breakpoint
            PEImpl::PortType portTypeEnum;
            if (!portType.compare("i")) {
                portTypeEnum = PEImpl::INPUT;
            } else {
                portTypeEnum = PEImpl::OUTPUT;
            }
            ProbePointPtr probePoint(new BreakPoint(_probePointServices,
                                                    _probePointServices.getPeHandle(), opName,
                                                    portTypeEnum, portIndex));

            // Verify and construct predicate, if any
            if (predicate.size() > 0) {
                const Meta::TupleType& tuple = getTuple(*opProp, portTypeEnum, portIndex);
                ProbePointExpressionPredicatePtr pred;
                try {
                    pred = ProbePointExpressionPredicatePtr(
                      new ProbePointExpressionPredicate(predicate, tuple));
                } catch (const SPLRuntimeDebuggerErrorException& e) {
                    cerr << "Tracepoint not defined because of error in predicate:" << e.what()
                         << endl
                         << flush;
                    return;
                }
                if (!pred->valid()) {
                    cerr << "Breakpoint not defined because of error in predicate" << endl << flush;
                    return;
                } else {
                    probePoint->setPredicate(pred);
                }
            }

            // Add break point to list to be set
            probePoints.push_back(probePoint);
        }

        // All breakpoints constructed successfully, now set them all
        vector<ProbePointPtr>::iterator probePointIter;
        for (probePointIter = probePoints.begin(); probePointIter != probePoints.end();
             probePointIter++) {
            uint32_t id = _probePointServices.setBreakPoint(*probePointIter);
            if (disable) {
                _probePointServices.disableProbePoint(id);
            }
            printProbePointStatus(id, "Set");
        }
    } else if (!commandName.compare("p")) { /* set predicate for breakpoint or tracepoint */
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::SET_PREDICATE);
        string usage = iter->second;
        uint32_t probePointId;
        string predicate;

        if (!(inputCommand >> probePointId)) {
            cerr << "probe point id not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
            return;
        } else {
            char strbuf[2049];
            inputCommand.getline(strbuf, 2048);
            predicate = strbuf;
            predicate = trim(predicate);
        }

        ProbePointPtr probePoint = _probePointServices.getProbePoint(probePointId);
        if (probePoint == NULL) {
            cerr << "   Specified probe     point id does not exist! " << endl << flush;
            return;
        }
        if (!probePoint->isType("Breakpoint") && !probePoint->isType("Tracepoint")) {
            cerr
              << "   Specified probe point id does not correspond to a breakpoint or tracepoint! "
              << endl
              << flush;
            return;
        }

        if (predicate.length() > 0) {
            const Meta::TupleType& tuple =
              getTuple(_probePointServices.getPeHandle(), probePoint->getOperationName(),
                       probePoint->getPortType(), probePoint->getPortIndex());
            ProbePointExpressionPredicatePtr pred;
            try {
                pred = ProbePointExpressionPredicatePtr(
                  new ProbePointExpressionPredicate(predicate, tuple));
            } catch (const SPLRuntimeDebuggerErrorException& e) {
                cerr << "Tracepoint not defined because of error in predicate:" << e.what() << endl
                     << flush;
                return;
            }
            if (pred->valid()) {
                cout << "Predicate set for " << probePoint->getProbePointType() << ' '
                     << probePointId << " to eval(" << predicate << ")" << endl
                     << flush;
                probePoint->setPredicate(pred);
            } else {
                cerr << "Predicate not set for " << probePoint->getProbePointType() << ' '
                     << probePointId << " because of error" << endl
                     << flush;
            }
        } else {
            // Remove existing predicate, if any
            if (probePoint->getPredicate().get() != NULL) {
                cout << "Predicate removed for " << probePoint->getProbePointType() << ' '
                     << probePointId << endl
                     << flush;
                ProbePointExpressionPredicatePtr pred;
                probePoint->setPredicate(pred);
            } else {
                cerr << "Predicate not set for " << probePoint->getProbePointType() << ' '
                     << probePointId << " because no expression was specified" << endl
                     << flush;
            }
        }
    } else if (!commandName.compare("i")) { /* set injectpoint */
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::SET_INJECTPOINT);
        string usage = iter->second;
        string opName, portType;
        string portIndexString;

        if (!(inputCommand >> opName)) {
            cerr << "opName not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
            return;
        } else if (!(inputCommand >> portType)) {
            cerr << "port type (i or o) not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
            return;
        } else if (!(inputCommand >> portIndexString)) {
            cerr << "port index not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
            return;
        }

        const ApplicationModel model = _probePointServices.getApplicationModel();
        OperatorImpl* opProp = model.getOperator(opName);
        if (!opProp) {
            cerr << "Unknown operator '" << opName << '\'' << endl << flush;
            return;
        }

        // Add port indexes for breakpoint, where "*" implies all ports (input or output)
        vector<uint32_t> portIndexVector;
        if (!portIndexString.compare("*")) {
            uint32_t numPorts;
            if (!portType.compare("i")) {
                numPorts = opProp->getNumberOfInputPorts();
            } else {
                numPorts = opProp->getNumberOfOutputPorts();
            }
            for (uint32_t portIndex = 0; portIndex < numPorts; portIndex++) {
                portIndexVector.push_back(portIndex);
            }
        } else {
            // If a specific port was provided, add that one to the list.
            portIndexVector.push_back(atoi(portIndexString.c_str()));
        }

        vector<uint32_t>::iterator portIndexIter;
        for (portIndexIter = portIndexVector.begin(); portIndexIter != portIndexVector.end();
             portIndexIter++) {
            uint32_t portIndex = *portIndexIter;
            if (!isProbePointArgsValid(opName, "Injectpoint", portType, portIndex)) {
                return;
            }
            uint32_t id = _probePointServices.setInjectPoint(opName, portType, portIndex);
            printProbePointStatus(id, "Set");
        }
    } else if (!commandName.compare("t")) { /* set tracepoint  */
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::SET_TRACEPOINT);
        string usage = iter->second;
        string opName, portType;
        uint32_t portIndex;

        if (!(inputCommand >> opName)) {
            cerr << "opName not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
            return;
        } else if (!(inputCommand >> portType)) {
            cerr << "port type not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
            return;
        } else if (!(inputCommand >> portIndex)) {
            cerr << "port index not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
            return;
        } else if (!isProbePointArgsValid(opName, "Tracepoint", portType, portIndex)) {
            return;
        }

        string optionalArg;
        bool logStart = false;
        bool disable = false;
        uint32_t maxTuples = 0;
        string predicate;
        bool done = false;
        string digits = "0123456789";
        while (!done) {
            if (!(inputCommand >> optionalArg)) {
                done = true;
            } else {
                if (!optionalArg.compare("d")) {
                    disable = true;
                } else if (!optionalArg.compare("log")) {
                    logStart = true;
                } else if (optionalArg.find_first_not_of(digits) == string::npos) {
                    maxTuples = atoi(optionalArg.c_str());
                } else if (!optionalArg.compare("p")) {
                    char strbuf[2049];
                    inputCommand.getline(strbuf, 2048);
                    predicate = strbuf;
                    predicate = trim(predicate);
                    done = true;
                    if (predicate.size() == 0) {
                        cerr << "predicate option, p, specified without a predicate expression"
                             << endl
                             << flush;
                    }
                } else {
                    cerr << "unrecognized command option: '" << optionalArg << "'" << endl << flush;
                }
            }
        }

        // Construct the tracepoint
        PEImpl::PortType portTypeEnum;
        if (!portType.compare("i")) {
            portTypeEnum = PEImpl::INPUT;
        } else {
            portTypeEnum = PEImpl::OUTPUT;
        }
        TracePoint* tp = new TracePoint(_probePointServices, _probePointServices.getPeHandle(),
                                        opName, portTypeEnum, portIndex);
        ProbePointPtr tracePoint(tp);
        // Verify and construct predicate, if any
        if (predicate.size() > 0) {
            const Meta::TupleType& tuple =
              getTuple(_probePointServices.getPeHandle(), tracePoint->getOperationName(),
                       tracePoint->getPortType(), tracePoint->getPortIndex());
            ProbePointExpressionPredicatePtr pred;
            try {
                pred = ProbePointExpressionPredicatePtr(
                  new ProbePointExpressionPredicate(predicate, tuple));
            } catch (const SPLRuntimeDebuggerErrorException& e) {
                cerr << "Tracepoint not defined because of error in predicate:" << e.what() << endl
                     << flush;
                return;
            }
            if (!pred->valid()) {
                cerr << "Tracepoint not defined because of error in predicate" << endl << flush;
                return;
            } else {
                tracePoint->setPredicate(pred);
            }
        }

        if (maxTuples > 0) {
            tp->setMaxRecords(maxTuples);
        }

        uint32_t id = _probePointServices.setTracePoint(tracePoint);

        if (logStart) {
            _probePointServices.startLogging(id);
        }

        if (disable) {
            _probePointServices.disableProbePoint(id);
        }
        printProbePointStatus(id, "Set");
    } else if (!commandName.compare("s")) { /* show probepoint */
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::SHOW_TRACEPOINT);
        string usage = iter->second;
        uint32_t probePointId;
        string formatOption;

        if (!(inputCommand >> probePointId)) {
            cerr << "probe point id not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
            return;
        }
        if (inputCommand >> formatOption) {
            // if a format option is specified, test the option and output the corresponding format
            if (!(formatOption.compare("t"))) { // format as table
                _probePointServices.showProbePointRecords(probePointId);
            } else {
                cerr << "invalid format option" << endl << flush;
                cerr << "usage: " << usage << endl << flush;
                return;
            }
        } else {
            // Output the probe point using the default format
            _probePointServices.showProbePoint(probePointId);
        }
    } else if (!commandName.compare("l")) { /* list all probe points */
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::LIST_PROBEPOINTS);
        string usage = iter->second;

        printProbePoints();
    } else if (!commandName.compare("o")) { /* list operators */
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::LIST_OPERATORS);
        string usage = iter->second;

        string opName, portTypeStr, portIndexStr;
        PEImpl::PortType portType;

        inputCommand >> opName;
        inputCommand >> portTypeStr;
        inputCommand >> portIndexStr;

        if (opName.size() == 0) {
            printOperators();
            return;
        }

        unordered_map<string, OperatorImpl*> opPropMap;
        const ApplicationModel model = _probePointServices.getApplicationModel();
        model.getOperators(opPropMap);

        unordered_map<string, OperatorImpl*>::const_iterator opIter;
        opIter = opPropMap.find(opName);
        if (opIter == opPropMap.end()) {
            cerr << "operator named " << opName << " does not exist" << endl << flush;
            return;
        }
        OperatorImpl* opProp = opIter->second;

        if (portTypeStr.size() == 0) {
            // print all ports for the operator
            for (uint32_t i = 0; i < opProp->getNumberOfInputPorts(); i++) {
                printOperator(opName, PEImpl::INPUT, i);
            }
            for (uint32_t i = 0; i < opProp->getNumberOfOutputPorts(); i++) {
                printOperator(opName, PEImpl::OUTPUT, i);
            }
            return;
        }

        uint32_t numPorts;
        if (portTypeStr.compare("i") == 0) {
            portType = PEImpl::INPUT;
            numPorts = opProp->getNumberOfInputPorts();
        } else if (portTypeStr.compare("o") == 0) {
            portType = PEImpl::OUTPUT;
            numPorts = opProp->getNumberOfOutputPorts();
        } else {
            cerr << "invalid port type, must be \"i\" or \"o\"" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
            return;
        }

        if (portIndexStr.size() == 0 ||
            portIndexStr.find_first_not_of("0123456789") != string::npos) {
            cerr << "port index required when port type specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
            return;
        }
        uint32_t portIndex = atoi(portIndexStr.c_str());
        if (portIndex >= numPorts) {
            cerr << "port index is larger than number of ports for operator" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
            return;
        }
        printOperator(opName, portType, portIndex);
    } else if (!commandName.compare("r")) { /* remove a probe point */
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::REMOVE_PROBEPOINT);
        string usage = iter->second;
        string probePointId;

        if (!(inputCommand >> probePointId)) {
            cerr << "probe point id not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
        } else {
            if (probePointId.compare("*") == 0) {
                vector<uint32_t> ids;
                _probePointServices.getProbepoints(ids, NULL, NULL, NULL);
                vector<uint32_t>::const_iterator iter1;
                for (iter1 = ids.begin(); iter1 != ids.end(); iter1++) {
                    printProbePointStatus(*iter1, "Removing");
                    _probePointServices.remProbePoint(*iter1);
                }
            } else {
                uint32_t id = atoi(probePointId.c_str());
                _probePointServices.remProbePoint(id);
            }
        }
    } else if (!commandName.compare("e")) { /* enable probe point */
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::ENABLE_PROBEPOINT);
        string usage = iter->second;
        string probePointId;
        stringstream outputLine;

        if (!(inputCommand >> probePointId)) {
            cerr << "probe point id not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
        } else {
            if (probePointId.compare("*") == 0) {
                vector<uint32_t> ids;
                _probePointServices.getProbepoints(ids, NULL, NULL, NULL);
                vector<uint32_t>::const_iterator iter1;
                for (iter1 = ids.begin(); iter1 != ids.end(); iter1++) {
                    _probePointServices.enableProbePoint(*iter1);
                    printProbePointStatus(*iter1, "Enabled");
                }
            } else {
                uint32_t id = atoi(probePointId.c_str());
                _probePointServices.enableProbePoint(id);
            }
        }
    } else if (!commandName.compare("d")) { /* disable probe point */
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::DISABLE_PROBEPOINT);
        string usage = iter->second;
        string probePointId;
        stringstream outputLine;

        if (!(inputCommand >> probePointId)) {
            cerr << "probe point id not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
        } else {
            if (probePointId.compare("*") == 0) {
                vector<uint32_t> ids;
                _probePointServices.getProbepoints(ids, NULL, NULL, NULL);
                vector<uint32_t>::const_iterator iter1;
                for (iter1 = ids.begin(); iter1 != ids.end(); iter1++) {
                    _probePointServices.disableProbePoint(*iter1);
                    printProbePointStatus(*iter1, "Disabled");
                }
            } else {
                uint32_t id = atoi(probePointId.c_str());
                _probePointServices.disableProbePoint(id);
            }
        }
    } else if (!commandName.compare("u")) { /* update tuple value */
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::UPDATE_TUPLE);
        string usage = iter->second;
        string attributeName, attributeValue;
        bool goodOpts = true;
        uint32_t probepointId;
        bool probePointIdSpecified = false;

        vector<string> tokens;
        UTILS_NAMESPACE::tokenize(inputCommand.str(), tokens, " ", false);

        // 3 or more tokens implies that a probe point ID is included
        if (tokens.size() >= 4) {
            inputCommand >> probepointId;
            probePointIdSpecified = true;
        }

        if (!(inputCommand >> attributeName)) {
            cerr << "attribute name not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
            goodOpts = false;
        } else {
            char strbuf[1025];
            inputCommand.getline(strbuf, 1024);
            attributeValue = strbuf;
            attributeValue = trim(attributeValue);
            if (attributeValue.size() < 1) {
                cerr << "attribute value not specified" << endl << flush;
                cerr << "usage: " << usage << endl << flush;
                goodOpts = false;
            }
        }

        if (goodOpts) {
            if (probePointIdSpecified) {
                _probePointServices.updateTuple(attributeName, attributeValue, probepointId);
            } else {
                // Defaulted to the only stopped breakpoint
                _probePointServices.updateTuple(attributeName, attributeValue);
            }
        }
    } else if (!commandName.compare("x")) { /* drop tuple */
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::DROP_TUPLE);
        string usage = iter->second;
        string probePointId = "";
        uint32_t probePointId_int;
        bool probePointIdSpecified = false;
        bool probePointIdWildcardSpecified = false;

        // The user may specify a specific probe point id, all probe points ("*"), or
        // or no probe point, which implies a default probe point
        if (inputCommand >> probePointId) {
            if (!probePointId.compare("*")) {
                probePointIdWildcardSpecified = true;
            } else {
                probePointIdSpecified = true;
            }
        }

        if (!probePointIdSpecified) {
            vector<uint32_t> stoppedIds;
            _probePointServices.getProbepoints(stoppedIds, "Breakpoint", "stopped", "true");
            if (stoppedIds.size() == 0) {
                cerr << "   No breakpoint stopped; no tuples to drop!" << endl << flush;
            }

            // If a wildcard is not specified, drop the tuple associated with the
            // single stopped breakpoint, if any
            if (!probePointIdWildcardSpecified) {
                if (stoppedIds.size() > 1) {
                    cerr
                      << "   More than one breakpoint stopped.  Specify a breakpoint id, or a '*'"
                      << endl
                      << flush;
                    return;
                }
                probePointId_int = stoppedIds.front();
                ProbePointPtr probePoint = _probePointServices.getProbePoint(probePointId_int);
                BreakPoint& breakPoint = dynamic_cast<BreakPoint&>(*probePoint);
                // Toggle tuple drop state
                if (breakPoint.isCondition("dropped", "false")) {
                    breakPoint.setCondition("dropped", "true");
                    cout << "   Set tuple drop, breakpoint: " << probePointId_int << endl << flush;
                } else {
                    breakPoint.setCondition("dropped", "false");
                    cout << "   Reset tuple drop, breakpoint: " << probePointId_int << endl
                         << flush;
                }
                return;
            }

            // Otherwise, a wildcard was specified. Toggle drop tuple state for each stopped
            // breakpoint, if any
            vector<uint32_t>::const_iterator iter1;
            for (iter1 = stoppedIds.begin(); iter1 != stoppedIds.end(); iter1++) {
                uint32_t probePointId_int1 = *iter1;
                ProbePointPtr probePoint = _probePointServices.getProbePoint(probePointId_int1);
                BreakPoint& breakPoint = dynamic_cast<BreakPoint&>(*probePoint);
                // Toggle tuple drop state
                if (breakPoint.isCondition("dropped", "false")) {
                    breakPoint.setCondition("dropped", "true");
                    cout << "   Set tuple drop, breakpoint: " << probePointId_int1 << endl << flush;
                } else {
                    breakPoint.setCondition("dropped", "false");
                    cout << "   Reset tuple drop, breakpoint: " << probePointId_int1 << endl
                         << flush;
                }
            }
            return;
        }

        if (probePointIdSpecified) {
            probePointId_int = (uint32_t)atoi(probePointId.c_str());
            ProbePointPtr probePoint = _probePointServices.getProbePoint(probePointId_int);
            if (!probePoint->isType("Breakpoint")) {
                cerr << "   Specified probepoint id is does not correspond to a breakpoint! "
                     << endl
                     << flush;
                return;
            }
            BreakPoint& breakPoint = dynamic_cast<BreakPoint&>(*probePoint);
            if (breakPoint.isCondition("stopped", "false")) {
                cerr << "   Specified breakpoint is not stopped; no tuple to drop! " << endl
                     << flush;
                return;
            }
            // Toggle tuple drop state
            if (breakPoint.isCondition("dropped", "false")) {
                breakPoint.setCondition("dropped", "true");
                cout << "   Set tuple drop, breakpoint: " << probePointId_int << endl << flush;
            } else {
                breakPoint.setCondition("dropped", "false");
                cout << "   Reset tuple drop, breakpoint: " << probePointId_int << endl << flush;
            }
        }
    } else if (!commandName.compare("find")) { /* find field */
        string matchName;
        string matchType;
        if (!(inputCommand >> matchName)) {
            matchName = "*";
            matchType = "*";
        } else if (!(inputCommand >> matchType)) {
            matchType = "*";
        }

        ValueDefinitionVector fields;

        ValueDefinition::find(fields, _probePointServices, matchName, matchType);
        if (fields.size() == 0) {
            cerr << "No fields found matching name: '" << matchName << "' and type: '" << matchType
                 << "'" << endl
                 << flush;
            return;
        }

        ValueDefinitionVector::iterator iter;
        uint32_t maxLen = 0;
        for (iter = fields.begin(); iter != fields.end(); iter++) {
            if ((*iter)->getName().length() > maxLen) {
                maxLen = (*iter)->getName().length();
            }
        }
        stringstream outputLine;
        outputLine.setf(ios::left);
        for (iter = fields.begin(); iter != fields.end(); iter++) {
            outputLine << setw(maxLen) << (*iter)->getName() << " : " << setw(16)
                       << (*iter)->getType()->getName() << " defined for " << (*iter)->portString()
                       << endl
                       << flush;
            gl_display_and_flush_text(_gl, GL_INDENT_L2, NULL, NULL, ' ', 132, 0,
                                      outputLine.str().c_str());
            outputLine.str(string()); // Clear line
        }
    } else if (!commandName.compare("save")) { /* save */
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::SAVE);
        string usage = iter->second;
        uint32_t probePointId;

        if (!(inputCommand >> probePointId)) {
            cerr << "probe point id not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
        } else {
            char strbuf[1025];
            inputCommand.getline(strbuf, 1024);
            string fileName = strbuf;
            fileName = trim(fileName);
            if (fileName.size() < 1) {
                cerr << "filename not specified" << endl << flush;
                cerr << "usage: " << usage << endl << flush;
            } else {
                _probePointServices.saveProbePoint(probePointId, fileName);
            }
        }
    } else if (!commandName.compare("log")) { /* clear */
        CommandsUsageInfoType::const_iterator iter = _commandsUsageInfo.find(StandaloneClient::LOG);
        string usage = iter->second;
        string startStop;
        uint32_t probePointId;

        // If start / stop is not specified, assume start
        if (!(inputCommand >> probePointId)) {
            cerr << "probe point id not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
        } else if (!(inputCommand >> startStop)) {
            startStop = "start";
        }

        if (startStop.compare("start") == 0) {
            _probePointServices.startLogging(probePointId);
        } else if (startStop.compare("stop") == 0) {
            _probePointServices.stopLogging(probePointId);
        }
    } else if (!commandName.compare("clear")) { /* clear */
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::CLEAR);
        string usage = iter->second;
        uint32_t probePointId;

        if (!(inputCommand >> probePointId)) {
            cerr << "probe point id not specified" << endl << flush;
            cerr << "usage: " << usage << endl << flush;
        } else {
            _probePointServices.clearProbePoint(probePointId);
        }
    } else if (!commandName.compare("g")) { /* go */
        if (_probePointServices.isStartup()) {
            _probePointServices.signalStartup();
        } else {
            cerr << "command - " << commandName << " is not allowed, application is running."
                 << endl
                 << flush;
        }
    } else if (!commandName.compare("q") || !commandName.compare("quit")) { /* quit */
        if (_probePointServices.isStandaloneApplication()) {
            ::exit(0);
        } else {
            cerr << "the \"quit\" command is only allowed in standalone executable applications"
                 << endl
                 << flush;
            return;
        }
    } else if (!commandName.compare("savecfg")) { /* savecfg */
        string cfgName;
        if (!(inputCommand >> cfgName)) {
            cfgName = "default";
        } else {
            if (cfgName.find_first_not_of(
                  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_") !=
                string::npos) {
                cerr << "Configuration name specified is not valid" << endl << flush;
                return;
            }
        }

        _probePointServices.saveCfg(cfgName);
    } else if (!commandName.compare("loadcfg")) { /* loadcfg */
        string cfgName;
        if (!(inputCommand >> cfgName)) {
            cfgName = "default";
        } else {
            if (cfgName.find_first_not_of(
                  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_") !=
                string::npos) {
                cerr << "Configuration name specified is not valid" << endl << flush;
                return;
            }
        }

        _probePointServices.loadCfg(cfgName);
    } else if (!commandName.compare("setdbg")) { /* set */
        CommandsUsageInfoType::const_iterator iter =
          _commandsUsageInfo.find(StandaloneClient::SETDBG);
        string usage = iter->second;
        string name;
        string value;
        SdbConsoleLogger& consoleLogger = *(_probePointServices.getConsoleLogger());
        SdbConsoleTracer& consoleTracer = *(_probePointServices.getConsoleTracer());
        if (!(inputCommand >> name)) {
            cout << "loglevel: " << consoleLogger.getLevel() << '\n'
                 << "logformat: " << consoleLogger.getFormat() << '\n'
                 << "tracelevel: " << consoleTracer.getLevel() << '\n'
                 << "traceformat: " << consoleTracer.getFormat() << endl
                 << flush;
        } else {
            char strbuf[1025];
            inputCommand.getline(strbuf, 1024);
            value = strbuf;
            value = trim(value);
            if (name.compare("loglevel") == 0) {
                int logLevel = atoi(value.c_str());
                switch (logLevel) {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        consoleLogger.setLogLevel(logLevel);
                        cout << "loglevel set to " << logLevel << endl << flush;
                        break;
                    default:
                        cerr << "loglevel value is not valid" << endl << flush;
                        cerr << "usage: " << usage << endl << flush;
                }
            } else if (name.compare("logformat") == 0) {
                if (value.compare("log") == 0 || value.compare("syslog") == 0) {
                    consoleLogger.setFormat(value);
                    cout << "logformat set to " << value << endl << flush;
                } else {
                    cerr << "logformat value is not valid" << endl << flush;
                    cerr << "usage: " << usage << endl << flush;
                }
            } else if (name.compare("tracelevel") == 0) {
                int traceLevel = atoi(value.c_str());
                switch (traceLevel) {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        consoleTracer.setTraceLevel(traceLevel);
                        cout << "tracelevel set to " << traceLevel << endl << flush;
                        break;
                    default:
                        cerr << "tracelevel value is not valid" << endl << flush;
                        cerr << "usage: " << usage << endl << flush;
                }
            } else if (name.compare("traceformat") == 0) {
                if (value.compare("long") == 0 || value.compare("default") == 0 ||
                    value.compare("short") == 0) {
                    consoleTracer.setFormat(value);
                    cout << "traceformat set to " << value << endl << flush;
                } else {
                    cerr << "traceformat value is not valid" << endl << flush;
                    cerr << "usage: " << usage << endl << flush;
                }
            } else {
                cerr << "name of value to set is not valid" << endl << flush;
                cerr << "usage: " << usage << endl << flush;
            }
        }
    } else if (!commandName.compare("gdb")) { /* run GDB on operator */
        string debugArg, opName;
        uint32_t probePointId;
        int portIndex = -1;
        string gdbCommandFileName;

        CommandsUsageInfoType::const_iterator iter = _commandsUsageInfo.find(StandaloneClient::GDB);
        string usage = iter->second;

        // If start / stop is not specified, assume start
        if (inputCommand >> debugArg) {
            // If a debug argeument is alpha character, assume that it's the name of an operator.
            // Otherwise, assume it's a probe point ID
            if (isalpha((debugArg.c_str())[0])) {
                opName = debugArg;
                // Verify that opName is valid
                const ApplicationModel model = _probePointServices.getApplicationModel();
                OperatorImpl* opProp = model.getOperator(opName);
                if (opProp == NULL) {
                    cerr << "operation " << opName << " not defined!" << endl << flush;
                    cerr << "usage: " << usage << endl << flush;
                    return;
                }
                if (!createGdbCommands(opName, gdbCommandFileName)) {
                    cerr << "usage: " << usage << endl << flush;
                    return;
                }
                portIndex = -1; // No port index specified
            } else {
                probePointId = (uint32_t)atoi(debugArg.c_str());
                ProbePointPtr probePoint = _probePointServices.getProbePoint(probePointId);
                if (!createGdbCommands(probePoint, gdbCommandFileName)) {
                    cerr << "usage: " << usage << endl << flush;
                    return;
                }
                portIndex = (int)probePoint->getPortIndex();
                opName = probePoint->getOperationName();
            }
        } else {
            // if no GDB args are specified, attempt to activate GDB on the operator
            // corresponding to the default SDB breakpoint, if there is one.
            vector<uint32_t> stoppedIds;
            _probePointServices.getStoppedBreakpoints(stoppedIds);
            int numStopped = stoppedIds.size();
            if (numStopped == 1) {
                probePointId = stoppedIds.front();
            } else if (numStopped == 0) {
                cerr << "No breakpoints are defined, a break point ID must be specified" << endl
                     << flush;
                cerr << "usage: " << usage << endl << flush;
                return;
            } else {
                cerr << "More than one breakpoint is stopped. Select a specific breakpoint" << endl
                     << flush;
                cerr << "usage: " << usage << endl << flush;
                return;
            }
            ProbePointPtr probePoint = _probePointServices.getProbePoint(probePointId);
            if (!createGdbCommands(probePoint, gdbCommandFileName)) {
                cerr << "usage: " << usage << endl << flush;
                return;
            }
            portIndex = (int)probePoint->getPortIndex();
            opName = probePoint->getOperationName();
        }

        // Get the path + filename of this program's executable.
        string exeDirPath, exeFileName;
        getExecutableLocation(exeDirPath, exeFileName);
        string fqPathExeFileName = exeDirPath + exeFileName;

        stringstream debugCommand;
        // Invoke the debugger in an xterm.  Pass the name of the command file containing the GDB
        // breakpoint definition
        debugCommand << "xterm -T " << opName << "." << portIndex << " -e gdb -x "
                     << gdbCommandFileName << ' ' << fqPathExeFileName << ' ' << getpid() << " &";

        SPCDBG(L_DEBUG, "launching: " + debugCommand.str(), SPL_APP_DBG);
        system(debugCommand.str().c_str());
    } else {
        cerr << "command - " << commandName << " not recognized" << endl << flush;
        cerr << "enter \"h\" for help" << endl << flush;
    }
}
