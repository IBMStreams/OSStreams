/*
 * Copyright 2021 IBM Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ibm.streams.spl.internal.tkindexer;

import com.ibm.streams.operator.Type.MetaType;
import java.io.File;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import javax.naming.InvalidNameException;

/**
 * Abstract class for the toolkit indexer Java annotation processor to process a specific type of
 * annotation.
 */
public abstract class AbstractAnnotationProcessor {

  private String classContainerRelPath;
  private String classErrorContext;
  private String classOrigName;
  private String classRelClasspath;
  private String toolkitName;
  private String toolkitVersion;
  private File toolkitRootDir;
  private int errorCount;
  private List<File> filesToRemoveOnError = new ArrayList<File>();

  /*
   * --- Methods to be implemented per annotation type. ---
   */

  /** Initialize. */
  public abstract void initialize() throws Exception;

  /** Process annotations in the specified class. */
  public abstract void process(Class<?> cls) throws Exception;

  /** Finish processing (called after all classes have been processed). */
  public abstract void complete() throws Exception;

  /*
   * --- Utility methods to be used by specific implementations. ---
   */

  /** Get name of (original, not shadow) class being processed. */
  public final String getClassOrigName() {
    return classOrigName;
  }

  /** Get relative pathname of file used to load a class (for user output). */
  public final String getClassContainerRelPath() {
    return classContainerRelPath;
  }

  /** Get classpath relative to toolkit root dir to load the current class. */
  public final String getClassRelClasspath() {
    return classRelClasspath;
  }

  /** Get "do not edit this file" string */
  public String getDoNotEditThisFileString() {
    return "DO NOT EDIT THIS FILE - it is machine generated";
  }

  /** Get a description of the class source used for generating output. */
  public String getGeneratedFromString() {
    return "Generated from "
        + getClassOrigName()
        + " in "
        + getClassContainerRelPath()
        + " at "
        + (new Date()).toString();
  }

  /** Get toolkit name. */
  public final String getToolkitName() {
    return toolkitName;
  }

  /** Get toolkit root directory. */
  public final File getToolkitRootDir() {
    return toolkitRootDir;
  }

  /** Get toolkit version. */
  public final String getToolkitVersion() {
    return toolkitVersion;
  }

  /** Return true if Java data type maps to an unsigned SPL type. */
  public static final boolean javaMapsToUnsignedSPLType(Class<?> cls) {
    if (cls.equals(byte.class)
        || cls.equals(byte[].class)
        || cls.equals(short.class)
        || cls.equals(short[].class)
        || cls.equals(int.class)
        || cls.equals(int[].class)
        || cls.equals(long.class)
        || cls.equals(long[].class)) return true;
    return false;
  }

  /** Convert Java data type to name used for JNI "Call<type>Method" call. */
  public static final String javaMethodReturnType(Class<?> cls) throws InvalidNameException {
    if (cls.equals(void.class)) return "Void";
    if (cls.equals(boolean.class)) return "Boolean";
    if (cls.equals(byte.class)) return "Byte";
    if (cls.equals(short.class)) return "Short";
    if (cls.equals(int.class)) return "Int";
    if (cls.equals(long.class)) return "Long";
    if (cls.equals(float.class)) return "Float";
    if (cls.equals(double.class)) return "Double";
    if (cls.equals(String.class) || cls.isArray()) return "Object";
    throw new InvalidNameException("Unsupported data type '" + cls.toString() + "'.");
  }

  /** Convert Java data type to C++ native type */
  public static final String javaToCppType(Class<?> cls) throws InvalidNameException {
    if (cls.equals(boolean.class)) return "jboolean";
    if (cls.equals(byte.class)) return "jbyte";
    if (cls.equals(short.class)) return "jshort";
    if (cls.equals(int.class)) return "jint";
    if (cls.equals(long.class)) return "jlong";
    if (cls.equals(float.class)) return "jfloat";
    if (cls.equals(double.class)) return "jdouble";
    if (cls.equals(String.class) || cls.isArray()) return "jobject";
    throw new InvalidNameException("Unsupported data type '" + cls.toString() + "'.");
  }

  /** Convert Java data type to SPL type using modes for resolution. */
  public static final String javaToSPLType(Class<?> cls, MetaType mode, boolean signedMode)
      throws InvalidNameException {
    if (cls.isArray())
      return "list<" + javaToSPLType(cls.getComponentType(), mode, signedMode) + ">";
    if (cls.equals(void.class)) return "void";
    if (cls.equals(boolean.class)) return MetaType.BOOLEAN.getLanguageType();
    if (cls.equals(byte.class)) {
      if (signedMode) return MetaType.INT8.getLanguageType();
      else return MetaType.UINT8.getLanguageType();
    }
    if (cls.equals(short.class)) {
      if (signedMode) return MetaType.INT16.getLanguageType();
      else return MetaType.UINT16.getLanguageType();
    }
    if (cls.equals(int.class)) {
      if (signedMode) return MetaType.INT32.getLanguageType();
      else return MetaType.UINT32.getLanguageType();
    }
    if (cls.equals(long.class)) {
      if (signedMode) return MetaType.INT64.getLanguageType();
      else return MetaType.UINT64.getLanguageType();
    }
    if (cls.equals(float.class)) return MetaType.FLOAT32.getLanguageType();
    if (cls.equals(double.class)) return MetaType.FLOAT64.getLanguageType();
    if (cls.equals(String.class) && (mode == MetaType.USTRING || mode == MetaType.RSTRING))
      return mode.getLanguageType();
    throw new InvalidNameException(
        "Unsupported data type '" + cls.toString() + "' for mode '" + mode + "'.");
  }

  /** Convert Java data type to Java VM type signature. */
  public static final String javaTypeSig(Class<?> cls) throws InvalidNameException {
    if (cls.isArray()) return "[" + javaTypeSig(cls.getComponentType());
    if (cls.equals(void.class)) return "V";
    if (cls.equals(boolean.class)) return "Z";
    if (cls.equals(byte.class)) return "B";
    if (cls.equals(short.class)) return "S";
    if (cls.equals(int.class)) return "I";
    if (cls.equals(long.class)) return "J";
    if (cls.equals(float.class)) return "F";
    if (cls.equals(double.class)) return "D";
    if (cls.equals(String.class)) return "Ljava/lang/String;";
    throw new InvalidNameException("Unsupported data type '" + cls.toString() + "'.");
  }

  /**
   * Add file to a list of files to be removed on error clean up.
   *
   * <p>If the file is already present, it is not added. If the file does not exist on clean up, it
   * is ignored. Files will be removed in reverse order on error clean up.
   */
  public final void fileToRemoveOnError(File file) {
    filesToRemoveOnError.add(file);
  }

  /** Create directories if needed that will be removed on error clean up. */
  public final void mkdirs(File dir) {
    if (!dir.exists()) {
      mkdirs(dir.getParentFile());
      fileToRemoveOnError(dir);
      dir.mkdir();
    }
  }

  /** Return true if errors were encountered during processing. */
  public final boolean hasErrors() {
    return (errorCount > 0);
  }

  /** Report error found in the current class and continue processing. */
  public final void reportClassError(String message) {
    reportError(classErrorContext + ": " + message);
  }

  /** Report error and continue processing. */
  public final void reportError(String message) {
    System.err.println("Error: " + message);
    errorCount++;
  }

  /*
   * --- Methods called from elsewhere for setup and processing. ---
   */

  /** Perform clean up prior to any error termination. */
  public final void cleanOnError() {
    for (int i = filesToRemoveOnError.size() - 1; i >= 0; i--) {
      filesToRemoveOnError.get(i).delete();
    }
  }

  /** Return number of errors encountered during processing. */
  public final int numErrors() {
    return errorCount;
  }

  /** Set name of (original, not shadow) class being processed. */
  public final void setClassOrigName(String name) {
    classOrigName = name;
  }

  /** Set relative pathname of file used to load a class (for user output). */
  public final void setClassContainerRelPath(String path) {
    classContainerRelPath = path;
  }

  /** Set classpath relative to toolkit root dir to load the current class. */
  public final void setClassRelClasspath(String path) {
    classRelClasspath = path;
  }

  /** Set where a class was defined for reporting errors in the class. */
  public final void setClassErrorContext(String context) {
    classErrorContext = context;
  }

  /** Set toolkit name. */
  public final void setToolkitName(String name) {
    toolkitName = name;
  }

  /** Set toolkit root directory. */
  public final void setToolkitRootDir(File path) {
    toolkitRootDir = path;
  }

  /** Set toolkit version. */
  public final void setToolkitVersion(String version) {
    toolkitVersion = version;
  }
}
