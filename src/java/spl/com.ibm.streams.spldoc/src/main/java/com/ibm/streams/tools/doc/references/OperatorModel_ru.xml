<?xml version="1.0" encoding="UTF-8" ?>
<reference id="spldoc_reference_operator_model">
<title>Модель оператора SPL</title>
<refbody>
<section id="overview">
<p>
Модель оператора можно использовать для описания примитивного оператора C++ или примитивного оператора Java. Набор элементов, которые могут присутствовать в модели оператора Java - это строгое подмножество элементов, которые могут присутствовать в
модели оператора C++, кроме специального элемента, используемого для конфигураций, связанных с JVM.
</p>
</section>
<section id="context">
<title outputclass="splhead-1">Сведения</title>
<p>
Элемент контекста описывает свойства, относящиеся к оператору в целом и не связанные с отдельными параметрами или портами оператора. Он также содержит общие определения, ссылки на которые есть в других местах в модели оператора.
</p>
<dl>
  <dlentry id="context__description">
    <dt>Описание</dt>
    <dd>Элемент описания, который является необязательным и содержит обзор оператора.</dd>
  </dlentry>
  <dlentry id="context__metrics">
    <dt>Показатели</dt>
    <dd>Элемент показателей, который является необязательным и содержит список показателей, открываемых оператором.
Он структурирован как список элементов показателей, где каждый элемент показателя содержит имя, описание и вид.
      <dl>
        <dlentry id="context__metrics_kind_counter">
          <dt>Вид: Счетчик</dt>
          <dd>Соответствует показателям, значения которых либо не уменьшаются, либо не увеличиваются.
          </dd>
        </dlentry>
        <dlentry id="context__metrics_kind_gauge">
          <dt>Вид: Индикатор</dt>
          <dd>Соответствует показателям, значения которых могут свободно изменяться, то есть, могут возрастать или снижаться.
          </dd>
        </dlentry>
        <dlentry id="context__metrics_kind_time">
          <dt>Вид: Время</dt>
          <dd>Соответствует показателям, обозначающим точку во времени.
          </dd>
        </dlentry>
      </dl>
    </dd>
  </dlentry>
  <dlentry id="context__customliterals">
    <dt>Пользовательские литералы</dt>
    <dd>Элемент customLiterals, который является необязательным, захватывает идентификаторы, которые могут появляться в конфигурациях параметра оператора. Он структурирован как список элементов нумерации. Например, оператор Source может поддерживать другие исходные форматы; в этом случае у нас может
быть нумерация FileFormat, содержащая значения <tt>{csv, xml, bin}</tt>.
    </dd>
  </dlentry>
  <dlentry id="context__customoutputfunctions">
    <dt>Пользовательские выходные функции (только C++)</dt>
    <dd>Элемент customOutputFunctions, который является необязательным, захватывает прототипы выходных функций, используемые оператором в его
назначениях выходных атрибутов. Он структурирован как список элементов customOutputFunction, где каждая нумерация содержит имя и список прототипов
выходных функций. Например, оператор Aggregate может поддерживать реляционные агрегации; в этом случае у нас может быть
нумерация RelationalAggs, которая будет содержать выходные функции
<tt>{Min, Max, Avg, Sum и т.д.}</tt>.
    </dd>
  </dlentry>
  <dlentry id="context__dependencies">
    <dt>Зависимости (необязательно)</dt>
    <dd>Последовательность одного или нескольких элементов библиотеки, каждый из которых представляет зависимость библиотеки.
Формат элемента
библиотеки точно такой же, какой используется для моделей оператора.
     <dl>
        <dlentry id="context__dependencies__description">
          <dt>Описание (необязательно)</dt>
          <dd>Описание библиотеки.
          </dd>
        </dlentry>
        <dlentry id="context__dependencies__managedlibrary">
          <dt>Управляемая библиотека</dt>
          <dd>Задает подробности отдельных артефактов библиотеки. Пути могут содержать переменные среды, заключенные между символами @ (например: <tt>@FOO_FFT_HOME@/lib</tt>), которые будут полностью разрешены компилятором SPL во время компиляции.
            <dl>
              <dlentry id="context__dependencies__managedlibrary__lib">
                <dt>lib (необязательно)</dt>
                <dd>Задает имя для передачи в аргумент компилятора C++ <tt>-l</tt> (например, <tt>fft</tt> который будет переведен в <tt>-lfft</tt> при
передаче компоновщику)
                </dd>
              </dlentry>
              <dlentry id="context__dependencies__managedlibrary__libpath">
                <dt>libPath (необязательно)</dt>
                <dd>Задает путь для передачи в аргумент компилятора C++ <tt>-L</tt>.
                </dd>
              </dlentry>
              <dlentry id="context__dependencies__managedlibrary__includepath">
                <dt>includePath (необязательно)</dt>
                <dd>Задает путь для передачи в аргумент компилятора C++ <tt>-I</tt>.
                </dd>
              </dlentry>
              <dlentry id="context__dependencies__managedlibrary__command">
                <dt>command (необязательно)</dt>
                <dd>Путь программы, которая будет выполняться для получения информации <tt>includePath, libPath</tt> и <tt>lib</tt>. Если путь программы является относительным, будет считаться, что его корнем является каталог модели оператора. Программа выполняется трижды, каждый раз с разными аргументами, а именно: <tt>lib,
libPath</tt> и <tt>includePath</tt>. 1 Стандартная выходная информация от ее выполнений будет прочитана, и каждая строка (усеченная или с пробелами)
будет добавлена в один из элементов <tt>lib,
libPath</tt>и <tt>includePath</tt> в зависимости от типа выполнения. Строка, начинающаяся с #, будет проигнорирована. Будет считаться, что корнем относительных путей является каталог, в котором находится XML-документ модели оператора.
                </dd>
              </dlentry>
            </dl>
          </dd>
        </dlentry>
    </dl>
    </dd>
  </dlentry>
  <dlentry id="context__providessinglethreadedexecutioncontext">
    <dt>Обеспечивать контекст выполнения одного потока (только C++)</dt>
    <dd><p>Элемент <tt>providesSingleThreadedContext</tt> описывает семантику потоков оператора относительно потока выполнения. Оператор предоставляет контекст выполнения одного потока, если и только если:
      <ul>
        <li>Он не выполняет параллельных вызовов передачи, если его методы обработки вызваны одновременно.</li>
        <li>Его вызовы по обработке завершаются до завершения вызова процесса, который инициировал передачу.</li>
      </ul>
    </p>
    <p>Как у исходного, так и не у исходного оператора есть методы процессов, и вышеуказанное определение применяется на глобальном уровне. Исходя из этого определения, если у оператора есть вызовы передачи, не инициированные вызовом процесса, например, те, которые инициированы событием
на основе времени, этот оператор не предоставляет контекст выполнения одного потока. Учтите, что этому определению не требуется вызов передачи,
который нужно выполнить в рамках того же потока, который выполняет вызов процесса, инициирующий передачу (даже при том, что
в общем случае они выполняются в рамках одного и того же потока).
    </p>
    <p>Есть несколько допустимых значений для этого свойства:
<ul>
  <li><tt>Never:</tt> Экземпляры этого оператора никогда не предоставляют контекст выполнения одного потока.</li>
  <li><tt>Always:</tt> Экземпляры этого оператора всегда предоставляют контекст выполнения одного потока.</li>
  <li><tt>WindowBound:</tt> Экземпляры этого оператора, которые не задают политики замещения окна на основе времени или инициирования окна на основе
времени, предоставляют контекст выполнения одного потока.</li>
  <li><tt>WindowEvictionBound:</tt> Экземпляры этого оператора, которые не задают политики замещения окна на основе времени, предоставляют
контекст выполнения одного потока.</li>
  <li><tt>WindowTriggerBound:</tt> Экземпляры этого оператора, которые не задают политики инициирования окна на основе времени, предоставляют
контекст выполнения одного потока.</li>
  <li><tt>WindowPartitionEvictionBound:</tt> Экземпляры этого оператора используют поток для реализации замещения раздела. Используйте этот параметр, если кортежи переданы от события onWindowPartitionEvictionSelection.</li>
</ul>
    </p>
<p>
В качестве примера рассмотрим оператор <tt>Filter</tt>. Если этот метод процесса не вызван параллельно, оператор <tt>Filter</tt> не создаст
параллельных вызовов передачи. Его вызовы передачи инициируются поступающими кортежами. Если он получает кортеж через вызов процесса, он создает вызов передачи, если полученный кортеж пройдет условие фильтра, и этот вызов передачи
завершится до завершения вызова процесса, который его инициировал. В результате этого все экземпляры оператора <tt>Filter</tt> обеспечат
контекст одного потока, и подойдет параметр <tt>Always</tt>.
</p>
<p>
Замечание по реализации: Элемент <tt>providesSingleThreadedContext</tt> используется, чтобы разрешить среде выполнения SPL избегать
ненужной синхронизации потоков. В то время, как значение Never является безопасным для всех операторов, оно бы воспрепятствовало оптимизации, которая сокращает служебную
нагрузку по синхронизации, когда оператор предоставляет контекст одного потока. Если задать какое-либо значение, кроме Never, которое противоречит семантике потоков, реализуемой операторами, это приведет к неопределенному поведению.
</p>
    </dd>
  </dlentry>
  <dlentry id="context__incrementalcompilationstrategy">
    <dt>Стратегия инкрементной компиляции (только C++)</dt>
    <dd><p>Указывает, как компилятор должен управлять инкрементной компиляцией операторов. Возможные варианты:
       <ul>
         <li><tt>SourceDependent</tt>: В этом режиме компилятор только перегенерирует источник оператора, если он устарел, используя
источник SPL или генератор кода для этого оператора. Это режим по умолчанию.</li>
         <li><tt>ResultDependent:</tt> В этом режиме компилятор всегда генерирует источник оператора, но исходные файлы обновляются, только если они
отличаются от того, что существовало до компиляции. Используйте этот режим, если генератор кода оператора основывается на внешних конфигурациях, не охваченных параметризацией, заданной в
источнике SPL.
         </li>
       </ul>
    </p></dd>
   </dlentry>
   <dlentry id="context__allowCustomLogic">
    <dt>Разрешить пользовательскую логику (только C++)</dt>
    <dd><p>Этот необязательный элемент указывает, разрешено ли, чтобы при использовании оператора было логическое условие, задающее любое
состояние, обработку <tt>onTuple</tt> или <tt>onPunct</tt>. Если задано значение false, никакого логического условия задать для данного оператора нельзя. Значение по умолчанию, когда этот элемент отсутствует - true.
    </p></dd>
   </dlentry>
   <dlentry id="context__codetemplate">
    <dt>Шаблон кода</dt>
    <dd><p>Этот необязательный элемент задает один или несколько шаблонов кода для оператора.
Они появляются во вспомогательных контекстных меню IDE и документах SPLDOC.
У каждого шаблона кода есть атрибут имени, присваивающий ему имя, элемент описания, который его описывает, и элемент значения, представляющий
собой строку, содержащую стереотипный код для шаблона.
Если шаблон используется в IDE, стереотипный код встраивается в исходный код.
Части кода, не представленные в формате ${name}, используются, чтобы указать фрагменты, которые должен настроить пользователь. IDE будет использовать идентификатор, заданный внутри ${}, чтобы указать настраиваемые части. Одним из примеров оператора Barrier является следующее:
</p>
<p>
<!-- START NON-TRANSLATABLE -->
<codeblock>
&lt;codeTemplates>
  &lt;codeTemplate name="Barrier">
    &lt;description>Basic Barrier template&lt;/description>
    &lt;template>
      &lt;![CDATA[
        stream&lt;${schema}> ${outputStream} = Barrier(${inputStream1};${inputStream2})
        {
          param
            ${parameter}: ${parameterExpression};
          output
            ${outputStream}: ${outputExpression};
          ${cursor}
        }
      ]]&gt;
    &lt;template>
  &lt;/codeTemplate>
&lt;/codeTemplates>
</codeblock>
<!-- END NON-TRANSLATABLE -->
    </p></dd>
   </dlentry>
   <dlentry id="context__splexpressiontree">
    <dt>Дерево выражений SPL (только C++)</dt>
    <dd><p>Необязательный элемент, который управляет генерированием деревьев выражений SPL для использования в общих примитивных оператораъ C++.</p>
      <ul>
      <li><tt>param</tt> - Если задано <tt>true</tt>, деревья выражений SPL генерируются для параметров.</li>
      <li><tt>output</tt> - Если задано <tt>true</tt>, деревья выражений SPL генерируются для выходных данных.</li>
      <li><tt>cppCode</tt> - Если задано <tt>true</tt>, каждый узел в сгенерированном XML экземпляра оператора расширяется за счет кода C++ с
использованием шаблонов.
Этот код C++ можно использовать, чтобы сгенерировать код C++ для выражения SPL. Например, для кода SPL:
<p>
<codeblock>
param predicates : {a = "a" == In.letter, b = "b" == In.letter};
</codeblock>
</p>
<p>
Сгенерированное дерево выражений SPL включает в себя:
</p>
<p>
<!-- START NON-TRANSLATABLE -->
<codeblock>
&lt;expressionTree cppCode="SPL::BeJwrMUoyTEwyTAIAC7UCCQ({attr:0}, {attr:1})">
  &lt;literal cppCode="SPL::BeJwrMUoyTEwyTAIAC7UCCQ({attr:0}, {attr:1})" type="1">
    &lt;tuple count="2" cppCode="SPL::BeJwrMUoyTEwyTAIAC7UCCQ({attr:0}, {attr:1})" type="1">
      &lt;attr id="a">
        &lt;value cppCode="({Lhs} == {Rhs})" type="2">
          &lt;expn cppCode="({Lhs} == {Rhs})">
            &lt;binary cppCode="({Lhs} == {Rhs})" op="==" type="2">
              &lt;lhs cppCode="SPL::rstring("a")">
                &lt;literal cppCode="SPL::rstring("a")" type="0">"a"&lt;/literal>
              &lt;/lhs>
              &lt;rhs cppCode="iport$0.get_letter()">
                &lt;attribute attribute="letter" cppCode="iport$0.get_letter()" type="0">
                  &lt;lhs cppCode="iport$0">
                    &lt;stream cppCode="iport$0" name="In" port="0" type="3"/>
                  &lt;/lhs>
                &lt;/attribute>
              &lt;/rhs>
            &lt;/binary>
          &lt;/expn>
        &lt;/value>
      &lt;/attr>
</codeblock>
<!-- END NON-TRANSLATABLE -->
</p>
<p>
Шаблоны (например, <tt>{Lhs}, {attr:0}</tt>) используются, чтобы гарантировать правильное определение замещения кода.
</p>
<p>
Эти выражения соответствуют выражениям SPL, но они доступны в формате, который легко понять.
Объекты Perl берутся из <tt>SPL::Operator::Instance::ExpressionTree</tt>, и у них есть вид, тип и методы для получения доступа к полям выражения. <tt>ExpressionTreeVisitor</tt> - это шаблон посетителя, предоставляемый, чтобы обеспечить
удобное перемещение по дереву выражений. Дополнительную информацию смотрите в книге
<i>Документация по API генерирования кода языка для обработки IBM Streams</i>.
</p>
      </li>
      </ul>
    </dd>
   </dlentry>
   <dlentry id="context__capability">
    <dt>Возможности операционной системы (только C++)</dt>
    <dd><p>Этот необязательный список элементов задает особые полномочия для оператора. IBM Streams поддерживает модель возможностей Linux с использованием элемента возможностей. Можно включить любое число элементов, чтобы задать точные полномочия, которых требуются оператору. Например,
<tt>&lt;capability&gt;CAP_NET_RAW+eip&lt;/capability&gt;</tt>
указывает, что оператору нужно разрешение на доступ к неструктурированным гнездам. Учтите, что экземпляр IBM Streams необходимо сконфигурировать, так чтобы разрешить процессам PE выполняться с использованием специальных
возможностей операционной системы.
    </p></dd>
   </dlentry>
</dl>
</section>

<section id="input_port_set">
<title outputclass="splhead-1">Набор входных портов</title>
<p>
Входные порты заданы с точки зрения наборов портов. Набор портов - это фиксированное число портов, которые совместно используют одну и ту же конфигурацию.
Это позволяет избежать повторения одной и той же конфигурации для разных портов. Набор портов можно открыть, и в этом случае он может содержать ноль или более портов с такой же конфигурацией. Элемент inputPorts содержит ноль или более элементов inputPortSet, после которых идет необязательный элемент inputPortOpenSet.
</p>
<dl>
  <dlentry id="input_port_set__cardinality">
    <dt>Мощность</dt>
    <dd>Задает число портов, которые представляет набор портов. Это свойство применяется к неоткрытым наборам портов.
    </dd>
  </dlentry>
  <dlentry  id="input_port_set__optional">
    <dt>Необязательный</dt>
    <dd>Логическое значение, указывающее, является ли набор входных портов необязательным.
    </dd>
  </dlentry>
    <dlentry  id="input_port_set__controlport">
    <dt>Управляющий порт</dt>
    <dd>Необязательный элемент controlPort сообщает компилятору, что кортежи, полученные на этом порту, будут использоваться только для управления
оператором, и никакие кортежи не будут передаваться при обработке кортежей на этом порту.
Если значение не указано, принимается false. Компилятор SPL выдает предупреждения, если в на графике оператора будут найдены циклы, так как это может
привести к тупиковой ситуации или бесконечному повторению. Если задать для controlPort значение true, компилятору будет сообщено, что данный порт не будет передавать дальнейшие кортежи, и это является
ожидаемым (и безопасным) циклом обратной связи, поэтому никакого предупреждения для этого порта выдано не будет.
   </dd>
  </dlentry>
  <dlentry id="input_port_set__windowingmode">
    <dt>Режим работы с окнами</dt>
    <dd>Элемент windowingMode задает действительные конфигурации работы с окнами для порта. Опции включают в себя NonWindowed, Windowed и OptionallyWindowed.
   </dd>
  </dlentry>
  <dlentry id="input_port_set__windowpunctuationinputmode">
    <dt>Входной режим прерываний окна</dt>
    <dd>
Элемент windowPunctuationInputMode задает семантику прерываний для входного порта. Допустимые опции:
<ul>
<li><tt>Expecting</tt> - Этот порт ожидает прерывания окна, чтобы оператор функционировал правильно и, таким образом, был передан в прерывающийся
поток.</li>
<li><tt>Oblivious</tt> - Этому порту не требуются прерывания, чтобы оператор работал правильно; таким образом нет никаких ограничений соединений,
которые могут быть с ним связаны.</li>
<li><tt>WindowBound</tt> - Это ожидающий порт (Expecting), если у него есть окно на основе прерываний; в противном случае это будет забытый порт (Oblivious).</li>
</ul>
   </dd>
  </dlentry>
  <dlentry id="input_port_set__windowexpressionmode">
    <dt>Режим выражения окна</dt>
    <dd>Этот элемент сообщает компилятору, какой тип выражений окна допускается. Если не задано, то значение по умолчанию: <tt>Константа</tt>.
    <ul>
      <li><tt>Константа</tt> - Выражения в <tt>count</tt>, <tt>time</tt> и <tt>delta</tt> должны быть константами, которые можно оценить во
время компилирования, или, если выражения среды выполнения, которые не ссылаются на входные атрибуты кортежа, являются действительными.</li>
      <li><tt>AttributeFree</tt> - Выражения не должны ссылаться на входные атрибуты кортежа. Можно использовать такие выражения, как время
<tt>((int32) getSubmissionTimeValue("timeParam"))</tt>. В случае разницы выражением, свободным от атрибутов среды выполнения, может быть только
второй аргумент. Первый аргумент все еще является атрибутом из входного потока.</li>
    </ul>
   </dd><!-- windowexpressionmode -->
  </dlentry>
  <dlentry id="input_port_set_rewriteallowedforwindowexpression">
    <dt>Перезапись разрешена для выражения окна (только C++)</dt>
    <dd>Если задано значение true, этот логический элемент сообщает компилятору, что тот может переписать
выражение окна так же, как элемент <tt>rewriteAllowed</tt> перезаписывает выражения, появляющиеся в значениях параметра. Дополнительную информацию об элементе rewriteAllowed смотрите в разделе <tt>Параметры</tt>.
Если элемент <tt>rewriteAllowedForWindowExpression</tt> не задан, то в качестве значения по умолчанию используется значение false. <tt>rewriteAllowedForWindowExpression</tt> должно быть равно false (или этот
элемент должен быть пропущен), если примитивный оператор C++ хочет изучить значение как литерал.
    </dd>
  </dlentry>
  <dlentry id="input_port_set_tuplemutationallowed">
    <dt>Изменение кортежей разрешается</dt>
    <dd>Элемент tupleMutationAllowed указывает, будет ли логика обработки, связанная с входным портом (включая и логику, связанную с функциями
процесса оператора, и обработку, выполняемую как часть условий onTuple, заданных в коде SPL), изменять входной кортеж. Для него можно задать значение
true в случае операторов, которые хотят изменять полученные ими кортежи.
   </dd>
  </dlentry>
</dl>

</section>
<section  id="output_port_set">
  <title outputclass="splhead-1">Набор выходных портов</title>
  <p>
Выходные порты заданы с точки зрения наборов портов, точно так же, как и входные порты. Набор портов - это фиксированное число портов, которые совместно используют одну и ту же конфигурацию. Это позволяет избежать повторения одной и той же конфигурации для разных портов. Набор портов можно открыть, и в этом случае он может содержать ноль или более портов с такой же конфигурацией. Элемент outputPorts содержит ноль или более элементов outputPortSet, после которых идет необязательный элемент outputPortOpenSet.
  </p>
  <dl>
  <dlentry  id="output_port_set__cardinality">
    <dt>Мощность</dt>
    <dd>Задает число портов, которые представляет набор портов. Это свойство применяется к неоткрытым наборам портов.
    </dd>
  </dlentry>
  <dlentry id="output_port_set__optional">
    <dt>Необязательный</dt>
    <dd>Логическое значение, указывающее, является ли набор выходных портов необязательным.
    </dd>
  </dlentry>
    <dlentry id="output_port_set_expressionmode">
    <dt>Режим выражения (только C++)</dt>
    <dd>
Элемент expressionMode описывает допустимый синтаксис назначений атрибута, сделанных на этом порту.
Учтите, что значение CustomLiteral для expressionMode недопустимо для выходных портов и приведет к ошибке компиляции. Допустимые значения для режима выражения:
<ul>
<li><tt>Attribute:</tt> Означает, что назначения, сделанные для входных атрибутов этого порта, должны быть атрибутами потока. Например: вывод <tt>Out : x = In.y;</tt>, но не <tt>x = In.y.z</tt>.</li>
<li><tt>AttributeFree:</tt> Означает, что назначения, сделанные для входных атрибутов этого порта, не могут ссылаться ни на какие атрибуты входного потока. Например: вывод <tt>Out : x = 3 + random(3);</tt>, но не <tt>x = In.x + 3</tt>.</li>
<li><tt>Constant:</tt> Означает, что назначения, сделанные для входных атрибутов этого порта, должны оцениваться во время компилирования как
константа. Например: вывод <tt>Out : x = 3 + pow(2, 3);</tt>, но не <tt>x = random(3)</tt>.</li>
<li><tt>Expression:</tt> Это - наиболее гибкий режим выражения; любое выражение SPL правильного типа может появиться как назначение для
выходных атрибутов этого порта. Например: вывод<tt> Out : x = A.y + B.z;</tt>.</li>
<li><tt>Nonexistent:</tt> Означает, что назначения выходных атрибутов нельзя задать в источнике SPL для этого порта.</li>
</ul>
    </dd>
  </dlentry>
    <dlentry id="output_port_set__autoassignment">
    <dt>Автоназначение</dt>
    <dd>
Элемент <tt>autoAssignment</tt> указывает, будут ли неназначенные атрибуты автоматически назначаться на основе атрибутов входных портов.
Если задано значение true, компилятор SPL перезапишет (во время компиляции) вызов оператора, так чтобы у неназначенных выходных атрибутов были
явные назначения в разделе выходной информации. Для каждого выходного атрибута, у которого отсутствует назначение, будет назначен входной атрибут с
тем же именем и типом или с тем же именем и типом <tt>T</tt>, где типом выходного атрибута является <tt>optional&lt;T&gt;</tt>.
Если такого входного атрибута нет или если их несколько, то во время компилирования будет сообщено об ошибке. Учтите, что значение Constant для expressionMode несовместимо со значением true для autoAssignment.
Эта комбинация приведет к ошибке компиляции.
    </dd>
  </dlentry>
  <dlentry id="output_port_set__completeassignment">
    <dt>Полное назначение</dt>
    <dd>
Элемент <tt>completeAssignment</tt> указывает, нужно ли назначить все выходные атрибуты порта, чтобы получить действительный вызов
оператора. Это проверяется во время компиляции. Если у оператора этому элементу присвоено значение true в его модели оператора и если не у всех выходных
атрибутов есть назначения после шага автоматического назначения (если он затребован) для данного экземпляра этого оператора, будет сообщено об ошибке.
    </dd>
  </dlentry>
  <dlentry id="output_port_set__rewriteallowed">
    <dt>Перезапись позволена (только C++)</dt>
    <dd>
Элемент <tt>rewriteAllowed</tt> указывает, разрешено ли компилятору перезаписывать выражения, появляющиеся в назначениях выходных атрибутов
для этого порта.
    </dd>
  </dlentry>
  <dlentry id="output_port_set__outputfunctions">
    <dt>Функции вывода</dt>
    <dd>
Элемент outputFunctions задает действительные пользовательские выходные функции, которые могут появляться в назначениях выходных атрибутов.
Он является необязательным. Если он присутствует, он содержит два подэлемента: элемент типа, который задает имя
пользовательского типа выходной функции, как в RelationalAggs; и элемент по умолчанию, который задает выходную функцию по умолчанию, которую следует
использовать при выполнении автоматического назначения выходных атрибутов. Это значение должно быть действительным именем функции для
пользовательского типа выходной функции, который используется (как Last для RelationalAggs). Учтите, что если пользовательский код задает
назначение выходного атрибута без выходной функции для порта, который ожидает выходную функцию, выходная функция по умолчанию
будет вставлена автоматически.
    </dd>
  </dlentry>
    <dlentry id="output_port_set__finalpunctuationoutputscope">
    <dt>Область порта конечных прерываний</dt>
    <dd>
Элемент <tt>finalPunctuationPortScope</tt>, который является необязательным, задает набор входных портов, который должен использоваться
средой выполнения языка SPL для переадресации конечных прерываний. По умолчанию, операторы, у которых есть и входные, и выходные порты, автоматически
переадресовывают конечные прерывания со своих входных портов на свои выходные порты. Это достигается путем генерирования конечных прерываний на выходном порту, когда конечное прерывание будет получено на всех входных портах. Элемент finalPunctuationPortScope можно использовать, чтобы ограничить набор входных портов, которые будут
использоваться для переадресации конечных прерываний. Этот элемент также можно использовать, чтобы выключить автоматическую переадресацию конечных
прерываний, задав набор входных портов, которые следует использовать для переадресации в пустое множество. В этом случае разработчик оператора отвечает за то, чтобы гарантировать, что выходной порт получит конечное прерывание.
    </dd>
  </dlentry>
  <dlentry id="output_port_set__windowpunctuationoutputmode">
    <dt>Выходной режим прерываний окна</dt>
    <dd>
windowPunctuationOutputMode задает семантику прерываний окна для выходного порта. Возможные значения:
<ul>
<li><tt>Generating</tt> - Этот порт генерирует прерывания окна.</li>
<li><tt>Free</tt> - У этого порта нет прерываний окна.</li>
<li><tt>Preserving</tt> - Этот порт сохраняет полученные прерывания окна. Если у оператора более одного входного порта, нужно задать элемент
windowPunctuationInputPort, чтобы указать, для каких входных портов сохраняются прерывания.</li>
</ul>
    </dd>
  </dlentry>
  <dlentry id="output_port_set__tuplemutationallowed">
    <dt>Изменение кортежей разрешается</dt>
    <dd>
Элемент <tt>tupleMutationAllowed</tt> указывает, разрешает ли этот оператор операторы на более низком уровне в потоке для изменения
выходных кортежей, переданных на этот порт через вызов передачи. Если задано значение true, логика обработки оператора должна ожидать, что
кортежи, которые он передает на этот порт, изменяются в результате вызова передачи.
    </dd>
  </dlentry>
  <dlentry id="output_port_set__windowpunctuationinputport">
    <dt>Входной порт прерывания окна</dt>
    <dd>
Как упоминалось выше, элемент <tt>windowPunctuationInputPort</tt> связывает входной порт с прерыванием, сохраняя выходной порт. Этот элемент можно задать, только если режим прерываний окна выходного окна - Preserving.
Для windowPunctuationInputPort можно задать значение -1, семантика которого такая же, как и у отсутствующего элемента windowPunctuationInputPort.
Важно отметить, что переадресация прерываний для прерываний окна не выполняется автоматически средой выполнения SPL (в отличие от конечных
прерываний), и используется модель оператора, чтобы проинформировать компилятор SPL о поведении, реализуемом оператором. Дополнительную информацию смотрите в книге
<i>Справочник по разработке инструментов IBM Streams Processing Language</i>.
    </dd>
  </dlentry>
  <dlentry id="output_port_set__outputassignmentportscope">
    <dt>Область портов выходного назначения</dt>
    <dd>
Элемент <tt>outputAssignmentPortScope</tt> дополнительно ограничивает то, какие атрибуты входных портов могут появиться в выходных
назначениях на этом порту.
 Если область задана, в в выходных назначениях для этого порта могут появляться только атрибуты из портов, заданных областью.
    </dd>
  </dlentry>
</dl>
</section>

<section id="parameters">
<title outputclass="splhead-1">Параметры</title>
<p>
Элемент параметра описывает действительные параметры, с использованием которых можно сконфигурировать оператор.
Он также описывает допустимый синтаксис для таких конфигураций параметра.
</p>
<dl>
  <dlentry id="parameters__allowany">
    <dt>Разрешить любой</dt>
    <dd>Этот элемент - логический флаг, указывающий, может ли оператор принимать произвольные параметры без ограничений.
Оператор может принимать произвольные параметры, и все же задавать дополнительные параметры и связанные ограничения.
    </dd><!-- Allow Any -->
  </dlentry>
  <dlentry id="parameters__parameter">
    <dt>Параметр</dt>
    <dd><p>Каждый элемент параметра содержит несколько подэлементов.
    </p>
      <dl>
       <dlentry id="parameters__parameter__name">
         <dt>Имя</dt>
         <dd>Элемент <tt>name</tt> - это имя параметра в том виде, в каком оно появится в исходном коде SPL.
Например, у оператора <tt>Functor</tt> может быть параметр <tt>filter</tt> .</dd>
       </dlentry>
       <dlentry id="parameters__parameter__description">
         <dt>Описание</dt>
         <dd>Необязательное описание этого параметра.</dd>
       </dlentry>
       <dlentry id="parameters__parameter__optional">
         <dt>Необязательный</dt>
         <dd>Логическое значение, указывающее, является ли данный параметр необязательным. Значение false подразумевает, что параметр должен быть определен в исходном коде SPL. </dd>
       </dlentry>
       <dlentry id="parameters__parameter__rewriteallowed">
         <dt>Перезапись позволена (только C++)</dt>
         <dd>Этот логический параметр позволяет компилятору перезаписывать выражения, появляющиеся в значениях этого параметра, заменяя литералы
(включая те, которые появляются в результате выполнения шага оценки во время компиляции) переменными, значения которых загружаются во время выполнения. Это позволяет компилятору генерировать меньше кода для операторов, конфигурация параметров которых отличается немного. В некоторых случаях генераторы кода оператора могут захотеть узнать значение параметра, чтобы сгенерировать другой код на основе определенного
значения или произвести проверку во время компиляции.
Например, <tt>format: csv</tt> может привести к генерированию специализированного кода для исходного оператора. В таких случаях должна быть выключена
перезапись выражения.</dd>
       </dlentry>
       <dlentry id="parameters__parameter__expressionmode">
         <dt>Режим выражения</dt>
         <dd>
           <ul>
             <li><tt>Атрибут</tt> - Ограничивает значения параметра атрибутами потока.</li>
             <li><tt>AttributeFree</tt> - Значение параметра - выражение, не содержащее ссылку на атрибут потока.</li>
             <li><tt>Constant (только C++)</tt> - Значения параметра должны оцениваться во время компиляции как константа.</li>
             <li><tt>CustomLiteral</tt> - Ограничивает значения параметра допустимыми значениями из одной из пользовательских нумераций
литералов, заданных в разделе контекста модели</li>
             <li><tt>Выражение (только C++)</tt> Наиболее гибкий режим выражения, при котором любое выражение SPL правильного типа может появиться
как значение параметра. </li>
           </ul>
         </dd>
       </dlentry>
       <dlentry id="parameters__parameter__type">
         <dt>Тип</dt>
         <dd>Элемент <tt>type</tt> для параметра - это либо тип SPL его значений (например, <tt>list&lt;ustring></tt>), либо имя
пользовательского литерала (например, <tt>SourceFormat</tt>). Тип также может быть пропущен; в этом случае подойдет любой тип SPL. У подэлемента типа параметра может быть пустое значение, семантика которого такая же, как у отсутствующего элемента типа.
         </dd>
       </dlentry>
       <dlentry id="parameters__parameter__cardinality">
         <dt>Мощность</dt>
         <dd>Максимальное число значений, которые принимает параметр. Если элемент пропущен или если значение равно -1, будет считаться, что число значений не ограничено. Число значений параметра должно соответствовать мощности. Подэлемент мощности может принимать значение -1, семантика которого такая же, как и у отсутствующего элемента мощности.
         </dd>
       </dlentry>
       <dlentry id="parameters__parameter__portScope">
         <dt>Область порта (только C++)</dt>
         <dd>Этот элемент используется, чтобы ограничить атрибуты потока, появляющиеся в значении параметра для определенного входного порта или
списка входных портов. Индексы портов начинаются с 0. Если элемент пропущен, никаких ограничений для атрибутов потока нет.
         </dd>
       </dlentry>
       <dlentry id="parameters__parameter__customOutputFunction">
         <dt>Пользовательская выходная функция (только C++)</dt>
         <dd>Этот необязательный элемент параметра указывает имя пользовательского набора выходных функций, заданного в элементе
контекста, и делает функции, заданные в этом наборе, видимыми при компиляции параметра. Обязанностью оператора является сгенерировать правильный код C++, включающий в себя пользовательские выходные функции и параметр, так же, как это
происходило бы при использовании в выходном условии.
         </dd>
       </dlentry>
      </dl>
    </dd><!-- Parameter -->
  </dlentry>
</dl> <!-- Parameters -->
</section>
</refbody>
</reference>
