/*
 * Copyright 2021 IBM Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ibm.streams.control.internal.server.consistent;

import com.api.json.JSONArray;
import com.api.json.JSONObject;
import java.math.BigInteger;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

/**
 * This thread must be started by the ControlPlane operator. It creates one MXBean for each
 * consistent cut region in the application. It uses the application PADL to understand how many
 * regions it must create. This process is offloaded to its own thread, as it can take some time and
 * it could block the creation of other operators in the application.
 */
public class ConsistentRegionSetup {

  private static final Logger trace = Logger.getLogger(ConsistentRegionSetup.class.getName());

  // Constants for annotations generated by the compiler and transformer - primitive operators
  protected static final String CC_TAG = "tag";
  protected static final String CC_REGION_ENTRY = "consistentRegionEntry";
  protected static final String CC_KEY_VALUES = "keyValues";
  protected static final String CC_INDEX = "index";
  protected static final String CC_LOGICAL_INDEX = "logicalIndex";
  protected static final String CC_IS_TRIGGER_OPERATOR = "isTriggerOperator";
  protected static final String CC_IS_START_REGION = "isStartOfRegion";
  protected static final String CC_IS_END_REGION = "isEndOfRegion";
  protected static final String CC_AUTONOMOUS_INPUT_PORT = "autonomousInputPort";
  protected static final String CC_DRAIN_TIMEOUT = "drainTimeout";
  protected static final String CC_RESET_TIMEOUT = "resetTimeout";

  // Logical view JSON attributes
  protected static final String MAIN_COMPOSITE = "mainComposite";
  protected static final String COMPOSITE_OPERATORS = "compositeOperators";
  protected static final String PRIMITIVE_OPERATORS = "primitiveOperators";
  protected static final String ANNOTATIONS = "annotations";
  protected static final String PRIMITIVE_OPERATOR_DEFS = "primitiveOperDefs";
  protected static final String OPERATOR_INDEX = "index";
  protected static final String KIND = "kind";

  // Physical view JSON attributes
  protected static final String PES = "pes";
  protected static final String ID = "id";
  protected static final String OPERATOR_NAME = "name";
  protected static final String OPERATORS = "operators";

  /**
   * Parse a primitive operator and inspect all its annotations to find new consistent regions.
   *
   * @param primitiveOp JSON description of primitive operator
   * @param consistentRegions set of discovered consistent regions
   */
  private static void discoverConsistentRegionInPrimitiveOperator(
      BigInteger jobId, JSONObject primitiveOp, Set<Integer> consistentRegions) throws Exception {
    if (primitiveOp.get(ANNOTATIONS) == null) {
      return;
    }

    JSONArray annotations = JSONArray.parse(primitiveOp.get(ANNOTATIONS).toString());
    for (Object annot : annotations) {
      JSONObject annotation = JSONObject.parse(annot.toString());
      String tag = annotation.get(CC_TAG).toString();
      if (tag.compareTo(CC_REGION_ENTRY) == 0) {
        JSONObject crEntry = JSONObject.parse(annotation.get(CC_KEY_VALUES).toString());
        Integer regionIndex = Integer.parseInt(crEntry.get(CC_INDEX).toString());

        consistentRegions.add(regionIndex);
        break;
      }
    }
  }

  /**
   * Parse a composite operator and inspect all its primitive operators to find new consistent
   * regions.
   *
   * @param compositeOp JSON description of composite operator
   * @param consistentRegions set of discovered consistent regions
   */
  private static void discoverConsistentRegionInCompositeOperator(
      BigInteger jobId, JSONObject compositeOp, Set<Integer> consistentRegions) throws Exception {
    // Go over all primitive operators in composite
    if (compositeOp.get(PRIMITIVE_OPERATORS) != null) {
      JSONArray allPrimitiveOps = JSONArray.parse(compositeOp.get(PRIMITIVE_OPERATORS).toString());
      for (Object primOp : allPrimitiveOps) {
        JSONObject primitiveOp = JSONObject.parse(primOp.toString());
        discoverConsistentRegionInPrimitiveOperator(jobId, primitiveOp, consistentRegions);
      }
    }
    // Find new composite operators in the composite operator
    if (compositeOp.get(COMPOSITE_OPERATORS) != null) {
      JSONArray allCompositeOps = JSONArray.parse(compositeOp.get(COMPOSITE_OPERATORS).toString());
      for (Object composite : allCompositeOps) {
        JSONObject innerCompositeOp = JSONObject.parse(composite.toString());
        discoverConsistentRegionInCompositeOperator(jobId, innerCompositeOp, consistentRegions);
      }
    }
  }

  /** Discover consistent regions external interface used in K8S job submission pipeline */
  public static Set<Integer> discoverConsistentRegions(final BigInteger jobId, String logicalModel)
      throws Exception {
    // Consistent regions seen so far
    final Set<Integer> consistentRegions = new HashSet<Integer>();

    JSONObject application = JSONObject.parse(logicalModel);
    JSONObject mainComposite = JSONObject.parse(application.get(MAIN_COMPOSITE).toString());

    discoverConsistentRegionInCompositeOperator(jobId, mainComposite, consistentRegions);

    trace.info("Found " + consistentRegions.size() + " consistent regions.");
    return consistentRegions;
  }

  private static Map<String, BigInteger> createPrimitiveOperatorToPeIdMapping(String physicalView)
      throws Exception {
    Map<String, BigInteger> primOperatorToPeIdMap = new HashMap<>();

    JSONObject application = JSONObject.parse(physicalView);
    JSONArray allPes = JSONArray.parse(application.get(PES).toString());
    for (Object pe : allPes) {
      JSONObject peObj = JSONObject.parse(pe.toString());

      BigInteger peId = new BigInteger(peObj.get(ID).toString());
      JSONArray operators = JSONArray.parse(peObj.get(OPERATORS).toString());
      for (Object op : operators) {
        JSONObject operator = JSONObject.parse(op.toString());
        String opName = operator.get(OPERATOR_NAME).toString();
        primOperatorToPeIdMap.put(opName, peId);
        trace.finest("Operator " + opName + " is in PE " + peId);
      }
    }
    return primOperatorToPeIdMap;
  }

  /**
   * Create a mapping between primitive operator definition index and its kind based on the
   * application logical view. This mapping is used by all consistent region controllers.
   */
  public static Map<Integer, String> createPrimitiveOperatorDefinitions(String logicalView)
      throws Exception {

    JSONObject app = JSONObject.parse(logicalView);
    Map<Integer, String> operDefIndexToOperKindMap = new HashMap<>();

    JSONArray allOperDefs = JSONArray.parse(app.get(PRIMITIVE_OPERATOR_DEFS).toString());
    for (Object operDefObj : allOperDefs) {
      JSONObject operDef = JSONObject.parse(operDefObj.toString());

      Integer defIndex = new Integer(operDef.get(OPERATOR_INDEX).toString());
      String operKind = operDef.get(KIND).toString();

      operDefIndexToOperKindMap.put(defIndex, operKind);
    }
    return operDefIndexToOperKindMap;
  }
}
