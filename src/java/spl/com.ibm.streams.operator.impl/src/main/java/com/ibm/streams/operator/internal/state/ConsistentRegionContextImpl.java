/*
 * Copyright 2021 IBM Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ibm.streams.operator.internal.state;

import static com.ibm.streams.operator.internal.logtrace.Setup.rtTrace;

import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.StreamingInput;
import com.ibm.streams.operator.Tuple;
import com.ibm.streams.operator.internal.pemodel.PEModel;
import com.ibm.streams.operator.internal.ports.RuntimeStream;
import com.ibm.streams.operator.internal.runtime.api.OperatorAdapter;
import com.ibm.streams.operator.logging.TraceLevel;
import com.ibm.streams.operator.state.Checkpoint;
import com.ibm.streams.operator.state.ConsistentRegionContext;
import com.ibm.streams.operator.state.DelegateStateHandler;
import com.ibm.streams.operator.state.OrderedStateHandlers;
import com.ibm.streams.platform.services.AnnotationAttributeValueType;
import com.ibm.streams.platform.services.AnnotationListEntryValueType;
import com.ibm.streams.platform.services.AnnotationType;
import com.ibm.streams.platform.services.PhysOperInstanceType;
import com.ibm.streams.spl.messages.Message;
import com.ibm.streams.spl.messages.general.StreamsSPLJavaMessagesKey.Key;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;
import javax.management.MalformedObjectNameException;

/**
 * Context object that provides the base implementation for ConsistentCutContext in
 * com.ibm.streams.operator. Implementation provides a read-only view of the consistent cut context
 * the user Operator is executing in.
 */
public class ConsistentRegionContextImpl implements ConsistentRegionContext {

  private static Logger trace = Logger.getLogger(ConsistentRegionContextImpl.class.getName());

  // Constants for annotations generated by the compiler and transformer - primitive operators
  public static final String CC_REGION_ENTRY = "consistentRegionEntry";
  public static final String CC_INDEX = "index";
  public static final String CC_LOGICAL_INDEX = "logicalIndex";
  public static final String CC_IS_TRIGGER_OPERATOR = "isTriggerOperator";
  public static final String CC_IS_START_REGION = "isStartOfRegion";
  public static final String CC_IS_END_REGION = "isEndOfRegion";
  public static final String CC_AUTONOMOUS_INPUT_PORT = "autonomousInputPort";
  public static final String CC_DRAIN_TIMEOUT = "drainTimeout";
  public static final String CC_RESET_TIMEOUT = "resetTimeout";

  private static final int MAX_PERMITS = Integer.MAX_VALUE;

  private static final String ANNOTATION_NAME = "consistent";
  private final boolean isStartRegion;
  private final boolean isEndRegion;
  private final boolean isTriggerOperator;
  private final float drainTimeout;
  private final float resetTimeout;
  private final int index;
  private final Set<StreamingInput<?>> inputPorts;
  private final OperatorAdapter adapter;
  private final BlockableSemaphore semaphore = new BlockableSemaphore();

  private int threadsInMakeConsistent;

  public static void addConsistentRegion(OperatorAdapter adapter, PEModel peModel)
      throws MalformedObjectNameException {
    AnnotationType annotation = getConsistentRegionAnnotation(adapter.getOperatorIndex(), peModel);
    if (annotation != null) {
      ConsistentRegionContextImpl crc = new ConsistentRegionContextImpl(adapter, annotation);

      adapter.addOptionalContext(ConsistentRegionContext.class, crc);
    }
  }

  private static AnnotationType getConsistentRegionAnnotation(int operatorIndex, PEModel peModel) {

    PhysOperInstanceType opInstance = peModel.getOperatorInstance(operatorIndex);
    List<AnnotationType> annotations = opInstance.getAnnotation();
    for (AnnotationType annotation : annotations) {

      if (!CC_REGION_ENTRY.equals(annotation.getTag())) continue;

      return annotation;
    }
    return null;
  }

  public static boolean inConsistentRegion(int operatorIndex, PEModel peModel) {

    return getConsistentRegionAnnotation(operatorIndex, peModel) != null;
  }

  ConsistentRegionContextImpl(OperatorAdapter adapter, AnnotationType regionEntry)
      throws MalformedObjectNameException {
    this.adapter = adapter;

    OperatorContext context = adapter.getContext();

    // Get the information from the PeModel using the annotation for the region for this operator.
    Set<StreamingInput<?>> inputs = null;
    if (context.getNumberOfStreamingInputs() != 0)
      inputs = new HashSet<StreamingInput<?>>(context.getStreamingInputs());

    int _index = -1;
    boolean _trigger = false;
    boolean _start = false;
    boolean _end = false;
    float _drainTimeout = -1.0f;
    float _resetTimeout = -1.0f;

    List<AnnotationAttributeValueType> attrs = regionEntry.getTuple().getAttr();

    for (AnnotationAttributeValueType regionValue : attrs) {
      final String key = regionValue.getKey();
      final String value = regionValue.getValue();

      if (CC_INDEX.equals(key)) {
        _index = Integer.parseInt(value);
      } else if (CC_IS_TRIGGER_OPERATOR.equals(key)) {
        _trigger = Boolean.parseBoolean(value);
      } else if (CC_IS_START_REGION.equals(key)) {
        _start = Boolean.parseBoolean(value);
      } else if (CC_IS_END_REGION.equals(key)) {
        _end = Boolean.parseBoolean(value);
      } else if (CC_DRAIN_TIMEOUT.equals(key)) {
        _drainTimeout = Float.parseFloat(value);
      } else if (CC_RESET_TIMEOUT.equals(key)) {
        _resetTimeout = Float.parseFloat(value);
      } else if (CC_AUTONOMOUS_INPUT_PORT.equals(key)) {
        List<AnnotationListEntryValueType> ports = regionValue.getList().getListEntry();
        for (AnnotationListEntryValueType port : ports) {
          int portIndex = Integer.parseInt(port.getValue());
          inputs.remove(context.getStreamingInputs().get(portIndex));
        }
      }
    }

    index = _index;
    isStartRegion = _start;
    isEndRegion = _end;
    isTriggerOperator = _trigger;
    drainTimeout = _drainTimeout;
    resetTimeout = _resetTimeout;

    if (inputs == null || inputs.isEmpty()) inputPorts = Collections.emptySet();
    else inputPorts = Collections.unmodifiableSet(inputs);

    // On a restart block until the reset occurs.
    if (context.getPE().getRelaunchCount() != 0) semaphore.block();
  }

  public String getName() {
    return ANNOTATION_NAME;
  }

  @Override
  public boolean isStartOfRegion() {
    return isStartRegion;
  }

  @Override
  public boolean isEndOfRegion() {
    return isEndRegion;
  }

  @Override
  public boolean isTriggerOperator() {
    return isTriggerOperator;
  }

  @Override
  public Set<StreamingInput<?>> getInputPorts() {
    return inputPorts;
  }

  @Override
  public int getIndex() {
    return index;
  }

  @Override
  public double getDrainTimeout() {
    return drainTimeout;
  }

  @Override
  public double getResetTimeout() {
    return resetTimeout;
  }

  @Override
  public long getSequenceId() {
    return adapter.getExecutionContext().getConsistentRegionSequenceId();
  }

  @Override
  public int getResetAttempt() {
    return adapter.getExecutionContext().getConsistentRegionResetAttempt();
  }

  // Call C++ here, so that we can indicate the SPL runtime that a drain
  // cannot happen
  @Override
  public synchronized void reset() throws java.io.IOException {
    adapter.getExecutionContext().resetConsistentRegion();
  }

  @Override
  public Semaphore getSubmissionSemaphore() {
    return semaphore;
  }

  @Override
  public boolean makeConsistent() {
    if (!isStartOfRegion())
      throw new IllegalStateException(
          new Message(Key.SPL_RUNTIME_OPERATOR_MUST_BE_START, "").getLocalizedMessageAndPrefix());

    synchronized (this) {
      threadsInMakeConsistent++;
    }

    try {
      return adapter.getExecutionContext().makeConsistent();
    } finally {
      synchronized (this) {
        threadsInMakeConsistent--;
      }

      // Release the permit and then re-acquire to
      // ensure that it is valid to submit tuples
      // once this method returns. See the comment
      // in block().
      rtTrace.log(
          TraceLevel.DEBUG,
          "before release permit. permits available: "
              + getSubmissionSemaphore().availablePermits());
      releasePermit();
      rtTrace.log(
          TraceLevel.DEBUG,
          "after release. permits available: " + getSubmissionSemaphore().availablePermits());
      getSubmissionSemaphore().acquireUninterruptibly();
      rtTrace.log(
          TraceLevel.DEBUG,
          "after acquire uninterrutibly. permits available: "
              + getSubmissionSemaphore().availablePermits());
    }
  }

  @Override
  public void acquirePermit() throws InterruptedException {
    getSubmissionSemaphore().acquire();
  }

  @Override
  public void releasePermit() {
    // checkForHeldPermit();
    getSubmissionSemaphore().release();
  }

  @Override
  public Runnable getPermitRunnable(final Runnable task) {
    return new Runnable() {

      @Override
      public void run() {
        getSubmissionSemaphore().acquireUninterruptibly();
        try {
          task.run();
        } finally {
          releasePermit();
        }
      }
    };
  }

  @Override
  public void enableNonBlockingCheckpoint() {
    adapter.getExecutionContext().enableNonBlockingCheckpoint();
  }

  @Override
  public DrainResult makeConsistentNonBlocking() {
    if (!isStartOfRegion())
      throw new IllegalStateException(
          new Message(Key.SPL_RUNTIME_OPERATOR_MUST_BE_START, "").getLocalizedMessageAndPrefix());

    synchronized (this) {
      threadsInMakeConsistent++;
    }

    try {
      return adapter.getExecutionContext().makeConsistentNonBlocking();
    } finally {
      synchronized (this) {
        threadsInMakeConsistent--;
      }

      // Release the permit and then re-acquire to
      // ensure that it is valid to submit tuples
      // once this method returns. See the comment
      // in block().
      rtTrace.log(
          TraceLevel.DEBUG,
          "before release permit. permits available: "
              + getSubmissionSemaphore().availablePermits());
      releasePermit();
      rtTrace.log(
          TraceLevel.DEBUG,
          "after release. permits available: " + getSubmissionSemaphore().availablePermits());
      getSubmissionSemaphore().acquireUninterruptibly();
      rtTrace.log(
          TraceLevel.DEBUG,
          "after acquire uninterrutibly. permits available: "
              + getSubmissionSemaphore().availablePermits());
    }
  }

  /**
   * Poor man's check a permit is held upon entry to a method. This will only catch cases where call
   * code does not hold a permit, but non-one else does either.
   */
  private void checkForHeldPermit() {
    if (getSubmissionSemaphore().availablePermits() == MAX_PERMITS)
      throw new IllegalStateException("Permit not acquired");
  }

  /**
   * Blocks the semaphore. Used via JNI so that the C++ Runtime can control when to stop tuple flow.
   * This is required when the reset call is dispatched to a background thread and ResetMarkers can
   * be submitted downstream before the callback executes.
   */
  public void blockPermitAcquisition() {
    rtTrace.log(TraceLevel.DEBUG, "Blocking permit acquisition");
    semaphore.block();
    rtTrace.log(TraceLevel.DEBUG, "Permits blocked");
  }

  /**
   * Unblocks the semaphore. Used via JNI so that the C++ Runtime can control when to resume tuple
   * flow.
   */
  public void releasePermitAcquisition() {
    if (isStartOfRegion()) {
      semaphore.unblock();
    }
  }

  /**
   * Creates a RuntimeStream for an input port in a consistent region that wraps the raw handler.
   * For input ports in the region we do not
   */
  public RuntimeStream<Tuple> newStreamHandler(
      final StreamingInput<Tuple> port, final RuntimeStream<Tuple> irs) {

    if (getInputPorts().contains(port)) {
      // Consistent port in the region
      return new ConsistentRegionConsistentInput<Tuple>(this.semaphore, irs);
    } else {
      // Autonomous port feeding into the region
      return new ConsistentRegionAutonomousInput<Tuple>(getSubmissionSemaphore(), irs);
    }
  }

  /**
   * Wrap the operator's state handler with the required logic for a consistent region.
   *
   * @param handler
   * @return
   */
  public DelegateStateHandler<OrderedStateHandlers> wrapStateHandler(OrderedStateHandlers handler) {
    return new DelegateStateHandler<OrderedStateHandlers>(handler) {

      /**
       * Automatically grab a permit to allow direct tuple submission from the drain method. The
       * drain method may wait for other threads submitting tuples, which requires them to hold
       * permits. Once the operator indicates the drain is complete we then block all permit
       * acquisitions and then wait for all threads to release permits.
       */
      @Override
      public void drain() throws Exception {
        super.drain();
        semaphore.block();
      }

      @Override
      public void reset(Checkpoint checkpoint) throws Exception {
        rtTrace.log(TraceLevel.DEBUG, "pre-reset");
        semaphore.block();
        super.reset(checkpoint);
        rtTrace.log(TraceLevel.DEBUG, "post-reset");
      }

      @Override
      public void resetToInitialState() throws Exception {
        rtTrace.log(TraceLevel.DEBUG, "pre-resetToInitial");
        semaphore.block();
        super.resetToInitialState();
        rtTrace.log(TraceLevel.DEBUG, "pre-resetToInitial");
      }
    };
  }

  /**
   * A semaphore where the granting of permits can be blocked, i.e. after a drain has been completed
   * and before the resume.
   */
  @SuppressWarnings("serial")
  class BlockableSemaphore extends Semaphore {
    private final Object syncMe = new Object();
    private boolean blockPermits;

    public BlockableSemaphore() {
      super(MAX_PERMITS);
    }

    private boolean isBlocked() {
      synchronized (syncMe) {
        return blockPermits;
      }
    }

    /**
     * Waits for all the permits to be acquired and then releases them all. The semaphore must be
     * blocked, and remains blocked.
     */
    void block() {

      rtTrace.log(TraceLevel.DEBUG, "before synchronized ");
      synchronized (syncMe) {
        if (blockPermits) return;
        blockPermits = true;
      }
      rtTrace.log(
          TraceLevel.DEBUG,
          "Blocking submission permit acquisition for consistent region: " + getName());

      // Need a loop here as threadsInMakeConsistent can change.
      // case 1: Other thread has grabbed a permit but not yet called
      //    makeConsistent (ie. not yet bumped threadsInMakeConsistent)
      //    thus threadsInMakeConsistent=1 on entry, but will soon be 2,
      //    reducing the number of permits we need.
      // case 2: Other thread has completed its makeConsistent but is
      //    not yet reached the decrement of threadsInMakeConsistent.
      //      two possible paths here:
      //       a) Pre-decrement - We acquire N-2 permits and proceed
      //       b) We acquire N-1 permits permits and proceed
      //       In each case, , any future submission is blocked from acquiring permits
      //       thus the fact we missed in case a) is ok, as it was just about to be released.
      //     Not in either of these case, the thread in makeConsistent releases its permit
      //     and then tries to re-acquire to ensure submission is not allowed while this
      //     makeConsistent is in progress (post drain).
      int permitsHeld = 0; // We must hold a permit upon entry.
      while (true) {
        permitsHeld += super.drainPermits();

        rtTrace.log(TraceLevel.DEBUG, "no while: " + permitsHeld);
        rtTrace.log(TraceLevel.DEBUG, "makeConsistent: " + threadsInMakeConsistent);
        rtTrace.log(TraceLevel.DEBUG, "MAX_PERMITS: " + MAX_PERMITS);

        synchronized (ConsistentRegionContextImpl.this) {
          final int permitsToAcquire = MAX_PERMITS - threadsInMakeConsistent;
          if (permitsHeld == permitsToAcquire) break;
        }
        try {
          if (super.tryAcquire(10, TimeUnit.MILLISECONDS)) permitsHeld++;
        } catch (InterruptedException e) {;
        }
      }

      rtTrace.log(
          TraceLevel.DEBUG,
          "Blocked submission permit acquisition for consistent region: " + getName());
      release(permitsHeld);
    }

    void unblock() {
      rtTrace.log(
          TraceLevel.DEBUG,
          "Unblocking submission permit acquisition for consistent region: " + getName());
      synchronized (syncMe) {
        blockPermits = false;
        syncMe.notifyAll();
      }
    }

    private final void waitUnblock() throws InterruptedException {
      synchronized (syncMe) {
        while (isBlocked()) syncMe.wait();
      }
    }

    @Override
    public void acquire() throws InterruptedException {
      rtTrace.log(TraceLevel.DEBUG, "acquiring. permits available: " + super.availablePermits());
      waitUnblock();
      super.acquire();
      rtTrace.log(TraceLevel.DEBUG, "acquired. permits available: " + super.availablePermits());
    }

    @Override
    public void release() {
      rtTrace.log(TraceLevel.DEBUG, "releasing. permits available: " + super.availablePermits());
      super.release();
      rtTrace.log(TraceLevel.DEBUG, "released. permits available: " + super.availablePermits());
    }

    @Override
    public void acquire(int permits) throws InterruptedException {
      waitUnblock();
      super.acquire(permits);
    }

    @Override
    public void acquireUninterruptibly() {
      // TODO Auto-generated method stub
      super.acquireUninterruptibly();
    }

    @Override
    public void acquireUninterruptibly(int permits) {
      // TODO Auto-generated method stub
      super.acquireUninterruptibly(permits);
    }

    @Override
    public int drainPermits() {
      if (isBlocked()) return 0;
      return super.drainPermits();
    }

    @Override
    public boolean tryAcquire() {
      if (isBlocked()) return false;
      return super.tryAcquire();
    }

    @Override
    public boolean tryAcquire(int permits) {
      if (isBlocked()) return false;
      return super.tryAcquire(permits);
    }

    @Override
    public boolean tryAcquire(int permits, long timeout, TimeUnit unit)
        throws InterruptedException {
      // TODO Auto-generated method stub
      return super.tryAcquire(permits, timeout, unit);
    }

    @Override
    public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException {
      // TODO Auto-generated method stub
      return super.tryAcquire(timeout, unit);
    }
  }
}
