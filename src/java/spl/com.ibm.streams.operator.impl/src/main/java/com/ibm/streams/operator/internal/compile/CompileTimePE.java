/*
 * Copyright 2021 IBM Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ibm.streams.operator.internal.compile;

import com.ibm.streams.operator.ProcessingElement;
import com.ibm.streams.operator.metrics.PEMetrics;
import com.ibm.streams.spl.messages.Message;
import com.ibm.streams.spl.messages.general.StreamsSPLJavaMessagesKey.Key;
import com.ibm.streams.spl.model.ToolkitType;
import java.io.File;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Map;

/**
 * Compile time representation of a ProcessingElement. Methods that are runtime only thrown an
 * IllegalStateException.
 */
final class CompileTimePE extends CompileTimeState implements ProcessingElement {

  CompileTimePE(CompileTimeSetup setup) {
    super(setup);
  }

  @Override
  public File getOutputDirectory() {
    return new File(getModel().getContext().getOutputDirectory());
  }

  @Override
  public File getDataDirectory() {
    String dataDirectory = getModel().getContext().getDataDirectory();
    if (dataDirectory == null || dataDirectory.isEmpty())
      throw new IllegalStateException(
          new Message(Key.DATA_DIRECTORY_NOT_SPECIFIED, "").getLocalizedMessageAndPrefix());
    return new File(dataDirectory);
  }

  @Override
  public boolean hasDataDirectory() {
    String dataDirectory = getModel().getContext().getDataDirectory();
    return dataDirectory != null && !dataDirectory.isEmpty();
  }

  /** {@inheritDoc} */
  @Override
  public File getApplicationDirectory() {
    return new File(getModel().getContext().getApplicationDirectory());
  }

  @Override
  public String getApplicationName() {
    throw runtimeOnly();
  }

  @Override
  public String getJobGroup() {
    throw runtimeOnly();
  }

  @Override
  public BigInteger getJobId() {
    throw runtimeOnly();
  }

  @Override
  public String getJobName() {
    throw runtimeOnly();
  }

  @Override
  public BigInteger getPEId() {
    throw runtimeOnly();
  }

  @Override
  public PEMetrics getMetrics() {
    throw runtimeOnly();
  }

  @Override
  public int getNumberOfOutputPorts() {
    throw runtimeOnly();
  }

  @Override
  public int getNumberOfInputPorts() {
    throw runtimeOnly();
  }

  @Override
  public boolean isStandalone() {
    throw runtimeOnly();
  }

  @Override
  public void setLoggerAspects(String loggerName, String... aspects) {
    throw runtimeOnly();
  }

  /** {@inheritDoc} */
  @Override
  public String getApplicationScope() {
    return getProperty(CompileTimeSetup.APPLICATION_SCOPE);
  }

  /** {@inheritDoc} */
  @Override
  public boolean isOptimized() {
    return getModel().getContext().isOptimized();
  }

  /** {@inheritDoc} */
  @Override
  public int getRelaunchCount() {
    throw runtimeOnly();
  }

  /** {@inheritDoc} */
  @Override
  public String getInstanceId() {
    throw runtimeOnly();
  }

  @Override
  public boolean isDebugging() {
    return Boolean.valueOf(getProperty(CompileTimeSetup.DEBUGGING_MODE));
  }

  @Override
  public boolean isProfilingOn() {
    return Boolean.valueOf(getProperty(CompileTimeSetup.PROFILING_MODE));
  }

  @Override
  public InetAddress getConfiguredHost() throws UnknownHostException {
    throw runtimeOnly();
  }

  @Override
  public String getDomainId() {
    throw runtimeOnly();
  }

  @Override
  public void setTagData(String tagName, Map<String, String> tagValues) {
    throw runtimeOnly();
  }

  @Override
  public Map<String, String> getApplicationConfiguration(String name) {
    throw runtimeOnly();
  }

  /**
   * {@inheritDoc}
   *
   * <p>Does a linear search through the toolkits sequence provided by the operatorInstanceModel
   * generated by the Streams compiler.
   */
  @Override
  public File getToolkitDirectory(String toolkitName) {
    File tr = null;
    for (ToolkitType tkt : getModel().getContext().getToolkits().getToolkit()) {
      if (toolkitName.equals(tkt.getName())) {
        tr = new File(tkt.getRootDirectory());
        break;
      }
    }
    return tr;
  }
}
