/*
 * Copyright 2021 IBM Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ibm.streams.operator.internal.runtime;

import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.OptionalContext;
import com.ibm.streams.operator.internal.pemodel.PEModel;
import com.ibm.streams.operator.internal.runtime.api.OperatorAdapter;
import com.ibm.streams.platform.services.AnnotationAttributeValueType;
import com.ibm.streams.platform.services.AnnotationType;
import com.ibm.streams.platform.services.PhysOperInstanceType;
import java.util.List;

/** Context object that provides the information related to the @catch annotation. */
public class CatchContext implements OptionalContext {

  public enum ExceptionKind {
    streams,
    std,
    all,
    none
  }

  // Constants for annotations generated by the compiler and transformer - primitive operators
  private static final String TUPLE_TRACE = "tupleTrace";
  private static final String STACK_TRACE = "stackTrace";
  private static final String EXCEPTION = "exception";

  private static final String ANNOTATION_NAME = "catch";
  private final boolean mustTraceTuple;
  private final boolean mustPrintStackTrace;
  private final ExceptionKind exceptionKind;
  private final OperatorAdapter adapter;

  public static void addCatchContext(OperatorAdapter adapter, PEModel peModel) {
    AnnotationType annotation = getCatchAnnotation(adapter.getOperatorIndex(), peModel);
    if (annotation != null) {
      CatchContext catchCtx = new CatchContext(adapter, annotation);
      adapter.addOptionalContext(CatchContext.class, catchCtx);
    }
  }

  private static AnnotationType getCatchAnnotation(int operatorIndex, PEModel peModel) {

    PhysOperInstanceType opInstance = peModel.getOperatorInstance(operatorIndex);
    List<AnnotationType> annotations = opInstance.getAnnotation();
    for (AnnotationType annotation : annotations) {

      if (!ANNOTATION_NAME.equals(annotation.getTag())) continue;

      return annotation;
    }
    return null;
  }

  CatchContext(OperatorAdapter adapter, AnnotationType catchAnnot) {
    this.adapter = adapter;

    OperatorContext context = adapter.getContext();

    boolean _mustTraceTuple = false;
    boolean _mustPrintStackTrace = true;
    ExceptionKind _exceptionKind = ExceptionKind.streams;

    List<AnnotationAttributeValueType> attrs = catchAnnot.getTuple().getAttr();

    for (AnnotationAttributeValueType attr : attrs) {
      final String key = attr.getKey();
      final String value = attr.getValue();

      if (EXCEPTION.equals(key)) {
        if (value.equals(ExceptionKind.streams.toString())) {
          _exceptionKind = ExceptionKind.streams;
        } else if (value.equals(ExceptionKind.std.toString())) {
          _exceptionKind = ExceptionKind.std;
        } else if (value.equals(ExceptionKind.all.toString())) {
          _exceptionKind = ExceptionKind.all;
        } else if (value.equals(ExceptionKind.none.toString())) {
          _exceptionKind = ExceptionKind.none;
        }
      } else if (TUPLE_TRACE.equals(key)) {
        _mustTraceTuple = Boolean.parseBoolean(value);
      } else if (STACK_TRACE.equals(key)) {
        _mustPrintStackTrace = Boolean.parseBoolean(value);
      }
    }

    mustTraceTuple = _mustTraceTuple;
    mustPrintStackTrace = _mustPrintStackTrace;
    exceptionKind = _exceptionKind;
  }

  public String getName() {
    return ANNOTATION_NAME;
  }

  public boolean mustTraceTuple() {
    return mustTraceTuple;
  }

  public boolean mustPrintStackTrace() {
    return mustPrintStackTrace;
  }

  public ExceptionKind getExceptionKind() {
    return exceptionKind;
  }
}
